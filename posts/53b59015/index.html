<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity 面试题 - CSharp 相关 Part 1 | Secret Garden</title><meta name="author" content="Aki_CCLing"><meta name="copyright" content="Aki_CCLing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="🟡: 代表个人还有一些理解上的问题🟢: 代表自己面试中被问到过🔴: 代表问题内容未完成 List请说明 C# 中的 List 是如何扩容的C#中的 List 是一个动态数组，其容量可以根据需要动态扩展。初始容量：List在创建时可以指定初始容量（capacity），如果没有指定，则初始容量默认为 0。 自动扩容：当添加元素导致当前容量不足时，List会自动扩容。扩容时，List会分配一个新的">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity 面试题 - CSharp 相关 Part 1">
<meta property="og:url" content="https://clearacg.com/posts/53b59015/index.html">
<meta property="og:site_name" content="Secret Garden">
<meta property="og:description" content="🟡: 代表个人还有一些理解上的问题🟢: 代表自己面试中被问到过🔴: 代表问题内容未完成 List请说明 C# 中的 List 是如何扩容的C#中的 List 是一个动态数组，其容量可以根据需要动态扩展。初始容量：List在创建时可以指定初始容量（capacity），如果没有指定，则初始容量默认为 0。 自动扩容：当添加元素导致当前容量不足时，List会自动扩容。扩容时，List会分配一个新的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg">
<meta property="article:published_time" content="2024-08-06T15:53:42.000Z">
<meta property="article:modified_time" content="2024-08-06T18:26:25.000Z">
<meta property="article:author" content="Aki_CCLing">
<meta property="article:tag" content="Technology">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Unity 面试题 - CSharp 相关 Part 1",
  "url": "https://clearacg.com/posts/53b59015/",
  "image": "https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg",
  "datePublished": "2024-08-06T15:53:42.000Z",
  "dateModified": "2024-08-06T18:26:25.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Aki_CCLing",
      "url": "https://clearacg.com/"
    }
  ]
}</script><link rel="shortcut icon" href="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/202402221339492.webp"><link rel="canonical" href="https://clearacg.com/posts/53b59015/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6ec84f1c930ef67ebd0716b3d42538a0";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;8c2bdf8651d54d3a82a47995bcb6e5cc&quot;}"></script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "mvz06k2itn");</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity 面试题 - CSharp 相关 Part 1',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/style.css?1"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background:url(https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/index/202402212340984.webp?imageSlim);background-attachment: local;background-position: center;background-size: cover;background-repeat: no-repeat;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://pic.imgdb.cn/item/65b2a3e9871b83018a2fa6bd.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> My ACG</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/outline/"><i class="fa-fw fa-solid fa-guitar"></i><span> 线下活动</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa-solid fa-play"></i><span> 追番</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-solid fa-book"></i><span> 藏书</span></a></li><li><a class="site-page child" href="/cds/"><i class="fa-fw fa fa-solid fa-compact-disc"></i><span> CD 收藏</span></a></li><li><a class="site-page child" href="/doujinshi/"><i class="fa-fw fa fa-solid fa-file"></i><span> 同人志</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fa-solid fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Secret Garden</span></a><a class="nav-page-title" href="/"><span class="site-name">Unity 面试题 - CSharp 相关 Part 1</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> My ACG</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/outline/"><i class="fa-fw fa-solid fa-guitar"></i><span> 线下活动</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa-solid fa-play"></i><span> 追番</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-solid fa-book"></i><span> 藏书</span></a></li><li><a class="site-page child" href="/cds/"><i class="fa-fw fa fa-solid fa-compact-disc"></i><span> CD 收藏</span></a></li><li><a class="site-page child" href="/doujinshi/"><i class="fa-fw fa fa-solid fa-file"></i><span> 同人志</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fa-solid fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Unity 面试题 - CSharp 相关 Part 1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-06T15:53:42.000Z" title="发表于 2024-08-06 15:53:42">2024-08-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-06T18:26:25.000Z" title="更新于 2024-08-06 18:26:25">2024-08-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology/">Technology</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology/Unity/">Unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology/Unity/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>🟡: 代表个人还有一些理解上的问题<br>🟢: 代表自己面试中被问到过<br>🔴: 代表问题内容未完成</p>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="请说明-C-中的-List-是如何扩容的"><a href="#请说明-C-中的-List-是如何扩容的" class="headerlink" title="请说明 C# 中的 List 是如何扩容的"></a>请说明 C# 中的 List 是如何扩容的</h2><p>C#中的 List<T> 是一个动态数组，其容量可以根据需要动态扩展。<br>初始容量：List<T>在创建时可以指定初始容量（capacity），如果没有指定，则初始容量默认为 0。</p>
<p>自动扩容：当添加元素导致当前容量不足时，List<T>会自动扩容。扩容时，List<T>会分配一个新的数组，并将现有元素复制到新数组中。</p>
<p>扩容倍数：扩容时，新数组的容量通常是旧容量的两倍。这种倍增策略有助于减少频繁分配内存和数据复制的开销。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个初始容量为2的List</span></span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        numbers.Add(<span class="number">1</span>);</span><br><span class="line">        numbers.Add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看当前容量</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;容量: &quot;</span> + numbers.Capacity); <span class="comment">// 输出: 容量: 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加第三个元素，触发扩容</span></span><br><span class="line">        numbers.Add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看当前容量</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;容量: &quot;</span> + numbers.Capacity); <span class="comment">// 输出: 容量: 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加更多元素</span></span><br><span class="line">        numbers.Add(<span class="number">4</span>);</span><br><span class="line">        numbers.Add(<span class="number">5</span>);<span class="comment">//触发扩容</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次查看容量</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;容量: &quot;</span> + numbers.Capacity); <span class="comment">// 输出: 容量: 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="List-扩容效率问题"><a href="#List-扩容效率问题" class="headerlink" title="List 扩容效率问题"></a>List 扩容效率问题</h2><p>下面两种获 10000 个数的方式，哪种效率更高？为什么?</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1 :</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    list.Add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式2 :</span></span><br><span class="line"><span class="built_in">float</span>[] array = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    array[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式 2 的效率更高。</p>
<p>List 本质上是一个数组，通过 Add 方法向 List 中添加元素时，如果容量不足，会触发数组扩容操作。每次扩容都会产生新的数组，导致旧数组成为垃圾，会增加内存的占用。此外，频繁的数组扩容也会增加垃圾收集（GC）的频率；数组扩容时需要将原数组中的元素搬移到新数组中，这涉及内存的拷贝和数据的移动，会影响程序的性能。<br>所以方式 2 的效率更高，因为它避免了数组扩容的操作，从而减少了内存和性能上的消耗。</p>
<h2 id="C-中-List-初始化效率比较"><a href="#C-中-List-初始化效率比较" class="headerlink" title="C#中 List 初始化效率比较"></a>C#中 List 初始化效率比较</h2><p>以下代码，谁的效率更高？为什么？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码1</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list1 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    list1.Add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码2</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list2 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    list2.Add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码 2 的效率更高。因为 List 的本质是数组，在初始化时，如果不明确指定分配多少容量，它会不断扩容。扩容会带来效率的降低和垃圾的产生。</p>
<h2 id="List-是链表还是数组"><a href="#List-是链表还是数组" class="headerlink" title="List 是链表还是数组"></a>List 是链表还是数组</h2><p>List 在 C#中实际上是基于数组实现的。尽管其名称中包含“List”，但它并不是传统意义上的链表。在 List 内部，元素存储在一个数组中，当数组大小不足时，List 会动态扩展数组的大小以容纳更多的元素。这种设计使得 List 在随机访问方面具有数组的性能，同时也能够像链表一样高效地进行插入和删除操作。</p>
<p>虽然 List 的内部实现是数组，但其提供了一系列的方法和属性，使得其用起来更像是一个动态数组而非传统的链表。因此，虽然名称上可能会让人误以为 List 是链表，但实际上它是基于数组实现的动态容器。</p>
<h2 id="List-容量满时的处理过程"><a href="#List-容量满时的处理过程" class="headerlink" title="List 容量满时的处理过程"></a>List 容量满时的处理过程</h2><p>当 List 容量满了的时候，再加入一个元素会导致效率降低，内部是什么样的执行过程？</p>
<p>当 List 的容量达到上限时，再加入一个元素会导致以下过程：</p>
<ul>
<li>数组搬家：List 内部会创建一个更大容量的新数组，并将原来的元素逐个复制到新数组中。</li>
<li>效率降低：由于数组搬家需要将原数组中的所有元素复制到新数组中，因此会导致效率降低。特别是在数据量较大时，这种效率下降会更为明显。</li>
<li>内存垃圾：数组搬家过程中会产生内存垃圾，因为需要创建新数组并复制数据。如果频繁发生数组搬家，会增加内存垃圾的产生，可能会对程序的性能造成影响。</li>
</ul>
<h2 id="请问执行以上代码后，List-中还存在哪些内容？"><a href="#请问执行以上代码后，List-中还存在哪些内容？" class="headerlink" title="请问执行以上代码后，List 中还存在哪些内容？"></a>请问执行以上代码后，List 中还存在哪些内容？</h2><p><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/1837299d071d164453.png?imageSlim"></p>
<h1 id="委托-和-事件"><a href="#委托-和-事件" class="headerlink" title="委托 和 事件"></a>委托 和 事件</h1><h2 id="委托和事件在使用上的区别是什么？"><a href="#委托和事件在使用上的区别是什么？" class="headerlink" title="委托和事件在使用上的区别是什么？"></a>委托和事件在使用上的区别是什么？</h2><p><strong>调用权限</strong>：</p>
<ul>
<li>委托：可以被外部代码直接调用。</li>
<li>事件：只能在声明它的类中调用（触发）。</li>
</ul>
<p><strong>订阅和取消订阅</strong>：</p>
<ul>
<li>委托：可以被外部代码赋值、替换、调用。</li>
<li>事件：只能被外部代码订阅（+&#x3D;）和取消订阅（-&#x3D;），不能直接赋值和调用。</li>
</ul>
<p><strong>语义和用途</strong>：</p>
<ul>
<li>委托：用于通用的回调机制，允许方法作为参数或返回值。</li>
<li>事件：用于发布-订阅模式，提供一种通知机制。</li>
</ul>
<h2 id="C-中委托的本质是什么？"><a href="#C-中委托的本质是什么？" class="headerlink" title="C#中委托的本质是什么？"></a>C#中委托的本质是什么？</h2><p>它是如何存储函数的？</p>
<h2 id="C-中的-Action-和-Func-是什么？-Unity-中的-UnityAction-是什么？-他们的区别"><a href="#C-中的-Action-和-Func-是什么？-Unity-中的-UnityAction-是什么？-他们的区别" class="headerlink" title="C# 中的 Action 和 Func 是什么？ Unity 中的 UnityAction 是什么？ 他们的区别"></a>C# 中的 Action 和 Func 是什么？ Unity 中的 UnityAction 是什么？ 他们的区别</h2><p>Action 和 Func 是 C# 中 System 命名空间下的预定义委托类型。</p>
<ul>
<li>Action 本身是一个无参数且无返回值的委托。泛型版本的 Action<T> 可以支持最多 16 个参数，但依然没有返回值。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Action action = () =&gt; Console.WriteLine(<span class="string">&quot;Hello, Action!&quot;</span>);</span><br><span class="line">action();</span><br><span class="line"></span><br><span class="line">Action&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; actionWithParameters = (number, text) =&gt; Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;number&#125;</span>: <span class="subst">&#123;text&#125;</span>&quot;</span>);</span><br><span class="line">actionWithParameters(<span class="number">1</span>, <span class="string">&quot;Hello, Action with parameters!&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Func 本身是一个无参数但有返回值的委托。泛型版本的 Func&lt;T, TResult&gt; 可以支持最多 16 个参数，并且最后一个类型参数表示返回值的类型。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>&gt; func = () =&gt; <span class="number">42</span>;</span><br><span class="line">Console.WriteLine(func());</span><br><span class="line"></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="keyword">add</span> = (a, b) =&gt; a + b;</span><br><span class="line">Console.WriteLine(<span class="keyword">add</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>UnityAction 是 UnityEngine.Events 命名空间下 Unity 提供的预定义委托类型。</p>
<ul>
<li>UnityAction 本身是一个无参数且无返回值的委托。泛型版本的 UnityAction<T> 可以支持最多 4 个参数，且无返回值。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UnityAction action = () =&gt; Debug.Log(<span class="string">&quot;Hello, UnityAction!&quot;</span>);</span><br><span class="line">        action();</span><br><span class="line"></span><br><span class="line">        UnityAction&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; actionWithParameters = (number, text) =&gt; Debug.Log(<span class="string">$&quot;<span class="subst">&#123;number&#125;</span>: <span class="subst">&#123;text&#125;</span>&quot;</span>);</span><br><span class="line">        actionWithParameters(<span class="number">1</span>, <span class="string">&quot;Hello, UnityAction with parameters!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别</p>
<ul>
<li><p>命名空间：<br>Action 和 Func 位于 System 命名空间。<br>UnityAction 位于 UnityEngine.Events 命名空间。</p>
</li>
<li><p>参数数量：<br>Action 和 Func 的泛型版本可以支持最多 16 个参数。<br>UnityAction 的泛型版本可以支持最多 4 个参数。</p>
</li>
<li><p>返回值：<br>Action 和 UnityAction 本身都没有返回值。<br>Func 委托具有返回值。</p>
</li>
</ul>
<p>Action 和 Func 是 C# 中的预定义委托，适用于一般的委托使用场景。UnityAction 是 Unity 提供的预定义委托，通常用于 Unity 事件系统中的回调函数。</p>
<h1 id="C-中事件的本质是什么？"><a href="#C-中事件的本质是什么？" class="headerlink" title="C#中事件的本质是什么？"></a>C#中事件的本质是什么？</h1><h1 id="内存管理-垃圾回收"><a href="#内存管理-垃圾回收" class="headerlink" title="内存管理 垃圾回收"></a>内存管理 垃圾回收</h1><h2 id="内存泄漏指什么？常见的内存泄漏有哪些？"><a href="#内存泄漏指什么？常见的内存泄漏有哪些？" class="headerlink" title="内存泄漏指什么？常见的内存泄漏有哪些？"></a>内存泄漏指什么？常见的内存泄漏有哪些？</h2><p>内存泄漏是指对象在超过其生命周期后不能被垃圾回收器（GC）回收，导致内存一直被占用，最终可能导致内存不足，简单说明就是那些不再需要的对象没有被及时清理掉。</p>
<p>常见的内存泄漏类型</p>
<ul>
<li>静态引用：静态字段（Static Field）持有对象的引用，这些对象会一直存在于应用程序的生命周期内，除非手动清除引用。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MemoryLeakExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;<span class="built_in">string</span>&gt; staticList = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddItem</span>(<span class="params"><span class="built_in">string</span> item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        staticList.Add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>staticList</code> 会一直持有添加的字符串，除非显式清除。</p>
<ul>
<li>未清除的引用：不使用的引用对象没有被设置为 null，导致 GC 无法回收这些对象。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MemoryLeakExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">object</span> reference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateReference</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        reference = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearReference</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        reference = <span class="literal">null</span>; <span class="comment">// 手动清除引用，允许GC回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件操作未正确释放：在进行文件或资源操作时，如果没有使用 using 语句或没有调用 Dispose 方法，资源会一直占用内存。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FileOperation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> FileStream(<span class="string">&quot;file.txt&quot;</span>, FileMode.Open))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 文件操作</span></span><br><span class="line">    &#125; <span class="comment">// using语句确保文件流被正确释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>未解除的委托或事件注册：委托或事件注册后没有解除注册，导致引用对象不能被 GC 回收。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MemoryLeakExample</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterEvent</span>(<span class="params">EventHandler handler</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyEvent += handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnregisterEvent</span>(<span class="params">EventHandler handler</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyEvent -= handler; <span class="comment">// 确保解除注册</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="请简述-GC（垃圾回收）产生的原因，并至少说出避免-GC-发生的三种方式？"><a href="#请简述-GC（垃圾回收）产生的原因，并至少说出避免-GC-发生的三种方式？" class="headerlink" title="请简述 GC（垃圾回收）产生的原因，并至少说出避免 GC 发生的三种方式？"></a>请简述 GC（垃圾回收）产生的原因，并至少说出避免 GC 发生的三种方式？</h2><p>GC 产生的原因是为了避免堆内存溢出而引入的回收机制。当不再使用的堆内存占用达到一定上限时，垃圾回收机制将会启动，以释放这些无用的内存。</p>
<p>避免方式：</p>
<ul>
<li>尽量减少创建新对象，尽量复用对象（可使用缓存池）。</li>
<li>使用 StringBuilder 替换 String，避免字符串拼接时产生垃圾。</li>
<li>公共对象用静态声明。</li>
<li>避免不必要的装箱和拆箱操作。</li>
<li>定期清理不再使用的资源和对象。</li>
</ul>
<h2 id="🟡-内存中，堆和栈的区别是什么？"><a href="#🟡-内存中，堆和栈的区别是什么？" class="headerlink" title="🟡 内存中，堆和栈的区别是什么？"></a>🟡 内存中，堆和栈的区别是什么？</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/K346K346/article/details/80849966/">https://blog.csdn.net/K346K346/article/details/80849966/</a></p>
</blockquote>
<p>栈（Stack）<br>管理方式：由操作系统自动分配和释放。<br>用途：主要存放函数的参数值、局部变量值等。<br>生命周期：栈中数据的生命周期随着函数的执行完成而结束，即当函数执行完毕后，栈中分配的内存会自动释放。<br>特点：栈内存分配速度快，但分配的内存空间较小，且存储的数据必须是固定大小的。</p>
<p>堆（Heap）<br>管理方式：一般由程序员分配和释放，如果开发人员不释放，则程序结束时由操作系统回收。在 C#中，托管堆内存由 C#帮助管理，存在垃圾回收机制（GC）。<br>用途：用于存储动态分配的内存，例如通过 new 关键字创建的对象。<br>生命周期：堆中的数据在不再使用时需要程序员手动释放，或者在托管环境中由垃圾回收机制自动回收。<br>特点：堆内存分配灵活，可以存储大块的数据，但分配和回收速度相对较慢。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 栈上分配的内存</span></span><br><span class="line">        <span class="built_in">int</span> stackVariable = <span class="number">10</span>; <span class="comment">// 栈上的局部变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 堆上分配的内存</span></span><br><span class="line">        <span class="built_in">int</span>[] heapArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]; <span class="comment">// 在堆上分配一个数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出栈变量</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;栈变量值: &quot;</span> + stackVariable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出堆变量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; heapArray.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            heapArray[i] = i * <span class="number">10</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;堆数组元素 &quot;</span> + i + <span class="string">&quot;: &quot;</span> + heapArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈上分配的内存会在函数执行完毕后自动释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存抖动指什么？如何避免内存抖动"><a href="#内存抖动指什么？如何避免内存抖动" class="headerlink" title="内存抖动指什么？如何避免内存抖动"></a>内存抖动指什么？如何避免内存抖动</h2><p>内存抖动指在短时间内大量的对象被创建或者被回收的现象。这种情况下，频繁的对象创建和回收会导致垃圾回收机制频繁运行，进而引起程序卡顿，影响性能。</p>
<p>避免内存抖动的方法：对象池是一种常用的避免内存抖动的方法。它通过预先创建一定数量的对象，并在需要时重复利用这些对象，避免了频繁的对象创建和回收过程。</p>
<h2 id="C-编程中常见的内存管理问题有哪些？"><a href="#C-编程中常见的内存管理问题有哪些？" class="headerlink" title="C#编程中常见的内存管理问题有哪些？"></a>C#编程中常见的内存管理问题有哪些？</h2><h2 id="为什么说闭包可能会带来内存泄漏？"><a href="#为什么说闭包可能会带来内存泄漏？" class="headerlink" title="为什么说闭包可能会带来内存泄漏？"></a>为什么说闭包可能会带来内存泄漏？</h2><h2 id="C-中的函数是何时被加载到内存中的呢？"><a href="#C-中的函数是何时被加载到内存中的呢？" class="headerlink" title="C#中的函数是何时被加载到内存中的呢？"></a>C#中的函数是何时被加载到内存中的呢？</h2><h1 id="🟢-装箱和拆箱是什么？"><a href="#🟢-装箱和拆箱是什么？" class="headerlink" title="🟢 装箱和拆箱是什么？"></a>🟢 装箱和拆箱是什么？</h1><p>装箱 - 把栈中内容迁移到堆中去（值类型 转 引用类型）<br>拆箱 - 把堆中内容迁移到栈中去（引用类型 转 值类型）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">object</span> o = i; <span class="comment">//装箱</span></span><br><span class="line">i = (<span class="built_in">int</span>)o; <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<h1 id="值和引用类型在变量赋值时的区别是什么？"><a href="#值和引用类型在变量赋值时的区别是什么？" class="headerlink" title="值和引用类型在变量赋值时的区别是什么？"></a>值和引用类型在变量赋值时的区别是什么？</h1><p>值类型赋值时复制值本身，而引用类型赋值时复制引用（指针）。<br>在变量赋值时，值类型和引用类型的区别主要在于它们的存储方式和行为：</p>
<p><strong>值类型（Value Types）</strong>：</p>
<ul>
<li>存储在栈（Stack）上。</li>
<li>赋值时会创建该值的副本。</li>
<li>更改副本不会影响原始变量。</li>
<li>例如：基本数据类型（int, float, bool）和结构体（struct）。</li>
</ul>
<p><strong>引用类型（Reference Types）</strong>：</p>
<ul>
<li>存储在堆（Heap）上，栈上存储指向堆内存的引用。</li>
<li>赋值时会复制引用（地址），而不是对象本身。</li>
<li>更改引用的对象会影响所有指向该对象的引用。</li>
<li>例如：类（class）、数组、字符串（string）。</li>
</ul>
<h1 id="有两个接口-IA-和-IB，他们中有一个同名方法-Test-一个类同时继承这两个接口，应该如何处理他们的同名方法？"><a href="#有两个接口-IA-和-IB，他们中有一个同名方法-Test-一个类同时继承这两个接口，应该如何处理他们的同名方法？" class="headerlink" title="有两个接口 IA 和 IB，他们中有一个同名方法 Test() 一个类同时继承这两个接口，应该如何处理他们的同名方法？"></a>有两个接口 IA 和 IB，他们中有一个同名方法 Test() 一个类同时继承这两个接口，应该如何处理他们的同名方法？</h1><p>显示实现接口<br>IA.Test()<br>IB.Test()</p>
<p>在 C#中，当一个类同时继承两个接口且接口中包含同名方法时，可以通过显式接口实现来区分这些方法。这种方法允许类实现每个接口的独立版本，从而避免命名冲突。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口IA，包含Test方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义接口IB，也包含Test方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实现两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IA</span>, <span class="title">IB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 显式实现IA的Test方法</span></span><br><span class="line">    <span class="keyword">void</span> IA.Test()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;IA.Test() implementation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式实现IB的Test方法</span></span><br><span class="line">    <span class="keyword">void</span> IB.Test()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;IB.Test() implementation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyClass.Test() implementation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用类自己的Test方法</span></span><br><span class="line">        obj.Test(); <span class="comment">// 输出：MyClass.Test() implementation</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用IA接口调用Test方法</span></span><br><span class="line">        IA objA = obj;</span><br><span class="line">        objA.Test(); <span class="comment">// 输出：IA.Test() implementation</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用IB接口调用Test方法</span></span><br><span class="line">        IB objB = obj;</span><br><span class="line">        objB.Test(); <span class="comment">// 输出：IB.Test() implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="请说说你认为-C-中-和-Equals-的区别是什么？"><a href="#请说说你认为-C-中-和-Equals-的区别是什么？" class="headerlink" title="请说说你认为 C# 中 &#x3D;&#x3D; 和 Equals 的区别是什么？"></a>请说说你认为 C# 中 &#x3D;&#x3D; 和 Equals 的区别是什么？</h1><p><code>==</code> 和 <code>Equals</code> 是用于比较对象的两种不同方式</p>
<p><code>==</code> 是一个运算符，用于比较两个操作数。</p>
<p><code>Equals</code> 是 <code>Object</code> 类中的虚方法，可以在子类中重写。</p>
<p><code>Equals</code> 方法一般用于比较两个对象的内容是否相同。默认情况下，<code>Object</code> 类中的 <code>Equals</code> 方法比较对象的引用，即判断两个对象是否是同一个实例。子类可以重写 <code>Equals</code> 方法以实现特定的比较逻辑。<br><code>==</code> 运算符在没有运算符重载的情况下，对于引用类型比较对象的引用地址，对于值类型比较对象的值是否相同。</p>
<p>一般情况下，<code>Equals</code> 方法的效率没有 <code>==</code> 运算符高，因为 <code>Equals</code> 方法通常会进行更多的比较操作。尤其是在子类中重写 <code>Equals</code> 方法时，可能会比较对象的各个字段，而 <code>==</code> 运算符通常进行简单的引用或值比较。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1：值类型比较</span></span><br><span class="line"><span class="built_in">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">5</span>;</span><br><span class="line">Console.WriteLine(a == b);      <span class="comment">// 输出：True</span></span><br><span class="line">Console.WriteLine(a.Equals(b)); <span class="comment">// 输出：True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：引用类型比较</span></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">Console.WriteLine(str1 == str2);      <span class="comment">// 输出：False，因为==比较的是引用地址</span></span><br><span class="line">Console.WriteLine(str1.Equals(str2)); <span class="comment">// 输出：True，因为Equals比较的是字符串内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3：自定义类比较</span></span><br><span class="line">MyClass obj1 = <span class="keyword">new</span> MyClass(<span class="number">1</span>, <span class="string">&quot;example&quot;</span>);</span><br><span class="line">MyClass obj2 = <span class="keyword">new</span> MyClass(<span class="number">1</span>, <span class="string">&quot;example&quot;</span>);</span><br><span class="line">Console.WriteLine(obj1 == obj2);      <span class="comment">// 输出：False，因为==比较的是引用地址</span></span><br><span class="line">Console.WriteLine(obj1.Equals(obj2)); <span class="comment">// 输出：True，因为重写的Equals方法比较的是内容</span></span><br></pre></td></tr></table></figure>

<h1 id="浅拷贝和深拷贝的区别？"><a href="#浅拷贝和深拷贝的区别？" class="headerlink" title="浅拷贝和深拷贝的区别？"></a>浅拷贝和深拷贝的区别？</h1><p>可以举例说明</p>
<p>浅拷贝（Shallow Copy）</p>
<p>浅拷贝只复制对象的引用地址，而不复制对象本身。即两个对象指向同一内存地址，修改其中一个对象的值会影响到另一个对象。当一个对象 A 被浅拷贝给另一个对象 B 时，修改对象 A 的内容会影响到对象 B。</p>
<p>深拷贝（Deep Copy）</p>
<p>深拷贝将对象及其所有值都复制一份，创建一个全新的对象。即两个对象互相独立，修改其中一个对象的值不会影响另一个对象。当一个对象 A 被深拷贝给另一个对象 B 时，修改对象 A 的内容不会影响到对象 B。</p>
<h1 id="try-和-finally-块执行顺序"><a href="#try-和-finally-块执行顺序" class="headerlink" title="try 和 finally 块执行顺序"></a>try 和 finally 块执行顺序</h1><p>请说出下方代码中<br>1.A 处和 B 处谁先打印？</p>
<p>2.A、B 出打印的 i 值分别是多少？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = GetInt();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;第A处 i =  <span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetInt</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">11</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;第B处 i =<span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B 处先打印，A 处后打印。<br>A 处 i &#x3D; 10，B 处 i &#x3D; 11。<br>解析<br>try 执行完后，finally 还是会执行。执行 GetInt 方法时，先 return i，外部得到 i&#x3D;10。由于方法中有 finally，要执行完 finally 再执行 Main 中代码，B 处打印 11。因为 i 是值类型，所以返回的 i 不收 finally 修改 i 的影响，所以 A 处打印 10.</p>
<h1 id="请问-A、B-两处-i-的值为多少？"><a href="#请问-A、B-两处-i-的值为多少？" class="headerlink" title="请问 A、B 两处 i 的值为多少？"></a>请问 A、B 两处 i 的值为多少？</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Test test = GetObj();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;第A处 i = <span class="subst">&#123;t.i&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Test <span class="title">GetObj</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Test t = <span class="keyword">new</span> Test();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        t.i = <span class="number">11</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;第B处 i = <span class="subst">&#123;t.i&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>A、B 两处 i 的值都为 11。</p>
<p>先打印 B，因为有 finally 先执行。finally 中改了 test 对象的值，t 是引用类型的，外部的 t 指向的地址和内部相同，所以改了内部外部也会打印 11。</p>
<h1 id="泛型的约束有哪几种？"><a href="#泛型的约束有哪几种？" class="headerlink" title="泛型的约束有哪几种？"></a>泛型的约束有哪几种？</h1><p>C#中泛型允许我们编写更灵活和可重用的代码。为了限制泛型参数的类型，C#提供了多种约束类型。以下是 C#中泛型的几种常见约束：</p>
<ul>
<li>值类型约束：<code>T:struct</code> 要求泛型参数必须是值类型</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// T 必须是值类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>引用类型约束：<code>T:class</code> 要求泛型参数必须是引用类型</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// T 必须是引用类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>公共无参构造函数约束：<code>T:new()</code> 要求泛型参数必须有一个公共的无参数构造函数</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">CreateInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类约束：<code>T:类名</code> 要求泛型参数必须是指定的类或其派生类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// T 必须是 MyClass 或其派生类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口约束：<code>T:接口名</code> 要求泛型参数必须实现指定的接口</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IMyInterface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// T 必须实现 IMyInterface</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型参数的约束：<code>T:U</code> 要求泛型参数必须是另一个泛型参数的类型或其派生类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">U</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// T 必须是 U 或其派生类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="🟡-什么是闭包？"><a href="#🟡-什么是闭包？" class="headerlink" title="🟡 什么是闭包？"></a>🟡 什么是闭包？</h1><p>闭包是指有权访问另一个函数作用域中的变量的函数。换句话说，闭包能够“记住”它创建时所处的环境，因此可以访问和操作该环境中的变量。通常，闭包是在一个函数内部创建的另一个函数。</p>
<p>闭包的定义<br>在 C#中，闭包通常是通过匿名方法或 Lambda 表达式实现的。闭包可以捕获并保留它在定义时所处的作用域中的变量，甚至在这个作用域已经销毁之后，依然可以访问这些变量。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个闭包</span></span><br><span class="line">        Func&lt;<span class="built_in">int</span>&gt; closure = CreateClosure();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用闭包函数</span></span><br><span class="line">        Console.WriteLine(closure()); <span class="comment">// 输出：1</span></span><br><span class="line">        Console.WriteLine(closure()); <span class="comment">// 输出：2</span></span><br><span class="line">        Console.WriteLine(closure()); <span class="comment">// 输出：3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Func&lt;<span class="built_in">int</span>&gt; <span class="title">CreateClosure</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> counter = <span class="number">0</span>; <span class="comment">// 这是闭包所捕获的外部变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个匿名函数，这个匿名函数就是一个闭包</span></span><br><span class="line">        <span class="keyword">return</span> () =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            counter++; <span class="comment">// 匿名函数可以访问和修改外部变量</span></span><br><span class="line">            <span class="keyword">return</span> counter;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="函数中对不同修饰符的变量进行运算"><a href="#函数中对不同修饰符的变量进行运算" class="headerlink" title="函数中对不同修饰符的变量进行运算"></a>函数中对不同修饰符的变量进行运算</h1><p>请问 A、B、C 三处打印结果分别为多少？为什么？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> test1Value = <span class="number">10</span>;</span><br><span class="line">    Test1(test1Value);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;A:<span class="subst">&#123;test1Value&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> test2Value = <span class="number">10</span>;</span><br><span class="line">    Test2(&amp;test2Value);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;B:<span class="subst">&#123;test2Value&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> test3Value = <span class="number">10</span>;</span><br><span class="line">    Test3(<span class="keyword">ref</span> test3Value);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;C:<span class="subst">&#123;test3Value&#125;</span>&quot;</span>);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">value</span> += <span class="number">90</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">unsafe</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test2</span>(<span class="params"><span class="built_in">int</span>* <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">value</span> += <span class="number">90</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test3</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">value</span> += <span class="number">90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A 是 10，B 和 C 为 100。</p>
<p>在 Test1 方法中，参数 value 是 <strong>按值传递</strong> 的。这意味着在函数内部，value 是在栈上重新开辟的空间，将传入参数的值拷贝到了该空间中，与传入参数 test1Value 没有关系。因此，修改 value 不会影响到 test1Value，所以 A 处的打印结果是 10。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">value</span> += <span class="number">90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Test2 方法中，参数 value 使用<strong>指针</strong>关键字，表示按指针传递。传入的是 test2Value 的地址。在函数内部，对 value 的修改会影响到外部的 test2Value，所以 B 处的打印结果是 100。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">Test2</span>(<span class="params"><span class="built_in">int</span>* <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">value</span> += <span class="number">90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Test3 方法中，参数 value 使用 ref 关键字，也表示按<strong>引用传递</strong>。不同于 ref 关键字，ref 参数在进入方法时不需要被初始化，但在方法内部必须被赋值。此处，value 的修改也会影响到外部的 test3Value，所以 C 处的打印结果是 100。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test3</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">value</span> = <span class="number">100</span>; <span class="comment">// 必须赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-重载运算符和重写-Equals-方法的意义"><a href="#C-重载运算符和重写-Equals-方法的意义" class="headerlink" title="C#重载运算符和重写 Equals 方法的意义"></a>C#重载运算符和重写 Equals 方法的意义</h1><p>C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及万物之父 Object 基类中的虚方法 virtual bool Equals(Object obj) 对于我们的意义是什么？</p>
<p><strong>重载运算符 &#x3D;&#x3D; 和 !&#x3D;</strong> ：可以自定义对象相等的判断逻辑。默认情况下，&#x3D;&#x3D; 和 !&#x3D; 操作符用于比较两个对象的引用地址，但是通过重载它们，我们可以改变比较的方式，使其根据对象的属性或字段来判断是否相等。这使得我们可以根据自己的需求定义对象相等的规则。</p>
<p><strong>重写 Equals 方法</strong>是为了提供对象相等的自定义逻辑。默认情况下，Object 类中的 Equals 方法用于比较两个对象的引用地址，即判断它们是否指向同一个内存地址。在子类中重写 Equals 方法就可以根据对象的属性或字段来判断它们是否相等。通过重写 Equals 方法，我们可以实现对象的值比较，而不仅仅是引用比较。</p>
<h1 id="C-空字符串表示"><a href="#C-空字符串表示" class="headerlink" title="C# 空字符串表示"></a>C# 空字符串表示</h1><p>请说明字符串中三者的区别</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="literal">null</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="built_in">string</span>.Empty</span><br></pre></td></tr></table></figure>

<p>这三种方式都可以用来表示空字符串，但有一些细微的区别：</p>
<p><strong>string str &#x3D; null</strong>：这种方式表示字符串变量 str 没有引用任何对象，即它在堆内存中没有分配任何内存地址，它的值是 null。尝试对其进行字符串操作可能会引发空引用异常。</p>
<p>**string str &#x3D; “”**：这种方式表示字符串变量 str 引用了一个空字符串对象，在堆内存中分配了空间，其中存储的是空字符串。它与 string.Empty 效果相同。</p>
<p><strong>string str &#x3D; string.Empty</strong>：string.Empty 是一个静态只读字段，表示一个空字符串。与 “” 相比，它更具有语义上的清晰度，可以明确表达代码意图。它在内存中只有一个实例，多个使用该字段的地方都会共享同一个实例，不会重复分配内存空间。</p>
<h1 id="string-和-StringBuilder-选择"><a href="#string-和-StringBuilder-选择" class="headerlink" title="string 和 StringBuilder 选择"></a>string 和 StringBuilder 选择</h1><p>每次对 <code>string</code> 进行修改或拼接操作时，都会在内存中创建新的字符串对象，而原始字符串对象会被标记为垃圾，等待垃圾回收器回收。这意味着频繁对 string 进行修改或拼接操作会产生大量的垃圾对象，可能会导致性能下降和内存泄漏问题。</p>
<p><code>StringBuilder</code> 是一个可变的字符串，它允许我们对字符串进行频繁的修改和拼接操作而不产生垃圾。<code>StringBuilder</code> 内部维护了一个字符数组，当需要修改字符串时，它会在原始字符数组的基础上进行修改，而不是创建新的字符串对象。另外，<code>StringBuilder</code> 会自动调整内部字符数组的大小，以容纳更多的字符，因此不需要手动管理字符串的容量。当我们需要对字符串进行频繁的修改或拼接操作时，推荐使用 <code>StringBuilder</code>。它能够有效地提高性能，减少内存占用，并避免产生大量的垃圾对象。</p>
<h1 id="数组和链表的区别是什么？"><a href="#数组和链表的区别是什么？" class="headerlink" title="数组和链表的区别是什么？"></a>数组和链表的区别是什么？</h1><ul>
<li>存储结构：数组在内存中是连续存储，链表在内存中是非连续存储。</li>
<li>访问效率：数组通过下标访问效率高，链表需要遍历效率低。</li>
<li>插入删除效率：数组插入删除需要移动元素，效率低；链表只需修改指针，效率高。</li>
<li>越界问题：数组有越界风险，链表无越界风险。</li>
</ul>
<h1 id="C-中的值和引用类型及特殊引用类型"><a href="#C-中的值和引用类型及特殊引用类型" class="headerlink" title="C# 中的值和引用类型及特殊引用类型"></a>C# 中的值和引用类型及特殊引用类型</h1><p>请问最终的打印结果是什么？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Record</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params">Record <span class="keyword">record</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">record</span>.id = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">record</span>.name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    <span class="keyword">record</span>.children[<span class="number">0</span>] = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">record</span> = <span class="keyword">new</span> Record();</span><br><span class="line"><span class="keyword">record</span>.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="keyword">record</span>.children = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">DoSomething(<span class="keyword">record</span>);</span><br><span class="line">Debug.Log(<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;-&#123;1&#125;-&#123;2&#125;&quot;</span>, <span class="keyword">record</span>.id, <span class="keyword">record</span>.name, <span class="keyword">record</span>.children[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>

<p>0-Alice-7</p>
<p>结构体是在栈上，是拷贝副本而不是引用地址。string 是特殊的引用类型，不具备你变我也变的特性。数组是引用类型，会跟着改变。</p>
<h1 id="C-中如何让自定义容器类能够使用-for-循环遍历？"><a href="#C-中如何让自定义容器类能够使用-for-循环遍历？" class="headerlink" title="C#中如何让自定义容器类能够使用 for 循环遍历？"></a>C#中如何让自定义容器类能够使用 for 循环遍历？</h1><p>通过在类中实现索引器实现。（通过 类对象[索引] 的形式遍历）</p>
<p>定义索引器：在自定义容器类中定义一个索引器，用于根据索引访问容器中的元素。<br>实现必要的方法和属性：通常需要实现 Count 属性来返回容器中元素的数量，以便 for 循环使用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomContainer</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomContainer</span>(<span class="params"><span class="built_in">int</span> size</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        items = <span class="keyword">new</span> T[size];</span><br><span class="line">        count = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引器的实现</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= count)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">&quot;索引超出范围&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> items[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= count)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">&quot;索引超出范围&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            items[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器中元素的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Count</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CustomContainer&lt;<span class="built_in">int</span>&gt; container = <span class="keyword">new</span> CustomContainer&lt;<span class="built_in">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到容器中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; container.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            container[i] = i * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 for 循环遍历容器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; container.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(container[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="🟡-C-中如何让自定义容器类能够使用-foreach-循环遍历？"><a href="#🟡-C-中如何让自定义容器类能够使用-foreach-循环遍历？" class="headerlink" title="🟡 C#中如何让自定义容器类能够使用 foreach 循环遍历？"></a>🟡 C#中如何让自定义容器类能够使用 foreach 循环遍历？</h1><p>通过为自定义容器类实现迭代器，可以使其能够使用 foreach 循环遍历。<br>语法糖方式<br>利用 yield return 语法糖，只需实现 GetEnumerator 方法即可完成迭代器的实现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyContainer</span>&lt;<span class="title">T</span>&gt; : <span class="title">IEnumerable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyContainer</span>(<span class="params"><span class="built_in">int</span> capacity</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        items = <span class="keyword">new</span> T[capacity];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; items.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            items[count++] = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> items[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="🟡-C-中接口的作用"><a href="#🟡-C-中接口的作用" class="headerlink" title="🟡 C#中接口的作用"></a>🟡 C#中接口的作用</h1><p>接口在 C# 中用于建立行为的继承关系，而不是对象的继承关系。它提供了一种抽象的方式来定义一组方法、属性、事件等，不包含实现细节。</p>
<ul>
<li>行为抽象：接口定义了一组行为（方法、属性等），任何实现这个接口的类都必须提供这些行为的具体实现。这使得我们可以通过接口来抽象不同对象的相同行为，而不关心这些对象的具体实现细节。</li>
<li>多态性：接口允许不同类实现相同的接口，从而实现多态性。可以用接口类型的变量来引用不同的实现类对象，通过调用接口方法来实现不同对象的多态行为。这使得代码更加灵活和可扩展。</li>
<li>解耦合：接口通过定义行为契约，将使用接口的代码与接口实现的代码解耦合。这样，可以在不改变使用接口的代码的情况下，替换接口的具体实现。这有助于提高代码的可维护性和可测试性。</li>
<li>行为整合：当不同对象具有相同行为时，可以利用接口对这些对象的行为进行整合。接口可以看作是一种协议，保证不同对象实现一致的行为。</li>
</ul>
<p>例如，不同类型的动物类都可以实现一个 IMovable 接口，统一定义移动行为。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMovable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口的类1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IMovable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Car is moving&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口的类2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> : <span class="title">IMovable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Person is walking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用接口类型的变量来引用不同的实现类对象</span></span><br><span class="line">        IMovable movable1 = <span class="keyword">new</span> Car();</span><br><span class="line">        IMovable movable2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用接口方法</span></span><br><span class="line">        movable1.Move(); <span class="comment">// 输出: Car is moving</span></span><br><span class="line">        movable2.Move(); <span class="comment">// 输出: Person is walking</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="请问这三行代码，运行后，在堆上会分配几个空间"><a href="#请问这三行代码，运行后，在堆上会分配几个空间" class="headerlink" title="请问这三行代码，运行后，在堆上会分配几个空间"></a>请问这三行代码，运行后，在堆上会分配几个空间</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> str3 = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这三行代码后，在堆上会分配 2 个空间</p>
<p>“123” 一个房间。<br>“1234” 一个房间。</p>
<p>在 C# 中，字符串是不可变的。当你将字符串赋值或重新分配时，会创建新的字符串对象并分配新的内存空间。因此，在这三行代码中，两个不同的字符串 “123” 和 “1234” 会分别在堆上创建新的内存空间。</p>
<h1 id="C-中如何让一个类不能再被其他类所继承"><a href="#C-中如何让一个类不能再被其他类所继承" class="headerlink" title="C#中如何让一个类不能再被其他类所继承"></a>C#中如何让一个类不能再被其他类所继承</h1><p>使用密封关键字<code>sealed</code>修饰该类。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="C-中使用泛型的好处"><a href="#C-中使用泛型的好处" class="headerlink" title="C#中使用泛型的好处"></a>C#中使用泛型的好处</h1><ul>
<li>提升代码复用率：泛型允许为不同类型对象的相同行为进行通用处理，从而减少重复代码，提高代码的复用性和可维护性。</li>
<li>提升性能：泛型避免了值类型的装箱和拆箱操作，从而提高了程序的运行性能。装箱和拆箱是将值类型转换为引用类型（装箱）和从引用类型转换为值类型（拆箱）的过程，这些操作会带来额外的性能开销。</li>
</ul>
<h1 id="C-中元组的作用"><a href="#C-中元组的作用" class="headerlink" title="C#中元组的作用"></a>C#中元组的作用</h1><ul>
<li>多返回值：可以在不用写数据结构类的情况下，利用元组处理方法的多返回值。</li>
<li>临时数据集合：适用于临时存储和传递多个相关的数据，而不需要定义专门的数据结构。</li>
</ul>
<p>元组提供了一种简洁的方式来组合多个值，对于处理临时数据和简化代码具有很大的帮助。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">double</span>, <span class="built_in">int</span>) t1 = (<span class="number">4.5</span>, <span class="number">3</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Tuple with elements <span class="subst">&#123;t1.Item1&#125;</span> and <span class="subst">&#123;t1.Item2&#125;</span>.&quot;</span>);</span><br><span class="line"><span class="comment">//使用Item + 序号访问</span></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Tuple with elements 4.5 and 3.</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">double</span> Sum, <span class="built_in">int</span> Count) t2 = (<span class="number">4.5</span>, <span class="number">3</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Sum of <span class="subst">&#123;t2.Count&#125;</span> elements is <span class="subst">&#123;t2.Sum&#125;</span>.&quot;</span>);</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Sum of 3 elements is 4.5.</span></span><br></pre></td></tr></table></figure>

<h1 id="🟡-请说明-Thread、ThreadPool、Task-分别是什么？并简单说明彼此的区别"><a href="#🟡-请说明-Thread、ThreadPool、Task-分别是什么？并简单说明彼此的区别" class="headerlink" title="🟡 请说明 Thread、ThreadPool、Task 分别是什么？并简单说明彼此的区别"></a>🟡 请说明 Thread、ThreadPool、Task 分别是什么？并简单说明彼此的区别</h1><ul>
<li>Thread：线程，可以使用它开启线程处理复杂逻辑，避免主线程卡顿。每次创建新线程时，都需要分配资源，开销较大。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread t;</span><br><span class="line"></span><br><span class="line">t = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//print(transform.position);//报错 不能使用主线程相关类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t.Start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//不停止线程的话开启的线程会和Unity编辑器进程共生死</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    t.Abort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>ThreadPool：线程池，C#为线程实现的缓存池，主要用于减少线程的创建和销毁，减少 GC 触发的频率，提高性能。管理线程的集合，用于执行短时间的并行操作。通过重用线程来减少开销，避免频繁创建和销毁线程。适合大量小任务的场景，不适合长时间运行的任务。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPool类中的QueueUserWorkItem方法 将方法排入队列以便执行，当线程池中线程变得可用时执行</span></span><br><span class="line">ThreadPool.QueueUserWorkItem((obj) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    print(obj);<span class="comment">//NULL</span></span><br><span class="line">    print(<span class="string">&quot;开启了一个线程&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数可以设置obj对象</span></span><br><span class="line">ThreadPool.QueueUserWorkItem((obj) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">print(obj);<span class="comment">//666</span></span><br><span class="line">print(<span class="string">&quot;开启了一个线程&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的执行顺序不可控 比如如下循环将线程入队 可能不会按顺序打印</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool.QueueUserWorkItem((obj) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;第&quot;</span> + obj + <span class="string">&quot;个任务&quot;</span>);</span><br><span class="line">    &#125;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Task：任务，基于线程池的优化，让我们可以更方便地控制和管理线程。基于 ThreadPool 实现，提供更高层次的抽象。支持异步编程模型，可以方便地处理并行操作和等待任务完成。提供了更好的错误处理和取消任务的机制。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TaskExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task task = Task.Run(() =&gt; DoWork());</span><br><span class="line">        task.Wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoWork</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Task is working&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="如果我们想为-Unity-中的-Transform-类添加一个自定义的方法，应该如何处理？"><a href="#如果我们想为-Unity-中的-Transform-类添加一个自定义的方法，应该如何处理？" class="headerlink" title="如果我们想为 Unity 中的 Transform 类添加一个自定义的方法，应该如何处理？"></a>如果我们想为 Unity 中的 Transform 类添加一个自定义的方法，应该如何处理？</h1><p>使用 C#的拓展方法（Extension Methods）来实现。</p>
<p>拓展方法是 C#的一种语法特性，允许开发者在不修改原始类定义的情况下，向现有类添加新的方法。</p>
<p>以下是添加自定义方法的一般步骤：</p>
<p>创建一个静态类，并在类中定义静态方法。这个类应该是静态的，且不可继承。<br>在方法的第一个参数前加上 this 关键字，并指定要扩展的类的类型。这样编译器就知道这个方法是一个拓展方法。<br>在方法内部实现自定义的逻辑。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TransformExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自定义方法，用于输出Transform的位置信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintPosition</span>(<span class="params"><span class="keyword">this</span> Transform transform</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;Position: <span class="subst">&#123;transform.position&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用这个拓展方法 :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Transform playerTransform = GetComponent&lt;Transform&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用自定义的拓展方法</span></span><br><span class="line">        playerTransform.PrintPosition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="using-关键字的两个作用"><a href="#using-关键字的两个作用" class="headerlink" title="using 关键字的两个作用"></a>using 关键字的两个作用</h1><p>使用关键字 <code>using</code> 在 C# 中有以下两个主要作用：</p>
<ul>
<li><p>引入命名空间：<br>使用 using 关键字可以将命名空间引入当前代码文件，使得其中定义的类型和成员可以直接使用，而无需使用完整的命名空间路径来引用。</p>
</li>
<li><p>安全使用引用对象：<br>在 C# 中，using 关键字还可以用于安全地使用引用对象。在 C# 中，using 关键字还可用于安全地使用引用对象。使用 using 关键字创建的代码块可以确保在代码块结束时释放资源，即使在代码块内发生异常，也会执行资源释放操作，从而避免资源泄漏。</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UsingExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 示例1：引入命名空间</span></span><br><span class="line">            <span class="keyword">using</span> System.IO;</span><br><span class="line">            <span class="built_in">string</span>[] files = Directory.GetFiles(<span class="string">@&quot;C:\&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">string</span> <span class="keyword">file</span> <span class="keyword">in</span> files)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="keyword">file</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 示例2：安全使用引用对象</span></span><br><span class="line">            <span class="keyword">using</span> (StreamReader reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;example.txt&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(reader.ReadToEnd());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="🟡-C-中-Dictionary-相同键对应多个值"><a href="#🟡-C-中-Dictionary-相同键对应多个值" class="headerlink" title="🟡 C#中 Dictionary 相同键对应多个值"></a>🟡 C#中 Dictionary 相同键对应多个值</h1><p>如果想要一个键对应多个值如何处理？</p>
<p>在 C#中，Dictionary 是一种键值对集合，每个键必须是唯一的，因此不支持相同键存储。如果想要一个键对应多个值，可以使用 Dictionary&lt;TKey, List<TValue>&gt; 等数据结构来处理。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Dictionary，键为 string 类型，值为 List&lt;int&gt; 类型</span></span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">int</span>&gt;&gt; multiValueDict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向 Dictionary 中添加键值对</span></span><br><span class="line">        AddKeyValuePair(multiValueDict, <span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        AddKeyValuePair(multiValueDict, <span class="string">&quot;key1&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        AddKeyValuePair(multiValueDict, <span class="string">&quot;key2&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        AddKeyValuePair(multiValueDict, <span class="string">&quot;key2&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印所有键值对</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> multiValueDict)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123;pair.Key&#125;</span>: &quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> pair.Value)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">value</span>&#125;</span> &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 Dictionary 中添加键值对，如果键已存在，则将值添加到对应的 List 中</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddKeyValuePair</span>(<span class="params">Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">int</span>&gt;&gt; dict, <span class="built_in">string</span> key, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dict.ContainsKey(key))</span><br><span class="line">        &#123;</span><br><span class="line">            dict[key] = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        dict[key].Add(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="委托和闭包中的变量捕获"><a href="#委托和闭包中的变量捕获" class="headerlink" title="委托和闭包中的变量捕获"></a>委托和闭包中的变量捕获</h1><p>请问下面代码的最终打印结果是什么？为什么？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Action action = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        action += () =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    action();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的最终打印结果是全都是 10。</p>
<p>这是因为在 C# 中，闭包会捕获外部作用域的变量。在循环体内，委托 actionList[i] 中的 i 是对外部变量 i 的引用，而不是值的拷贝。在循环结束后，i 的值已经变为了 10。因此，无论在什么时候调用委托，都会打印出 10。</p>
<h1 id="🔴-上题中的代码，如果我们希望打印出-0-9，应该如何修改代码？"><a href="#🔴-上题中的代码，如果我们希望打印出-0-9，应该如何修改代码？" class="headerlink" title="🔴 上题中的代码，如果我们希望打印出 0~9，应该如何修改代码？"></a>🔴 上题中的代码，如果我们希望打印出 0~9，应该如何修改代码？</h1><h1 id="buff-系统中，如何用一个-byte，记录多种-buff-状态标识"><a href="#buff-系统中，如何用一个-byte，记录多种-buff-状态标识" class="headerlink" title="buff 系统中，如何用一个 byte，记录多种 buff 状态标识"></a>buff 系统中，如何用一个 byte，记录多种 buff 状态标识</h1><p>在 buff 系统中，我们可以使用一个 byte 来记录多种 buff 状态标识。由于一个 byte 有 8 位，我们可以让每一位代表一种状态，其中 0 代表无，1 代表有。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个byte类型的变量来记录buff状态</span></span><br><span class="line"><span class="built_in">byte</span> buffType = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态标识位示例:</span></span><br><span class="line"><span class="comment">// 0000 0000: 初始状态，无buff</span></span><br><span class="line"><span class="comment">// 0000 0001: 中毒 buff</span></span><br><span class="line"><span class="comment">// 0000 0010: 灼烧 buff</span></span><br><span class="line"><span class="comment">// 0000 0100: 回复 buff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加状态时，进行 或 ( | ) 运算</span></span><br><span class="line">buffType |= <span class="number">0x02</span>; <span class="comment">// 添加灼烧 buff，结果为 0000 0010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加多个状态示例:</span></span><br><span class="line">buffType |= <span class="number">0x01</span>; <span class="comment">// 添加中毒 buff，结果为 0000 0011</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除状态时，进行 异或 ( ^ ) 运算</span></span><br><span class="line">buffType ^= <span class="number">0x01</span>; <span class="comment">// 移除中毒 buff，结果为 0000 0010</span></span><br></pre></td></tr></table></figure>

<h1 id="文件中文本信息乱码的原因"><a href="#文件中文本信息乱码的原因" class="headerlink" title="文件中文本信息乱码的原因"></a>文件中文本信息乱码的原因</h1><p>文件中保存了文本信息，但是打开后却是乱码，一般是什么原因造成的？</p>
<p>文件中文本信息乱码的原因是因为序列化和反序列化字符串时使用的编码格式不统一。</p>
<p>当文本信息在进行序列化时，如果使用了不同的编码格式，比如在写入文件时使用 UTF-8 编码，但在读取文件时使用了 ANSI 编码，就会导致读取出来的文本信息是乱码的情况。</p>
<p>为了避免文件中文本信息乱码的问题，应该在序列化和反序列化字符串时统一使用相同的编码格式。</p>
<h1 id="C-中-new-关键字的作用（至少说出-3-种）"><a href="#C-中-new-关键字的作用（至少说出-3-种）" class="headerlink" title="C#中 new 关键字的作用（至少说出 3 种）"></a>C#中 new 关键字的作用（至少说出 3 种）</h1><ul>
<li>创建新对象：最基本的用途是使用 new 关键字来实例化一个类，创建新的对象。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj = <span class="keyword">new</span> MyClass();</span><br></pre></td></tr></table></figure>

<ul>
<li>方法隐藏：当在子类中声明一个与父类方法名称相同的方法时，可以使用 new 关键字来隐藏父类方法，使子类的方法覆盖父类的方法。这种方法称为方法隐藏。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Parent class method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Child</span> : <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Child class method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型约束中使用 new 关键词：在泛型约束中使用 new 关键字表示需要无参构造函数的类型参数。这种约束要求泛型类型参数必须具有公共的无参数构造函数。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// T必须具有无参数构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="同步方法和异步方法的区别是什么？"><a href="#同步方法和异步方法的区别是什么？" class="headerlink" title="同步方法和异步方法的区别是什么？"></a>同步方法和异步方法的区别是什么？</h1><p>异步编程是什么意思？对于我们来说，什么时候需要使用异步编程？（至少说出 3 种）</p>
<p>同步方法：当一个方法被调用时，调用者需要等待该方法执行完毕后返回才能继续执行。</p>
<p>异步方法：当一个方法被调用时立即返回，并获取一个线程执行该方法内部的逻辑，调用者不用等待该方法执行完毕。</p>
<p>异步编程的意义：异步编程是指在日常开发中，将一些不需要立即得到结果且耗时的逻辑设置为异步执行的编程方式。它的意义在于提高程序的运行效率，避免由于复杂逻辑带来的线程阻塞，从而提升系统的响应性和性能。</p>
<p>什么时候需要使用异步编程：异步编程的主要目的是提高程序的并发性和性能，使得程序能够更高效地利用系统资源，处理各种耗时操作，从而提升整体的系统响应速度和用户体验。</p>
<ul>
<li><p>复杂逻辑计算：比如寻路算法等复杂计算任务，这些任务可能会耗费较长时间，使用异步编程可以让主线程不被阻塞，保持系统的响应性。</p>
</li>
<li><p>网络通信：在进行网络下载、网络通讯等操作时，由于网络请求可能会有一定的延迟，使用异步编程可以避免阻塞主线程，提高系统的并发性和网络通信效率。</p>
</li>
<li><p>资源加载：在进行大量资源加载时，如加载大型纹理、模型等资源，这些操作可能会消耗较长的时间，使用异步加载可以让主线程保持流畅，提升用户体验。</p>
</li>
</ul>
<h1 id="🟡-回调函数指什么？一般在什么时候使用？（至少说出-3-种使用场景）"><a href="#🟡-回调函数指什么？一般在什么时候使用？（至少说出-3-种使用场景）" class="headerlink" title="🟡 回调函数指什么？一般在什么时候使用？（至少说出 3 种使用场景）"></a>🟡 回调函数指什么？一般在什么时候使用？（至少说出 3 种使用场景）</h1><p>在程序设计中，回调函数指的是将一个函数作为参数传递给另一个函数，并在另一个函数执行完毕后被调用的函数。在 C#中，回调函数一般以委托的形式出现。</p>
<ul>
<li>异步编程：当需要执行一些异步逻辑，并在异步逻辑执行完毕后执行某些操作时，可以使用回调函数。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> DoAsyncWork(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;异步逻辑执行完毕，执行回调函数。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DoAsyncWork</span>(<span class="params">Action callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 异步逻辑执行完毕后调用回调函数</span></span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">        callback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件中心：在事件驱动的编程模型中，可以使用回调函数来响应事件的触发。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">EventPublisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">string</span>&gt; OnEventTriggered;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TriggerEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnEventTriggered?.Invoke(<span class="string">&quot;事件触发了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> publisher = <span class="keyword">new</span> EventPublisher();</span><br><span class="line">        publisher.OnEventTriggered += (message) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        publisher.TriggerEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UI 界面中的控件逻辑回调：在 UI 界面中，当用户触发某些操作（如按钮点击）时，可以使用回调函数来执行相应的逻辑。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ButtonClickHandler</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Button button = GetComponent&lt;Button&gt;();</span><br><span class="line">        button.onClick.AddListener(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;按钮被点击了！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何用一个-int-变量，记录-32-种状态？（注意：状态可以并存）"><a href="#如何用一个-int-变量，记录-32-种状态？（注意：状态可以并存）" class="headerlink" title="如何用一个 int 变量，记录 32 种状态？（注意：状态可以并存）"></a>如何用一个 int 变量，记录 32 种状态？（注意：状态可以并存）</h1><p>每一位代表一个状态，1 表示存在，0 表示不存在。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义一个状态变量，初始值为0</span></span><br><span class="line">        <span class="built_in">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置第 1 种状态为存在</span></span><br><span class="line">        status |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>);  <span class="comment">// 将第 1 位设为 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置第 5 种状态为存在</span></span><br><span class="line">        status |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>);  <span class="comment">// 将第 5 位设为 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断第 1 种状态是否存在</span></span><br><span class="line">        <span class="built_in">bool</span> isFirstStateExist = (status &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) != <span class="number">0</span>;  <span class="comment">// 检查第 1 位是否为 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断第 2 种状态是否存在</span></span><br><span class="line">        <span class="built_in">bool</span> isSecondStateExist = (status &amp; (<span class="number">1</span> &lt;&lt; <span class="number">1</span>)) != <span class="number">0</span>;  <span class="comment">// 检查第 2 位是否为 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;第 1 种状态是否存在：&quot;</span> + isFirstStateExist);  <span class="comment">// 输出: 第 1 种状态是否存在：True</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;第 2 种状态是否存在：&quot;</span> + isSecondStateExist); <span class="comment">// 输出: 第 2 种状态是否存在：False</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="CSharp-中常用的接口-IDispose-的作用"><a href="#CSharp-中常用的接口-IDispose-的作用" class="headerlink" title="CSharp 中常用的接口 IDispose 的作用"></a>CSharp 中常用的接口 IDispose 的作用</h1><p>IDispose 接口是 C# 中用于手动释放资源的机制。通过显式调用 Dispose() 方法来实现资源的释放，避免资源泄漏和浪费。它允许对象在不再需要时显式地释放资源，而不依赖于垃圾回收器的自动内存管理。</p>
<h1 id="CSharp-中垃圾回收机制和-IDispose-接口的关系"><a href="#CSharp-中垃圾回收机制和-IDispose-接口的关系" class="headerlink" title="CSharp 中垃圾回收机制和 IDispose 接口的关系"></a>CSharp 中垃圾回收机制和 IDispose 接口的关系</h1><p>CSharp 有垃圾回收机制，把一个对象设置为空的时候，系统会帮我们回收，它和接口 IDispose 有什么关系吗？为什么会存在两个做析构事情的东西呢？</p>
<p>C#中的垃圾回收机制，只会回收托管堆上分配的对象。对于非托管资源以及其它需要显示释放的资源，垃圾回收是无法自动处理的，因为这些资源不属于托管堆，因此垃圾回收器无法自动识别和回收。这种情况下我们就需要显式地手动释放这些资源了。</p>
<p>而 IDisposable 接口就提供了一种通用的机制来进行资源清理，主要用于释放非托管资源。</p>
<p>非托管资源可以包括但不限于：</p>
<ul>
<li>文件句柄，在操作系统中打开的文件等</li>
<li>数据库链接，与数据库服务器建立的链接</li>
<li>网络链接，例如 Socket 的连接对象</li>
<li>在 unsafe 关键词中使用的指针等</li>
</ul>
<p>通过实现 IDisposable 接口，我们可以在对象被销毁时执行资源的释放工作，确保非托管资源得到正确地释放，从而避免资源泄露和内存泄漏的问题。</p>
<h1 id="C-中哪些变量类型是值类型（至少说出-13-种），哪些是引用该类型（至少说出-5-种）"><a href="#C-中哪些变量类型是值类型（至少说出-13-种），哪些是引用该类型（至少说出-5-种）" class="headerlink" title="C#中哪些变量类型是值类型（至少说出 13 种），哪些是引用该类型（至少说出 5 种）"></a>C#中哪些变量类型是值类型（至少说出 13 种），哪些是引用该类型（至少说出 5 种）</h1><p>值类型直接包含其数据，存储在栈中</p>
<table>
<thead>
<tr>
<th align="center">int</th>
<th align="center">byte</th>
<th align="center">ulong</th>
<th align="center">char</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float</td>
<td align="center">short</td>
<td align="center">ushort</td>
<td align="center">bool</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">long</td>
<td align="center">sbyte</td>
<td align="center">自定义结构体（struct）</td>
</tr>
<tr>
<td align="center">uint</td>
<td align="center">decimal</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>引用类型存储在堆中，并通过引用（即指针）访问其数据</p>
<ul>
<li>自定义类（class）</li>
<li>数组（array）</li>
<li>字符串（string）</li>
<li>委托（delegate）</li>
<li>接口（interface）</li>
<li>Object（万物之父）</li>
</ul>
<h1 id="自定义类和结构体成员变量的存储位置"><a href="#自定义类和结构体成员变量的存储位置" class="headerlink" title="自定义类和结构体成员变量的存储位置"></a>自定义类和结构体成员变量的存储位置</h1><ol>
<li>在自定义类中声明的成员变量，类型为 int，该 int 变量存储在栈上还是堆上？</li>
<li>在自定义结构体中声明的成员变量，类型为 string，该 string 变量存储在栈上还是堆上？</li>
</ol>
<p>一、堆上<br>在自定义类中声明的成员变量，无论其类型如何，都会存储在堆上。类是引用类型，其实例存储在堆上，成员变量也存储在该实例所指向的内存区域（堆上）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> myInt; <span class="comment">// 存储在堆上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">        obj.myInt = <span class="number">10</span>; <span class="comment">// myInt 存储在堆上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、堆上<br>在结构体变量中的引用类型成员实际上会存储在堆上。虽然结构体本身是值类型，存储在栈上，但如果结构体的成员包含引用类型，那么引用类型的对象会存储在堆上，而结构体的实例内部会包含对这些堆上对象的引用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> myString; <span class="comment">// myString 的内容存储在堆上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyStruct myStruct = <span class="keyword">new</span> MyStruct();</span><br><span class="line">        myStruct.myString = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// myString 的实际字符串内容存储在堆上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接口和抽象类使用上的区别"><a href="#接口和抽象类使用上的区别" class="headerlink" title="接口和抽象类使用上的区别"></a>接口和抽象类使用上的区别</h1><p>C#中在什么情况下会选择使用接口，什么情况下会选择使用抽象类？</p>
<p>接口（Interface）: 不同对象的共同行为，当你需要定义一组不相关的类具有相同的行为时，使用接口是一个好的选择。接口可以提供一个公共的行为规范，但不涉及具体实现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFlyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同类实现相同接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bird</span> : <span class="title">IFlyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 实现飞行行为</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Airplane</span> : <span class="title">IFlyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 实现飞行行为</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要多继承时：</p>
<p>C#不支持类的多继承，但支持接口的多继承。如果一个类需要继承多个行为规范，可以使用接口。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWalkable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Walk</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISwimmable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swim</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两栖动物 继承两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Amphibian</span> : <span class="title">IWalkable</span>, <span class="title">ISwimmable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Walk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 实现行走行为</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Swim</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实现游泳行为</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类（Abstract Class）<br>同类对象的共同行为：</p>
<p>当你需要定义一组相关的类共享相同的行为和状态时，使用抽象类。抽象类可以提供公共的实现和字段。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：定义一个抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实现狗叫声</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实现猫叫声</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享成员变量：当你需要定义共享的成员变量或方法实现时，可以使用抽象类。抽象类允许定义具体的成员变量和部分实现。</p>
<h1 id="🟡-C-中托管内存和非托管内存"><a href="#🟡-C-中托管内存和非托管内存" class="headerlink" title="🟡 C#中托管内存和非托管内存"></a>🟡 C#中托管内存和非托管内存</h1><p>托管内存是由<code>.NET</code> 运行时（CLR，Common Language Runtime）进行管理的内存。C#中大部分对象都是托管内存，它们的内存分配、回收和资源管理都由 CLR 负责。CLR 提供了自动垃圾回收机制（GC），可以自动检测不再使用的对象并释放它们占用的内存，从而避免了内存泄漏问题。</p>
<p>我们平时声明的引用类型的变量都属于托管内存：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个托管内存的示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example example = <span class="keyword">new</span> Example();</span><br></pre></td></tr></table></figure>

<p>非托管内存是由应用程序自己负责管理的内存，通常是通过调用本机 API 或与外部系统进行交互时使用的。非托管内存不受 CLR 的管理，这意味着它不会受到垃圾回收的影响。开发人员需要自己负责内存的分配和释放，否则可能会导致内存泄漏或者访问无效内存的问题。</p>
<p>我们平时在 unsafe 语句块中声明的指针成员，数据库链接对象，Socket 通讯对象，文件流等对象都存在非托管内存，需要我们自己释放：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个非托管内存的示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">class</span> <span class="title">UnsafeExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UsePointer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>\* p = <span class="keyword">stackalloc</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 使用指针进行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非托管资源，我们需要使用如 IDisposable 接口来手动释放资源：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个非托管内存的示例，使用 IDisposable 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnmanagedResource</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IntPtr unmanagedPointer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnmanagedResource</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分配非托管内存</span></span><br><span class="line">        unmanagedPointer = Marshal.AllocHGlobal(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 释放非托管内存</span></span><br><span class="line">        <span class="keyword">if</span> (unmanagedPointer != IntPtr.Zero)</span><br><span class="line">        &#123;</span><br><span class="line">            Marshal.FreeHGlobal(unmanagedPointer);</span><br><span class="line">            unmanagedPointer = IntPtr.Zero;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用非托管资源</span></span><br><span class="line">UnmanagedResource resource = <span class="keyword">new</span> UnmanagedResource();</span><br><span class="line">resource.Dispose();</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://clearacg.com">Aki_CCLing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://clearacg.com/posts/53b59015/">https://clearacg.com/posts/53b59015/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://clearacg.com" target="_blank">Secret Garden</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Technology/">Technology</a><a class="post-meta__tags" href="/tags/Unity/">Unity</a></div><div class="post-share"><div class="social-share" data-image="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/56e313ff/" title="国内二次元相关展会概览 &amp; 逛展推荐"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/qungz.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">国内二次元相关展会概览 & 逛展推荐</div></div><div class="info-2"><div class="info-item-1">Bilibili World (BW)Bilibili World 是哔哩哔哩弹幕网举办的线下大型展会，简称 BW。    时间 名称 地点 备注    2017 年 7 月 21 日 - 23 日 Bilibili World 2017 上海世博展览馆 -   2018 年 7 月 20 日 - 22 日 Bilibili World 2018     2019 年 8 月 16 日 - 18 日 Bilibili World 2019 广州 保利世贸博览馆    2019 年 10 月 4 日 - 6 日 Bilibili World 2019 上海 上海世博展览馆    2019 年 12 月 21 日 - 22 日 Bilibili World 2019 成都 成都世纪城新国际会展中心    2020 年 8 月 7 日 - 9 日 Bilibili World 2020 上海 国家会展中心 (上海)    2020 年 12 月 26 日 - 27 日 Bilibili World 2020 广州 中国进出口商品交易会展馆    2021 年 7 月 9 日 - 11...</div></div></div></a><a class="pagination-related" href="/posts/32f3e24e/" title="Unity 面试题 - Unity 相关 Part 1"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Unity 面试题 - Unity 相关 Part 1</div></div><div class="info-2"><div class="info-item-1">🟡: 代表个人还有一些理解上的问题🟢: 代表自己面试中被问到过🔴: 代表问题内容未完成 Unity 工作原理 &amp; 脚本基础Unity 引擎中哪些功能使用了 C#的反射功能？至少说出一点通过反射，Unity 能够动态地访问和操作代码中的元数据，实现了很多自动化和灵活的功能，使得开发者在使用 Unity 进行游戏开发时能够更加方便和高效。 Inspector 窗口中显示的内容：Unity 通过反射来显示和编辑脚本中定义的字段和属性。在 Inspector 窗口中显示的内容是通过反射自动生成的，开发者不需要手动编写 Inspector 窗口的代码。 预设体文件：预设体（Prefabs）中的字段和属性值也通过反射进行存储和恢复。这使得在编辑器中可以方便地保存和加载复杂的对象状态。 场景文件：场景文件中对象的序列化和反序列化过程也依赖于反射。通过反射，Unity 可以在场景文件中保存对象的状态，并在加载场景时恢复这些状态。 Unity 中的各种特性（Attributes）：Unity...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/978bdfbc/" title="Unity 学习路线"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-05</div><div class="info-item-2">Unity 学习路线</div></div><div class="info-2"><div class="info-item-1"> 内容参考：课程内容及架构 : 唐老狮 唐老狮的 B 站空间内容整理、面试题整理 : 人间自有韬哥在 人间自有韬哥在的博客盘子 ssa : 盘子 ssa&#x2F;个人学习笔记litfire : 2024 年 Unity 面试题和日常问题总结  CSharp目录传送门 : CSharp 知识目录 CSharp 入门文章传送门 : CSharp 入门 知识点主要内容包括变量、常量、转义字符、类型转换、异常捕获、运算符、条件分支语句、循环语句 CSharp 基础文章传送门 : CSharp 基础主要包括枚举、数组、值类型和引用类型、函数（ref 和 out、参数、重载、递归）、结构体、冒泡排序、递归排序 CSharp 核心文章传送门 : CSharp 核心 主要包括枚举、面向对象（封装、继承、多态） 封装：类和对象、成员变量、成员方法、构造函数、析构函数、成员属性、索引器、静态成员、静态类和静态构造函数、拓展方法、运算符重载 继承：里氏替换原则、继承中的构造函数、万物之父和装箱拆箱、密封类 多态：Vob、抽象类和抽象方法、接口、密封方法 以及七大原则 CSharp 进阶文章传送门...</div></div></div></a><a class="pagination-related" href="/posts/1c8fef53/" title="Unity 面试题 - CSharp 相关 Part 2"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-07</div><div class="info-item-2">Unity 面试题 - CSharp 相关 Part 2</div></div><div class="info-2"><div class="info-item-1">请问什么是线程安全？如何在 C#中实现线程安全操作？C#中属性(Property)和字段(Field)的区别是什么？请解释一下 C#中的异步编程模型（Async&#x2F;Await），它是用来做什么的？请问七大排序算法一般指哪七种排序算法？你一般常用的排序算法是哪种？请简单描述它的排序原理 请简单描述斐波那契数列的基本规则是什么请简单描述 A 星寻路算法的基本原理抽象类中的虚函数和抽象函数，是否必须在子类中重写？当我们使用里式替换原则，用父类容器装载子类对象时我们通过该父类容器调用其中的一个虚函数，执行的逻辑是父类中的还是子类中的逻辑呢？ 我们在游戏开发时，想要获取系统时间，应该如何获取？C#使用 var 声明临时变量相比用指定变量类型声明临时变量，在最终执行时是否会增加性能消耗？int a &#x3D; 10;int b &#x3D; a;b &#x3D; 20;我们知道，上述代码 b 改为 20 后，a 还是 10。（值类型的特点）我们是否可以简单修改以上代码，让 b 变成 20 后，a 跟着一起变。请说出修改方案 我们可以使用...</div></div></div></a><a class="pagination-related" href="/posts/cbdf6728/" title="Unity 面试题 - Lua 相关"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-06</div><div class="info-item-2">Unity 面试题 - Lua 相关</div></div><div class="info-2"><div class="info-item-1">热更新流程简述获取对比文件：从远程服务器下载一个用于对比的文件，该文件记录了当前可用资源的版本号或哈希值等信息。 对比本地资源和远程资源：将下载的对比文件与本地保存的对比文件进行比较，以确定本地资源和远程资源之间的差异。根据比较结果，确定需要更新的资源和需要移除的资源。 资源更新和移除：下载远程服务器上与本地资源不同的更新文件，并覆盖本地对应的资源文件，或者直接将更新的资源文件添加到本地资源目录。根据对比结果，删除本地不再需要的资源文件。 更新对比文件：将下载的远程对比文件替换本地保存的对比文件，以保持本地对比文件与服务器端一致，为下一次热更新做准备。 在 Unity 中 AssetBundle 的压缩方式有不压缩、LZMA、LZ4 三种，请问 LZMA 和 LZ4 有什么区别？🟡 Lua 面向对象的三大特性Lua 如何实现面向对象的三大特性 封装：可以通过 table 进行实现。在 Lua 中，我们可以将对象的属性和方法放入一个 table 中，然后对该 table 进行操作，从而达到封装的效果。 1234567891011121314151617Object =...</div></div></div></a><a class="pagination-related" href="/posts/32f3e24e/" title="Unity 面试题 - Unity 相关 Part 1"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-06</div><div class="info-item-2">Unity 面试题 - Unity 相关 Part 1</div></div><div class="info-2"><div class="info-item-1">🟡: 代表个人还有一些理解上的问题🟢: 代表自己面试中被问到过🔴: 代表问题内容未完成 Unity 工作原理 &amp; 脚本基础Unity 引擎中哪些功能使用了 C#的反射功能？至少说出一点通过反射，Unity 能够动态地访问和操作代码中的元数据，实现了很多自动化和灵活的功能，使得开发者在使用 Unity 进行游戏开发时能够更加方便和高效。 Inspector 窗口中显示的内容：Unity 通过反射来显示和编辑脚本中定义的字段和属性。在 Inspector 窗口中显示的内容是通过反射自动生成的，开发者不需要手动编写 Inspector 窗口的代码。 预设体文件：预设体（Prefabs）中的字段和属性值也通过反射进行存储和恢复。这使得在编辑器中可以方便地保存和加载复杂的对象状态。 场景文件：场景文件中对象的序列化和反序列化过程也依赖于反射。通过反射，Unity 可以在场景文件中保存对象的状态，并在加载场景时恢复这些状态。 Unity 中的各种特性（Attributes）：Unity...</div></div></div></a><a class="pagination-related" href="/posts/2f9ec35b/" title="Unity 面试题 - Unity 相关 Part 2"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-07</div><div class="info-item-2">Unity 面试题 - Unity 相关 Part 2</div></div><div class="info-2"><div class="info-item-1">🟡: 代表个人还有一些理解上的问题🟢: 代表自己面试中被问到过🔴: 代表问题内容未完成 Unity 3D 数学Unity 场景中有两个点连成了一条线，想要旋转这条线，应该怎么做？首先，将两点相减得到一条向量,然后将该向量乘以所需的旋转四元数。 123456789101112131415161718192021using UnityEngine;public class LineRotation : MonoBehaviour&#123;    public Transform point1;    public Transform point2;    public Quaternion rotationQuaternion;    void Update()    &#123;        // 计算两点的向量        Vector3 lineVector = point2.position - point1.position;        // 对向量进行旋转        Vector3 rotatedLineVector =...</div></div></div></a><a class="pagination-related" href="/posts/ac98fa8d/" title="Unity 面试题 &amp; 日常问题"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-18</div><div class="info-item-2">Unity 面试题 &amp; 日常问题</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/65b2a3e9871b83018a2fa6bd.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Aki_CCLing</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/AkiCCLing" target="_blank" title="GitHub"><i class="fa-brands fa-github" style="color: #1E3050;"></i></a><a class="social-icon" href="https://space.bilibili.com/5840406" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color: #FF6699;"></i></a><a class="social-icon" href="https://steamcommunity.com/id/AKIYC/" target="_blank" title="Steam"><i class="fa-brands fa-steam" style="color: #1E3050;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一个ACGN爱好者的Blog，有问题与我交流可在Bilibili 留言 / 私信，谢谢你的关注。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#List"><span class="toc-number">1.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E6%98%8E-C-%E4%B8%AD%E7%9A%84-List-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="toc-number">1.1.</span> <span class="toc-text">请说明 C# 中的 List 是如何扩容的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-%E6%89%A9%E5%AE%B9%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">List 扩容效率问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD-List-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.</span> <span class="toc-text">C#中 List 初始化效率比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-%E6%98%AF%E9%93%BE%E8%A1%A8%E8%BF%98%E6%98%AF%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">List 是链表还是数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-%E5%AE%B9%E9%87%8F%E6%BB%A1%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">List 容量满时的处理过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E9%97%AE%E6%89%A7%E8%A1%8C%E4%BB%A5%E4%B8%8A%E4%BB%A3%E7%A0%81%E5%90%8E%EF%BC%8CList-%E4%B8%AD%E8%BF%98%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">请问执行以上代码后，List 中还存在哪些内容？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A7%94%E6%89%98-%E5%92%8C-%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">委托 和 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%9C%A8%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">委托和事件在使用上的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E5%A7%94%E6%89%98%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">C#中委托的本质是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84-Action-%E5%92%8C-Func-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-Unity-%E4%B8%AD%E7%9A%84-UnityAction-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">C# 中的 Action 和 Func 是什么？ Unity 中的 UnityAction 是什么？ 他们的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">C#中事件的本质是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">4.</span> <span class="toc-text">内存管理 垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">内存泄漏指什么？常见的内存泄漏有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0-GC%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%B9%B6%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA%E9%81%BF%E5%85%8D-GC-%E5%8F%91%E7%94%9F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">请简述 GC（垃圾回收）产生的原因，并至少说出避免 GC 发生的三种方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9F%A1-%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">🟡 内存中，堆和栈的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8"><span class="toc-number">4.4.</span> <span class="toc-text">内存抖动指什么？如何避免内存抖动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">C#编程中常见的内存管理问题有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E9%97%AD%E5%8C%85%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">为什么说闭包可能会带来内存泄漏？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%98%AF%E4%BD%95%E6%97%B6%E8%A2%AB%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">4.7.</span> <span class="toc-text">C#中的函数是何时被加载到内存中的呢？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9F%A2-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">🟢 装箱和拆箱是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">值和引用类型在变量赋值时的区别是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3-IA-%E5%92%8C-IB%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95-Test-%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%90%8C%E6%97%B6%E7%BB%A7%E6%89%BF%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%96%E4%BB%AC%E7%9A%84%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">有两个接口 IA 和 IB，他们中有一个同名方法 Test() 一个类同时继承这两个接口，应该如何处理他们的同名方法？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E8%AF%B4%E4%BD%A0%E8%AE%A4%E4%B8%BA-C-%E4%B8%AD-%E5%92%8C-Equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">请说说你认为 C# 中 &#x3D;&#x3D; 和 Equals 的区别是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">浅拷贝和深拷贝的区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#try-%E5%92%8C-finally-%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text">try 和 finally 块执行顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E9%97%AE-A%E3%80%81B-%E4%B8%A4%E5%A4%84-i-%E7%9A%84%E5%80%BC%E4%B8%BA%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">请问 A、B 两处 i 的值为多少？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">泛型的约束有哪几种？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9F%A1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">🟡 什么是闭包？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E5%AF%B9%E4%B8%8D%E5%90%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%90%E7%AE%97"><span class="toc-number">14.</span> <span class="toc-text">函数中对不同修饰符的变量进行运算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E5%86%99-Equals-%E6%96%B9%E6%B3%95%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">15.</span> <span class="toc-text">C#重载运算符和重写 Equals 方法的意义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA"><span class="toc-number">16.</span> <span class="toc-text">C# 空字符串表示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string-%E5%92%8C-StringBuilder-%E9%80%89%E6%8B%A9"><span class="toc-number">17.</span> <span class="toc-text">string 和 StringBuilder 选择</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">数组和链表的区别是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%B9%E6%AE%8A%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.</span> <span class="toc-text">C# 中的值和引用类型及特殊引用类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8%E7%B1%BB%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8-for-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">C#中如何让自定义容器类能够使用 for 循环遍历？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9F%A1-C-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8%E7%B1%BB%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8-foreach-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">🟡 C#中如何让自定义容器类能够使用 foreach 循环遍历？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9F%A1-C-%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">22.</span> <span class="toc-text">🟡 C#中接口的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E9%97%AE%E8%BF%99%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BF%90%E8%A1%8C%E5%90%8E%EF%BC%8C%E5%9C%A8%E5%A0%86%E4%B8%8A%E4%BC%9A%E5%88%86%E9%85%8D%E5%87%A0%E4%B8%AA%E7%A9%BA%E9%97%B4"><span class="toc-number">23.</span> <span class="toc-text">请问这三行代码，运行后，在堆上会分配几个空间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8D%E8%83%BD%E5%86%8D%E8%A2%AB%E5%85%B6%E4%BB%96%E7%B1%BB%E6%89%80%E7%BB%A7%E6%89%BF"><span class="toc-number">24.</span> <span class="toc-text">C#中如何让一个类不能再被其他类所继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">25.</span> <span class="toc-text">C#中使用泛型的好处</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E5%85%83%E7%BB%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">26.</span> <span class="toc-text">C#中元组的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9F%A1-%E8%AF%B7%E8%AF%B4%E6%98%8E-Thread%E3%80%81ThreadPool%E3%80%81Task-%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%B9%B6%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E%E5%BD%BC%E6%AD%A4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">27.</span> <span class="toc-text">🟡 请说明 Thread、ThreadPool、Task 分别是什么？并简单说明彼此的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E6%83%B3%E4%B8%BA-Unity-%E4%B8%AD%E7%9A%84-Transform-%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">如果我们想为 Unity 中的 Transform 类添加一个自定义的方法，应该如何处理？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#using-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BD%9C%E7%94%A8"><span class="toc-number">29.</span> <span class="toc-text">using 关键字的两个作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9F%A1-C-%E4%B8%AD-Dictionary-%E7%9B%B8%E5%90%8C%E9%94%AE%E5%AF%B9%E5%BA%94%E5%A4%9A%E4%B8%AA%E5%80%BC"><span class="toc-number">30.</span> <span class="toc-text">🟡 C#中 Dictionary 相同键对应多个值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%92%8C%E9%97%AD%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7"><span class="toc-number">31.</span> <span class="toc-text">委托和闭包中的变量捕获</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%B4-%E4%B8%8A%E9%A2%98%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E5%B8%8C%E6%9C%9B%E6%89%93%E5%8D%B0%E5%87%BA-0-9%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">🔴 上题中的代码，如果我们希望打印出 0~9，应该如何修改代码？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#buff-%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E4%B8%AA-byte%EF%BC%8C%E8%AE%B0%E5%BD%95%E5%A4%9A%E7%A7%8D-buff-%E7%8A%B6%E6%80%81%E6%A0%87%E8%AF%86"><span class="toc-number">33.</span> <span class="toc-text">buff 系统中，如何用一个 byte，记录多种 buff 状态标识</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%AD%E6%96%87%E6%9C%AC%E4%BF%A1%E6%81%AF%E4%B9%B1%E7%A0%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">34.</span> <span class="toc-text">文件中文本信息乱码的原因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD-new-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA-3-%E7%A7%8D%EF%BC%89"><span class="toc-number">35.</span> <span class="toc-text">C#中 new 关键字的作用（至少说出 3 种）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">同步方法和异步方法的区别是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9F%A1-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%80%E8%88%AC%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%EF%BC%9F%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA-3-%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="toc-number">37.</span> <span class="toc-text">🟡 回调函数指什么？一般在什么时候使用？（至少说出 3 种使用场景）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E4%B8%AA-int-%E5%8F%98%E9%87%8F%EF%BC%8C%E8%AE%B0%E5%BD%95-32-%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F%EF%BC%88%E6%B3%A8%E6%84%8F%EF%BC%9A%E7%8A%B6%E6%80%81%E5%8F%AF%E4%BB%A5%E5%B9%B6%E5%AD%98%EF%BC%89"><span class="toc-number">38.</span> <span class="toc-text">如何用一个 int 变量，记录 32 种状态？（注意：状态可以并存）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3-IDispose-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">39.</span> <span class="toc-text">CSharp 中常用的接口 IDispose 的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSharp-%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C-IDispose-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">40.</span> <span class="toc-text">CSharp 中垃圾回收机制和 IDispose 接口的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA-13-%E7%A7%8D%EF%BC%89%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%BC%95%E7%94%A8%E8%AF%A5%E7%B1%BB%E5%9E%8B%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA-5-%E7%A7%8D%EF%BC%89"><span class="toc-number">41.</span> <span class="toc-text">C#中哪些变量类型是值类型（至少说出 13 种），哪些是引用该类型（至少说出 5 种）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">42.</span> <span class="toc-text">自定义类和结构体成员变量的存储位置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">43.</span> <span class="toc-text">接口和抽象类使用上的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9F%A1-C-%E4%B8%AD%E6%89%98%E7%AE%A1%E5%86%85%E5%AD%98%E5%92%8C%E9%9D%9E%E6%89%98%E7%AE%A1%E5%86%85%E5%AD%98"><span class="toc-number">44.</span> <span class="toc-text">🟡 C#中托管内存和非托管内存</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/91f34db4/" title="杭州 ACGN 地点游玩推荐 / 攻略"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/69553946_p0.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="杭州 ACGN 地点游玩推荐 / 攻略"/></a><div class="content"><a class="title" href="/posts/91f34db4/" title="杭州 ACGN 地点游玩推荐 / 攻略">杭州 ACGN 地点游玩推荐 / 攻略</a><time datetime="2025-10-22T18:17:26.000Z" title="发表于 2025-10-22 18:17:26">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/602d5f17/" title="日本旅行1st"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/noet8h3s.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="日本旅行1st"/></a><div class="content"><a class="title" href="/posts/602d5f17/" title="日本旅行1st">日本旅行1st</a><time datetime="2025-10-22T03:51:24.000Z" title="发表于 2025-10-22 03:51:24">2025-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/45e232e1/" title="签名 &amp; 合影 收藏"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/qungz.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="签名 &amp; 合影 收藏"/></a><div class="content"><a class="title" href="/posts/45e232e1/" title="签名 &amp; 合影 收藏">签名 &amp; 合影 收藏</a><time datetime="2025-10-09T12:50:39.000Z" title="发表于 2025-10-09 12:50:39">2025-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1161385d/" title="广州 ACGN 地点游玩推荐 / 攻略"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/69553946_p0.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="广州 ACGN 地点游玩推荐 / 攻略"/></a><div class="content"><a class="title" href="/posts/1161385d/" title="广州 ACGN 地点游玩推荐 / 攻略">广州 ACGN 地点游玩推荐 / 攻略</a><time datetime="2025-02-19T00:41:54.000Z" title="发表于 2025-02-19 00:41:54">2025-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/37d9abb5%60/" title="Unity 面试高频题"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity 面试高频题"/></a><div class="content"><a class="title" href="/posts/37d9abb5%60/" title="Unity 面试高频题">Unity 面试高频题</a><time datetime="2024-08-26T02:07:45.000Z" title="发表于 2024-08-26 02:07:45">2024-08-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Aki_CCLing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20238180" target="_blank">萌ICP备20238180号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://venerable-smakager-94ad33.netlify.app/.netlify/functions/twikoo',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://venerable-smakager-94ad33.netlify.app/.netlify/functions/twikoo',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>