<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CSharp 核心 | Secret Garden</title><meta name="author" content="Aki_CCLing"><meta name="copyright" content="Aki_CCLing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面向对象的三大特性封装 : 用程序语言来形容对象继承 ：复用封装对象的代码；儿子继承父亲，复用现成代码多态：同样行为的不同表现，儿子继承父亲基因但是有不同的行为表现类（class 关键词） 封装类和对象基本概念 一般在 namespace 中声明，命名所以首字母大小。 具有相同特征、相同行为的一类事物的抽象，类是对象的模板，可以通过类创建对象。 关键词：class 类的声明和类对象声明是两个概念：">
<meta property="og:type" content="article">
<meta property="og:title" content="CSharp 核心">
<meta property="og:url" content="https://clearacg.com/posts/fd651bad/index.html">
<meta property="og:site_name" content="Secret Garden">
<meta property="og:description" content="面向对象的三大特性封装 : 用程序语言来形容对象继承 ：复用封装对象的代码；儿子继承父亲，复用现成代码多态：同样行为的不同表现，儿子继承父亲基因但是有不同的行为表现类（class 关键词） 封装类和对象基本概念 一般在 namespace 中声明，命名所以首字母大小。 具有相同特征、相同行为的一类事物的抽象，类是对象的模板，可以通过类创建对象。 关键词：class 类的声明和类对象声明是两个概念：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/65b2aa8b871b83018a3e31ec.jpg">
<meta property="article:published_time" content="2024-02-21T20:22:45.000Z">
<meta property="article:modified_time" content="2024-07-22T23:42:12.000Z">
<meta property="article:author" content="Aki_CCLing">
<meta property="article:tag" content="Technology">
<meta property="article:tag" content="Code">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/65b2aa8b871b83018a3e31ec.jpg"><link rel="shortcut icon" href="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/202402221339492.webp"><link rel="canonical" href="https://clearacg.com/posts/fd651bad/index.html"><link rel="preconnect" href="https://cdn.staticfile.org"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/5.0.33/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6ec84f1c930ef67ebd0716b3d42538a0";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;8c2bdf8651d54d3a82a47995bcb6e5cc&quot;}"></script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "mvz06k2itn");</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.staticfile.org/egjs-infinitegrid/4.11.1/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CSharp 核心',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-22 23:42:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css?1"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/65b2a3e9871b83018a2fa6bd.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-music"></i><span> 追番</span></a></li><li><a class="site-page child" href="/game/"><i class="fa-fw fas fa-video"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-solid fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/65b2aa8b871b83018a3e31ec.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Secret Garden"><span class="site-name">Secret Garden</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-music"></i><span> 追番</span></a></li><li><a class="site-page child" href="/game/"><i class="fa-fw fas fa-video"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-solid fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CSharp 核心</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-21T20:22:45.000Z" title="发表于 2024-02-21 20:22:45">2024-02-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-22T23:42:12.000Z" title="更新于 2024-07-22 23:42:12">2024-07-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology/">Technology</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology/Unity/">Unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology/Unity/CSharp/">CSharp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CSharp 核心"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h1><p>封装 : 用程序语言来形容对象<br>继承 ：复用封装对象的代码；儿子继承父亲，复用现成代码<br>多态：同样行为的不同表现，儿子继承父亲基因但是有不同的行为表现<br>类（class 关键词）</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>一般在 namespace 中声明，命名所以首字母大小。</li>
<li>具有相同特征、相同行为的一类事物的抽象，类是对象的模板，可以通过类创建对象。</li>
<li>关键词：<code>class</code></li>
<li>类的声明和类对象声明是两个概念：</li>
<li>类的声明类似枚举和结构体的声明，相当于是声明了一个自定义的变量类型，用来抽象现实实物的。</li>
<li>对象是类创建出来的，是用来表象现实中的对象个体。对象的声明相当于声明一个指定类的变量。类创建对象的过程称之为实例化对象。</li>
<li>类和对象都是引用类型的。</li>
<li><code>null</code>：空引用类型为 null 的时候指的是内存堆没有分配。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//特征——成员变量</span></span><br><span class="line">    <span class="comment">//行为——成员方法</span></span><br><span class="line">    <span class="comment">//保护特征——成员属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数和析构函数</span></span><br><span class="line">    <span class="comment">//索引器</span></span><br><span class="line">    <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="comment">//静态成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例化对象的基本语法"><a href="#实例化对象的基本语法" class="headerlink" title="实例化对象的基本语法"></a>实例化对象的基本语法</h3><p>用<code>new</code>来完成实例化。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类名 变量名； 			 //（没用分配堆内存）</span></span><br><span class="line"><span class="comment">//类名 变量名 = null；	 //（没用分配堆内存）</span></span><br><span class="line"><span class="comment">//类名 变量名 = new 类名；	//（在堆中新开了个房间）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Les</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Machine</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//类名 变量名； 			 //（没用分配堆内存）</span></span><br><span class="line">            Person p;</span><br><span class="line">            <span class="comment">//类名 变量名 = null；	 //（没用分配堆内存）</span></span><br><span class="line">            Person p2 = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//类名 变量名 = new 类名；	//（在堆中新开了个房间）</span></span><br><span class="line">            Person p3 = <span class="keyword">new</span> Person();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员变量和访问修饰符"><a href="#成员变量和访问修饰符" class="headerlink" title="成员变量和访问修饰符"></a>成员变量和访问修饰符</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>用于描述对象的特征，可以是任意变量类型（枚举，结构体，类对象）。是否赋值根据需求而定。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//特征——成员变量</span></span><br><span class="line">    <span class="comment">//行为——成员方法</span></span><br><span class="line">    <span class="comment">//保护特征——成员属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数和析构函数</span></span><br><span class="line">    <span class="comment">//索引器</span></span><br><span class="line">    <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="comment">//静态成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要声明一个和自己相同类型的成员变量时，不能对它进行实例化（会死循环！！）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不能这么做，会死循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    Person boy = <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员变量的使用和初始值"><a href="#成员变量的使用和初始值" class="headerlink" title="成员变量的使用和初始值"></a>成员变量的使用和初始值</h3><p>默认的初始值，对值类型来说都是 0（bool 为 false），引用类型来说都是 null</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">default</span>(变量);   <span class="comment">// 可以得到一个变量的默认值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> b;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">char</span> c;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------</span></span><br><span class="line">Person r = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//点出来使用，和结构体一样</span></span><br><span class="line"><span class="built_in">int</span> a =r. a;</span><br><span class="line">Console.WriteLine(<span class="literal">default</span>(<span class="built_in">int</span>));</span><br></pre></td></tr></table></figure>

<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul>
<li><code>public</code>: 公开的，所有对象都能访问和使用。</li>
<li><code>private</code>: 私有的，只有自己内部才能访问和使用，变量前不写默认为该状态。</li>
<li><code>protected</code>: 只有自己内部和子类才能访问和使用，继承的时候用到。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> b;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>和结构体中函数的声明使用差不多，用来描述对象的行为, 在类中声明。<br>受访问修饰符的影响，不需要加<code>static</code>关键字。成员方法需要实例化才能使用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person类中增加朋友的数组的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//特征——成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> nanme;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> high;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> Person[] friend;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//行为——成员方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 扩容friend数组</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;p&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFriend</span>(<span class="params">Person p</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (friend ==<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            friend = <span class="keyword">new</span> Person[] &#123; p &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数组扩容+1</span></span><br><span class="line">            Person[] newFriend = <span class="keyword">new</span> Person[friend.Length + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; friend.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                newFriend[i] = friend[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将新成员p存在新数组的最后一个索引</span></span><br><span class="line">            newFriend[newFriend.Length - <span class="number">1</span>] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在实例化对象时会调用的用于初始化的函数，如果不写就默认存在一个无参构造函数<br>和结构体中构造函数的写法一致，（类允许自己申明一个无参构造函数 结构体是不允许的）<br>无返回值，函数名和类名必须相同，一般都是 public，可以重载构造函数<br>声明有参构造函数之前最好一起声明一个无参构造函数，声明有参构造时默认的无参构造就不存在了，要手动声明</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//特征——成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> nanme;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> high;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> Person[] friend;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数 实现对象实例化时 初始化</span></span><br><span class="line">    <span class="comment">//构造函数可以重载</span></span><br><span class="line">    <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        nanme = <span class="string">&quot;苏同学&quot;</span>;</span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">        sex = <span class="literal">true</span>;</span><br><span class="line">        high = <span class="number">180</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age,<span class="built_in">bool</span> sex,<span class="built_in">float</span> high</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.high = high;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">//在main主函数中 使用构造函数初始化对象</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;苏同学&quot;</span>,<span class="number">18</span>,<span class="literal">true</span>,<span class="number">180f</span>);</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;李同学&quot;</span>, <span class="number">18</span>, <span class="literal">false</span>, <span class="number">171f</span>);</span><br></pre></td></tr></table></figure>

<p>特殊写法 （构造函数的继承）较少使用<br>在构造函数后添加 :this(指定的重载参数)<br>可以实现执行该构造函数前执行 this 指定的构造函数</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    nanme = <span class="string">&quot;苏同学&quot;</span>;</span><br><span class="line">    age = <span class="number">18</span>;</span><br><span class="line">    sex = <span class="literal">true</span>;</span><br><span class="line">    high = <span class="number">180</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造函数，this指定了先执行无参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age,<span class="built_in">bool</span> sex,<span class="built_in">float</span> high</span>):<span class="title">this</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    <span class="keyword">this</span>.high = high;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>当引用类型的堆内存被回收时，会调用该函数。对于需要手动管理内存的语言（比如 C++），需要在析构函数中做一些内存回收处理。C#中有自动垃圾回收机制 GC，所以几乎不使用析构函数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">     ~Person()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>垃圾回收, 英文简写 GC (Garbage Collector)。垃圾回收的过程是在遍历堆(HEAP)上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是垃圾，哪些对象仍要被使用。所谓的垃圾就是没有被任何变量、对象引用的内容。垃圾就需要被回收释放。</p>
<p>垃圾回收有很多种算法，比如：</p>
<ul>
<li>引用计数(Reference Counting)</li>
<li>标记清除(Mark Sweep)</li>
<li>标记整理(Mark Compact)</li>
<li>复制集合(Copy Collection)</li>
</ul>
<p>注意：</p>
<ul>
<li>GC 只负责堆(HEAP)内存的垃圾回收。引用类型都是存在堆(HEAP)中的，所以它的分配和释放都通过垃圾回收机制来管理。</li>
<li>栈(STACK)上的内存是由系统自动管理的。值类型在栈(STACK)中分配内存，他们有自己的生命周期，不用对他们进行管理，会自动分配和释放。</li>
</ul>
<p>C#中内存回收机制的大概原理<br>0 代内存 1 代内存 2 代内存<br>代的概念：代是垃圾回收机制使用的一种算法（分代算法）。新分配的对象都会被配置在第 0 代内存中。每次分配都可能会进行垃圾回收以释放内存（0 代内存满时）。在一次内存回收过程开始时，垃圾回收器会认为堆中全是垃圾，会进行以下两步：</p>
<ol>
<li>标记对象：从根(静态字段, 方法参数)开始检查引用对象，标记后为可达对象，未标记为不可达对象。不可达对象就认为是垃圾（挂起执行托管代码线程），释放未标记的对象，搬迁可达对象，修改引用地址。</li>
<li>搬迁对象：压缩堆。</li>
</ol>
<p>大对象总被认为是第二代内存，目的是减少性能损耗，提高性能。不会对大对象进行搬迁压缩，85000 字节(83KB)以上的对象为大对象。</p>
<p>手动垃圾回收</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CG.Collect();</span><br></pre></td></tr></table></figure>

<h2 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>用于保护成员变量，为成员属性的获取和赋值添加逻辑处理。<br>解决 3p 局限性问题，get,set 可以写一个（起到保护作用）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">get</span></span><br><span class="line">  &#123;</span><br><span class="line">       <span class="comment">//可以在返回之前添加逻辑规则</span></span><br><span class="line">       <span class="comment">//意味着这个属性可以获取的内容</span></span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//可以在设置前添加逻辑规则</span></span><br><span class="line">      <span class="comment">// value 关键字 用于表示外部传入的值</span></span><br><span class="line">      name = <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数值保护和加密处理"><a href="#数值保护和加密处理" class="headerlink" title="数值保护和加密处理"></a>数值保护和加密处理</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> High</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">get</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//可以在返回之前添加逻辑规则</span></span><br><span class="line">         <span class="comment">//意味着这个属性可以获取的内容</span></span><br><span class="line">         <span class="comment">//解密处理</span></span><br><span class="line">         <span class="keyword">return</span> High - <span class="number">5</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">set</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//可以在设置前添加逻辑规则</span></span><br><span class="line">         <span class="keyword">if</span> (High &lt; <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             high = <span class="number">0</span>;</span><br><span class="line">             Console.WriteLine(<span class="string">&quot;身高不能为负数，已设置为0&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// value 关键字 用于表示外部传入的值</span></span><br><span class="line">         <span class="comment">//加密处理</span></span><br><span class="line">         High = <span class="keyword">value</span> + <span class="number">5</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-和-set-前可加访问修饰符"><a href="#get-和-set-前可加访问修饰符" class="headerlink" title="get 和 set 前可加访问修饰符"></a>get 和 set 前可加访问修饰符</h3><p>private<br>默认不加 会使用属性声明时的访问权限<br>加的访问修饰符要低于属性的访问权限<br>不能让 get 和 set 的访问权限都低于属性的权限</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">get</span></span><br><span class="line">  &#123;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//只能get不能set，保护作用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">  &#123;</span><br><span class="line">      name = <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动属性"><a href="#自动属性" class="headerlink" title="自动属性"></a>自动属性</h3><p>外部能得不能改的特征，很少使用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动属性 少用</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Money</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><p>作用：可以以中括号的形式范围自定义类中的元素，规则自定义，访问时和数组一样。<br>适用于在类中有数组变量时使用。索引器可以重载。<br>锦上添花的作用，功能和成员属性相同，可以不写。结构体也支持索引器。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> Person friends[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> friends[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (friends==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                friends = <span class="keyword">new</span> Person[]&#123;<span class="keyword">value</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            friends[index] = <span class="keyword">value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p[<span class="number">0</span>] = <span class="keyword">new</span> Person;</span><br></pre></td></tr></table></figure>

<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p><code>static</code>关键字修饰的成员变量、成员方法、成员属性等。<br>特点：不用 new 一个，可以直接类名点出来。静态成员和程序同生共死，静态函数中不能使用非静态成员（生命周期的差异）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态成员的特点</span></span><br><span class="line"><span class="comment">// 程序开始运行时，就会分配内存空间。所以我们就能直接使用。</span></span><br><span class="line"><span class="comment">// 静态成员和程序同生共死，只要使用了它，直到程序结束时内存空间才会被释放。</span></span><br><span class="line"><span class="comment">// 所以一个静态成员就会有自己唯一的一个&quot;内存小房间&quot;，这让静态成员就有了唯一性。</span></span><br><span class="line"><span class="comment">// 在任何地方使用都是用的小房间里的内容，改变了它也是改变小房间里的内容。</span></span><br></pre></td></tr></table></figure>

<p>作用：常用变量的申明，常用的唯一的方法声明。如：同规则的数学计算相关函数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">计算圆的面积</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyCalss</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> PI = <span class="number">3.1415926f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">AreaOfCircle</span> (<span class="params"><span class="built_in">float</span> r</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.PI * r * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************************</span></span><br><span class="line"><span class="built_in">float</span> areaCircle =  MyCalss.AreaOfCircle(<span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<p>常量和静态变量</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CONST(常量)可以理解为特殊的STATIC(静态)</span></span><br><span class="line"><span class="comment">// 相同点</span></span><br><span class="line"><span class="comment">// 他们都可以通过类名点出使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同点</span></span><br><span class="line"><span class="comment">// 1. CONST必须初始化, 不能修改 STATIC没有这个规则</span></span><br><span class="line"><span class="comment">// 2. CONST只能修饰变量, STATIC可以修饰很多</span></span><br><span class="line"><span class="comment">// 3. CONST一定是写在访问修饰符后面的 ,STATIC没有这个要求</span></span><br></pre></td></tr></table></figure>

<p>补充<br>设计模式：单例模式（线程安全相关）</p>
<h2 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h2><p>使用<code>static</code>关键字修饰的类，只能包含静态成员。不能被实例化，具有唯一性，适合用作工具类（计算公式等）。</p>
<h2 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h2><p>使用<code>static</code>关键字修饰的构造函数，无访问修饰符，无参数，自动调用一次。<br>作用：主要用于初始化静态成员。</p>
<p>静态类和普通类中的静态构造函数功能一样，调用类时都会优先执行静态构造函数进行初始化<br>与构造函数（针对实例对象）不同的是，静态构造函数（针对类）只执行一次，并且是在第一个实例对象创建前被调用，所以它可以用于那些只需要执行一次的操作；而且它不允许有 public 等修饰符，由程序自动调用，不能被外界调用。<br>总结：静态构造函数用于初始化任何静态数据，或者用于执行仅需执行一次的操作；在创建第一个实例对象或者引用任何静态变量之前，将自动调用静态构造函数<br>所以一般静态构造函数用来为静态成员初始化，或者作为单件模式中创建对象的唯一入口。</p>
<h2 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>为现有非静态变量类型添加新方法。</p>
<p>作用</p>
<ol>
<li>提升程序拓展性</li>
<li>不需要在对象中重新写方法</li>
<li>不需要继承来添加方法</li>
<li>为别人封装的类型写额外的方法</li>
</ol>
<p>特点</p>
<ol>
<li>一定是写在静态类中</li>
<li>一定是个静态函数</li>
<li>第一个参数为拓展目标</li>
<li>第一个参数用 <code>this</code> 修饰</li>
</ol>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 返回值 函数名(<span class="keyword">this</span> 拓展类名 参数名, 参数类型 参数名)</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;方法1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;方法2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TuoZhan</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun3</span>(<span class="params"><span class="keyword">this</span> Tools2 <span class="keyword">value</span> ,<span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;方法3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************************************</span></span><br><span class="line">Tools t = <span class="keyword">new</span> Tools();</span><br><span class="line">t.fun3();</span><br></pre></td></tr></table></figure>

<p>作用</p>
<ol>
<li>提升程序的拓展性</li>
<li>为别人封装的类型写额外方法（在一些闭源的黑盒中拓展）</li>
<li>不需要继承来添加方法</li>
</ol>
<h2 id="运算符重载（仅做了解）"><a href="#运算符重载（仅做了解）" class="headerlink" title="运算符重载（仅做了解）"></a>运算符重载（仅做了解）</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>关键词：<code>operator</code>。实现自定义类型的运算。可以多个重载。<br>可以多个重载<br>参数的数量 和运算符对应 （++ 单个参数 * 两个参数）<br>提升程序的扩展性<br>特点</p>
<ol>
<li>一定是一个公共的静态方法</li>
<li>返回值写在 <code>operator</code> 前</li>
<li>逻辑处理自定义</li>
</ol>
<p>作用<br>让自定义类和结构体对象可以进行运算。</p>
<p>注意</p>
<ol>
<li>条件运算符需要成对实现</li>
<li>一个符号可以多个重载</li>
<li>不能使用 <code>ref</code> 和 <code>out</code></li>
</ol>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 <span class="keyword">operator</span> 运算符（参数列表）</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运算符重载 实现自定义类型的运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="keyword">operator</span> +(Person p1, Person p2)</span><br><span class="line">&#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person();</span><br><span class="line">    p.age = p1.age + p2.age;</span><br><span class="line">    p.high = p1.high + p2.high;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************************************</span></span><br><span class="line"></span><br><span class="line">Person p2 = p + p1;</span><br></pre></td></tr></table></figure>

<h3 id="可重载的运算符"><a href="#可重载的运算符" class="headerlink" title="可重载的运算符"></a>可重载的运算符</h3><ul>
<li>算数运算符：<code>+ - * / % ++ --</code></li>
<li>逻辑运算符：<code>!</code></li>
<li>位运算符：<code>&amp; | ^ ~ &lt;&lt; &gt;&gt;</code></li>
<li>条件运算符：<code>&lt; &lt;= &gt; &gt;= == !=</code></li>
</ul>
<h3 id="不可重载的运算符"><a href="#不可重载的运算符" class="headerlink" title="不可重载的运算符"></a>不可重载的运算符</h3><ul>
<li>逻辑运算符：<code>&amp;&amp; ||</code></li>
<li>其他：<code>[ ] () . = ? :</code></li>
</ul>
<h2 id="内部类和分布类（仅做了解）"><a href="#内部类和分布类（仅做了解）" class="headerlink" title="内部类和分布类（仅做了解）"></a>内部类和分布类（仅做了解）</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>在类中再声明一个类，亲密关系的体现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//人</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> Body body;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Body</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//身体</span></span><br><span class="line">        Arm leftArm;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Arm</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//手臂</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布类"><a href="#分布类" class="headerlink" title="分布类"></a>分布类</h3><p>关键词：<code>partial</code>。</p>
<h3 id="分部类"><a href="#分部类" class="headerlink" title="分部类"></a>分部类</h3><p>把一个类分成几部分声明。</p>
<p>特点</p>
<ol>
<li>分部类可以写在多个脚本文件中。</li>
<li>分部类的访问修饰符要一致。</li>
<li>分部类中不能有重复成员。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> number;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h3><p>概念<br>将方法的声明和实现分离。</p>
<p>特点</p>
<ol>
<li>不能加访问修饰符，默认私有。</li>
<li>只能在分部类中声明。</li>
<li>返回值只能是 <code>void</code>。</li>
<li>可以有参数，但不用 <code>out</code> 关键字。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span>; <span class="comment">// 分部方法声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> number;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> high;</span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">Speak</span>() <span class="comment">// 分部方法实现</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello, my name is &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的基本规则"><a href="#继承的基本规则" class="headerlink" title="继承的基本规则"></a>继承的基本规则</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>不能多继承，单根性。</p>
<p>一个类 A 继承一个类 B，类 A 将会继承类 B 的所有成员。A 类将拥有 B 类的所有特征和行为。</p>
<p>被继承的类称为父类、基类、超类</p>
<p>继承的类称为子类、派生类</p>
<p>子类可以有自己的特征和行为</p>
<p>特点</p>
<ol>
<li><strong>单根性</strong>：子类只能有一个父类</li>
<li><strong>传递性</strong>：子类可以间接继承父类的父类</li>
</ol>
<h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 : 被继承的类名</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="comment">//工号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> number;</span><br><span class="line">    <span class="comment">//介绍名字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeakName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承Teacher类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">TeachingTeacher</span> : <span class="title">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//科目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> subject;</span><br><span class="line">    <span class="comment">//介绍科目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeakSubject</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(subject+<span class="string">&quot;老师&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问修饰符-1"><a href="#访问修饰符-1" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p><code>protected</code> 不希望外部访问，但子类可以访问。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><p>父类容器转载子类对象，方便进行对象存储和管理。</p>
<p>重点<br>任何父类出现的地方，子类都可以替代。</p>
<p>作用<br>方便进行对象存储和管理。</p>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerAtk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;玩家攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Moster</span> : <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MosterAtk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;怪物攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Boss</span> : <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BossAtk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boss攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//****************************************************</span></span><br><span class="line"><span class="comment">//里氏替换原则，用父类容器转载子类对象</span></span><br><span class="line"><span class="comment">//但是Player类的功能无法使用要用is as转换</span></span><br><span class="line">GameObject player = <span class="keyword">new</span> Player();</span><br><span class="line"></span><br><span class="line"><span class="comment">//✅is和as</span></span><br><span class="line"><span class="comment">//is判断一个对象是否是指定的对象</span></span><br><span class="line"><span class="comment">//返回值bool</span></span><br><span class="line"><span class="keyword">if</span> (player <span class="keyword">is</span> Player)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//as：将一个对象转换为指定类对象</span></span><br><span class="line">    <span class="comment">//返回值：指定类型对象</span></span><br><span class="line">    <span class="comment">//成功返回指定类对象 失败返回null</span></span><br><span class="line">    Player p = player <span class="keyword">as</span> Player;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以正常使用Player类的功能了</span></span><br><span class="line">p.PlayerAtk();</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实际使用时和数组配合使用多 方便进行对象存储和管理</span></span><br><span class="line">GameObject[] objects = <span class="keyword">new</span> GameObject[] &#123; <span class="keyword">new</span> Player(), <span class="keyword">new</span> Moster(), <span class="keyword">new</span> Boss() &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历objects数组 来判断类和执行类</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; objects.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (objects[i] <span class="keyword">is</span> Player)</span><br><span class="line">    &#123;</span><br><span class="line">        (player <span class="keyword">as</span> Player).PlayerAtk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (objects[i] <span class="keyword">is</span> Moster)</span><br><span class="line">    &#123;</span><br><span class="line">        (player <span class="keyword">as</span> Moster).MosterAtk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (objects[i] <span class="keyword">is</span> Boss)</span><br><span class="line">    &#123;</span><br><span class="line">        (player <span class="keyword">as</span> Boss).BossAtk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Teather</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> c;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> d;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TAdd</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">10</span>;</span><br><span class="line">        d = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//********************************</span></span><br><span class="line">Person t = <span class="keyword">new</span> Teather();</span><br><span class="line"><span class="comment">//替换后直接使用是只能用父类的方法</span></span><br><span class="line">t.Add();</span><br><span class="line"><span class="comment">//使用as 后才能使用子类和父类的方法</span></span><br><span class="line">(t <span class="keyword">as</span> Teather).TAdd();</span><br></pre></td></tr></table></figure>

<h2 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h2><h3 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h3><p>先执行父类的构造函数再执行子类构造函数。子类实例化时，默认调用无参构造函数。若父类没有无参构造函数就会报错。</p>
<p>特点</p>
<ol>
<li>当声明一个子类对象时，先执行父类的构造函数，再执行子类的构造函数。</li>
<li>父类的无参构造很重要。</li>
<li>子类可以通过 <code>base</code> 关键字（代表父类）调用父类构造函数。</li>
</ol>
<p>1.始终保持申明一个无参构造 2.通过 base 调用指定父类构造 （注意和 this 的区别）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base调用指定父类构造</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span> (<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span> a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span> (<span class="params"><span class="built_in">int</span> a</span>) : <span class="title">base</span>(<span class="params">a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************************</span></span><br><span class="line">Son s = <span class="keyword">new</span> Son(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="万物之父-装箱拆箱"><a href="#万物之父-装箱拆箱" class="headerlink" title="万物之父&amp;装箱拆箱"></a>万物之父&amp;装箱拆箱</h2><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><p>关键词：<code>object</code>。<code>object</code> 是一个基类，可以装任何东西。</p>
<p>作用</p>
<ol>
<li>可以利用里氏替换原则，用 <code>object</code> 容器装所有对象。</li>
<li>可以用来表示不确定类型，作为函数参数类型。</li>
</ol>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>引用类型和里氏替换原则一样用 is 和 as<br>值类型使用括号强转</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Sb</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;傻逼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**************************</span></span><br><span class="line"><span class="comment">//装引用类型 和使用 ——里氏替换</span></span><br><span class="line"><span class="built_in">object</span> o = <span class="keyword">new</span> Sb();</span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">is</span> Sb)</span><br><span class="line">&#123;</span><br><span class="line">    (o <span class="keyword">as</span> Sb).Speak;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//装值类型 和使用 ——括号强转</span></span><br><span class="line"><span class="built_in">object</span> o2 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> a = (<span class="built_in">int</span>)o2;</span><br><span class="line"><span class="comment">//装特殊类型 string</span></span><br><span class="line"><span class="built_in">object</span> o3 = <span class="string">&quot;你好呀&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str = o3.ToString;<span class="comment">//也可以使用引用类型的 o3 as string</span></span><br><span class="line"><span class="comment">//装特殊类型 数组</span></span><br><span class="line"><span class="built_in">object</span> o4 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">int</span>[] arr = (<span class="built_in">int</span>[])o4;<span class="comment">//也可以使用引用类型的 o4 as int[]</span></span><br></pre></td></tr></table></figure>

<h3 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h3><p>值类型和 <code>object</code> 之间发生的转换。</p>
<p>装箱<br>把值类型用引用类型存储，栈内存移到堆内存中。</p>
<p>拆箱<br>把引用类型存储的值类型取出来，堆内存移到栈内存中。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 装箱</span></span><br><span class="line"><span class="built_in">object</span> o = a;</span><br><span class="line"><span class="comment">// 拆箱</span></span><br><span class="line"><span class="built_in">int</span> b = (<span class="built_in">int</span>)o;</span><br></pre></td></tr></table></figure>

<h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>关键词：<code>sealed</code>。作用是让类无法被继承，保证程序的规范性和安全性。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Father 类无法被继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="Vob"><a href="#Vob" class="headerlink" title="Vob"></a>Vob</h2><h3 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h3><p>关键词：virtual（虚函数） override（重写） base（父类）<br>在执行同一方法时有不同的表现<br>重写的方法 输入参数的类型和数量要一致（也复合面向对象）<br>多层继承中也可以使用 层层重写回到父类</p>
<p>作用：其实多态的作用就是把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出更通用的程序。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> 多态的概念</span></span><br><span class="line"><span class="comment">//多态文字面的意思就是“多种状态”</span></span><br><span class="line"><span class="comment">//让继承同一父类的子类们 在执行相同方法时有不同的表现（状态）</span></span><br><span class="line"><span class="comment">//主要目的</span></span><br><span class="line"><span class="comment">//同一父类的对象 执行相同行为（方法）有不同的表现</span></span><br><span class="line"><span class="comment">//解决的问题</span></span><br><span class="line"><span class="comment">//让同一个对象有唯一行为的特征</span></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> 多态的实现</span></span><br><span class="line"><span class="comment">//目前已经学过的多态</span></span><br><span class="line"><span class="comment">//编译时多态——函数重载，开始就写好的</span></span><br><span class="line"><span class="comment">//我们将学习的:</span></span><br><span class="line"><span class="comment">//运行时多态（vob，抽象函数，接口）</span></span><br><span class="line"><span class="comment">//我们今天学习 vob</span></span><br><span class="line"><span class="comment">//v: virtual(虚函数)</span></span><br><span class="line"><span class="comment">//o: override(重写)</span></span><br><span class="line"><span class="comment">//b: base(父类)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure>

<h3 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title">GameObeject</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//虚函数 virtual</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;游戏对象进行攻击&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObeject</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//重写</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//base可以保留父类的方法</span></span><br><span class="line">            <span class="comment">//base.Atk();</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;玩家对象进行攻击&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Monster</span> : <span class="title">GameObeject</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//重写</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//base可以保留父类的方法</span></span><br><span class="line">            <span class="comment">//base.Atk();</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;怪物对象进行攻击&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**********************************************</span></span><br><span class="line">    GameObeject p = <span class="keyword">new</span> Player();</span><br><span class="line">    p.Atk();</span><br><span class="line"></span><br><span class="line">    GameObeject m = <span class="keyword">new</span> Monster();</span><br><span class="line">    m.Atk();</span><br></pre></td></tr></table></figure>

<h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>抽象类<br>关键字：abstract<br>不能被实例化 可以包含抽象方法 遵循里氏替换</p>
<p>概念：被抽象关键字 ABSTRACT 修饰的类<br>特点:</p>
<ol>
<li>不能被实例化的类</li>
<li>可以包含抽象方法</li>
<li>继承抽象类必须重写其抽象方法</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Fruits</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何选择普通类还是抽象类</p>
<ul>
<li>不希望实例化的对象 相对抽象的类可以使用 如 ：人 person 水果 fruit</li>
<li>父类中的行为不太需要被实现 只希望子类去定义具体的规则</li>
<li>整体框架设计时会使用 让基类更安全</li>
</ul>
<h3 id="抽象函数"><a href="#抽象函数" class="headerlink" title="抽象函数"></a>抽象函数</h3><p>又叫纯虚方法<br>关键字：<code>abstract</code><br>特点：</p>
<ol>
<li>只能在抽象类中声明</li>
<li>没有方法体</li>
<li>不能是私有的</li>
<li>继承后必须要 override 重写</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Fruits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">Bad</span> ()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Apple</span> : <span class="title">Fruits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bad</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;苹果坏了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"><span class="comment">//遵循里氏替换 父类装子类</span></span><br><span class="line">Fruits f = <span class="keyword">new</span> Apple();</span><br><span class="line">f.Bad();</span><br></pre></td></tr></table></figure>

<p>虚方法（vritual）和纯虚方法（abstract）的区别</p>
<ul>
<li>虚方法可以在抽象类和非抽象类中声明 纯虚方法只能在抽象类中声明</li>
<li>虚方法可以由子类选择性实现 纯虚方法必须实现重写。虚方法有方法体可实现逻辑</li>
<li>他们都可以被子类用 override 重写 可以多层重写 子子类重写子类重写父类</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口是行为的抽象规范</span></span><br><span class="line"><span class="comment">//它也是一种自定义类型</span></span><br><span class="line"><span class="comment">//关键字：interface</span></span><br><span class="line"><span class="comment">//接口申明的规范</span></span><br><span class="line"><span class="comment">//1.不包含成员变量</span></span><br><span class="line"><span class="comment">//2.只包含方法、属性、索引器、事件</span></span><br><span class="line"><span class="comment">//3.成员不能被实现</span></span><br><span class="line"><span class="comment">//4.成员可以不用写访问修饰符，不能是私有的</span></span><br><span class="line"><span class="comment">//5.接口不能继承类，但是可以继承另一个接口</span></span><br><span class="line"><span class="comment">//接口的使用规范</span></span><br><span class="line"><span class="comment">//1.类可以继承多个接口</span></span><br><span class="line"><span class="comment">//2.类继承接口后，必须实现接口中所有成员</span></span><br><span class="line"><span class="comment">//特点</span></span><br><span class="line"><span class="comment">//1.它和类的申明类似</span></span><br><span class="line"><span class="comment">//2.接口是用来继承的</span></span><br><span class="line"><span class="comment">//3.接口不能被实例化，但是可以作为容器存储对象</span></span><br></pre></td></tr></table></figure>

<h3 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h3><p>接口的申明</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口关键字：interface</span></span><br><span class="line"><span class="comment">//语法：interface 接口名</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//一句话记忆：接口是抽象行为的&quot;基类&quot;</span></span><br><span class="line"><span class="comment">//接口命名规范：帕斯卡前面加个I</span></span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//索引器</span></span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事件 c#进阶讲</span></span><br><span class="line">    <span class="keyword">event</span> Action doSomthing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的使用</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口用来继承</span></span><br><span class="line"><span class="comment">//1.类可以继承1个类，N个接口</span></span><br><span class="line"><span class="comment">//2.继承了接口后，必须实现其中的内容，并且必须是PUBLIC的</span></span><br><span class="line"><span class="comment">//3.实现的接口函数，可以加V再在子类重写</span></span><br><span class="line"><span class="comment">//4.接口也遵循里氏替换原则</span></span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//索引器</span></span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事件 c#进阶讲</span></span><br><span class="line">    <span class="keyword">event</span> Action doSomthing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Animal</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Persom</span> : <span class="title">Animal</span>,<span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//实现的接口函数 可以加virtual再在子类中重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action doSomthing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************************************</span></span><br><span class="line"><span class="comment">//接口遵循里氏替换 父类装子类</span></span><br><span class="line">IFly f = <span class="keyword">new</span> Persom1();</span><br></pre></td></tr></table></figure>

<h3 id="接口可以继承接口"><a href="#接口可以继承接口" class="headerlink" title="接口可以继承接口"></a>接口可以继承接口</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于行为合并</span></span><br><span class="line"><span class="comment">//接口继承接口时不需要实现</span></span><br><span class="line"><span class="comment">//待类继承接口后类去实现所有内容</span></span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IWalk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Walk</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IMove</span> : <span class="title">IFly</span>, <span class="title">IWALK</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="显示实现接口"><a href="#显示实现接口" class="headerlink" title="显示实现接口"></a>显示实现接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//当一个类继承两个接口</span><br><span class="line">//但是接口中存在着同名方法时</span><br><span class="line">//注意：显示实现接口时不能写访问修饰符</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Player</span> : <span class="title">IAtk</span>, <span class="title">ISuperAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IAtk.Atk()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ISuperAtk.Atk()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的作用和总结"><a href="#接口的作用和总结" class="headerlink" title="接口的作用和总结"></a>接口的作用和总结</h3><p>作用</p>
<ul>
<li>抽象行为：把行为抽象出来供子类继承。个别功能独立在基类外，子类需要时继承。</li>
<li>提高程序复用性。</li>
</ul>
<p>总结</p>
<ul>
<li>继承类：是对象间的继承，包括特征行为等。</li>
<li>接口继承：是行为间的继承，继承接口的行为规范，按照规范去实现内容。</li>
<li>接口也是遵循里氏替换，所以可以用接口容器装对象，实现装载毫无关系但是却有相同行为的对象。</li>
<li>接口包含：成员方法、属性、索引器、事件，且都不实现，都没有访问修饰符。</li>
<li>接口继承接口相当于行为合并。</li>
</ul>
<h2 id="密封方法"><a href="#密封方法" class="headerlink" title="密封方法"></a>密封方法</h2><p>关键字：<code>sealed</code> 修饰重写函数<br>让虚方法或者抽象方法不能再被重写<br>和 override 一同出现</p>
<p>以下是关于命名空间的概念和用法的 Markdown 格式说明：</p>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><h2 id="基本概念-9"><a href="#基本概念-9" class="headerlink" title="基本概念"></a>基本概念</h2><p>命名空间用于组织和复用代码，类似于一个工具包，将类声明放置其中。命名空间可以分开编写。</p>
<ul>
<li><strong>同一命名空间</strong>中的类名不能重复。</li>
<li><strong>不同命名空间</strong>中的类可以同名。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Mygame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Gameobject</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名空间可以分开写</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Mygame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 属于同一命名空间，可以正常继承</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">Gameobject</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用命名空间"><a href="#引用命名空间" class="headerlink" title="引用命名空间"></a>引用命名空间</h2><p>在不同命名空间中相互使用时，需要引用命名空间。可以通过两种方法进行引用：</p>
<ol>
<li><strong>使用 <code>using</code> 关键字</strong></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Mygame;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Mygame 命名空间的 Gameobject 类</span></span><br><span class="line">Gameobject g = <span class="keyword">new</span> Gameobject();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>直接使用命名空间的完整路径</strong></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Mygame 命名空间的 Gameobject 类</span></span><br><span class="line">Mygame.Gameobject g = <span class="keyword">new</span> Mygame.Gameobject();</span><br></pre></td></tr></table></figure>

<h2 id="应对不同命名空间中的同名类"><a href="#应对不同命名空间中的同名类" class="headerlink" title="应对不同命名空间中的同名类"></a>应对不同命名空间中的同名类</h2><p>当不同命名空间中有同名类时，可以通过指定完整路径来区分：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Mygame;</span><br><span class="line"><span class="keyword">using</span> Mygame2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区分同名类</span></span><br><span class="line">Mygame.Gameobject g = <span class="keyword">new</span> Mygame.Gameobject();</span><br><span class="line">Mygame2.Gameobject g2 = <span class="keyword">new</span> Mygame2.Gameobject();</span><br></pre></td></tr></table></figure>

<h2 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h2><p>命名空间可以嵌套使用，类似于小工具包中的小工具包：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyGame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">UI</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">Image</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Game</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">Image</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用嵌套命名空间中的类"><a href="#使用嵌套命名空间中的类" class="headerlink" title="使用嵌套命名空间中的类"></a>使用嵌套命名空间中的类</h3><ol>
<li><strong>通过命名空间的完整路径</strong></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyGame.UI.Image img = <span class="keyword">new</span> MyGame.UI.Image();</span><br><span class="line">MyGame.Game.Image img2 = <span class="keyword">new</span> MyGame.Game.Image();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用 <code>using</code> 关键字引入命名空间</strong></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyGame.UI;</span><br><span class="line"><span class="keyword">using</span> MyGame.Game;</span><br><span class="line"></span><br><span class="line">Image img = <span class="keyword">new</span> Image();</span><br><span class="line">Image img2 = <span class="keyword">new</span> Image();</span><br></pre></td></tr></table></figure>

<p>以下是关于<code>Object</code>类的各种方法的详细说明及代码示例的 Markdown 格式：</p>
<h1 id="Object-类中的方法"><a href="#Object-类中的方法" class="headerlink" title="Object 类中的方法"></a><code>Object</code> 类中的方法</h1><p>知识回顾</p>
<ul>
<li>所有类型的基类是 <code>Object</code>。</li>
<li>可以利用里氏替换原则装载一切对象，涉及装箱和拆箱。</li>
</ul>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="Equals"><a href="#Equals" class="headerlink" title="Equals"></a><code>Equals</code></h3><ul>
<li><strong>定义</strong>: <code>public static bool Equals(object? objA, object? objB);</code></li>
<li><strong>作用</strong>: 判断两个对象是否相等。最终的比较由左侧对象的 <code>Equals</code> 方法决定。</li>
<li><strong>示例</strong>:</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(Object.Equals(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 输出 True</span></span><br><span class="line">Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">Console.WriteLine(Object.Equals(t1, t2)); <span class="comment">// 输出 False</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>值类型判断</strong>: 比较两个值是否相等。</li>
<li><strong>引用类型判断</strong>: 比较两个对象是否指向同一内存地址，而不是判断是否相同类型。</li>
</ul>
<h3 id="ReferenceEquals"><a href="#ReferenceEquals" class="headerlink" title="ReferenceEquals"></a><code>ReferenceEquals</code></h3><ul>
<li><strong>定义</strong>: <code>public static bool ReferenceEquals(object? objA, object? objB);</code></li>
<li><strong>作用</strong>: 比较两个对象是否是同一个引用。主要用于引用类型的比较，不用于值类型。</li>
<li><strong>示例</strong>:</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">Test t2 = t1;</span><br><span class="line">Console.WriteLine(Object.ReferenceEquals(t1, t2)); <span class="comment">// 输出 True</span></span><br></pre></td></tr></table></figure>

<h2 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="GetType"><a href="#GetType" class="headerlink" title="GetType"></a><code>GetType</code></h3><ul>
<li><strong>定义</strong>: <code>public Type GetType();</code></li>
<li><strong>作用</strong>: 获取对象的运行时类型。结合反射相关知识，可以对对象进行各种操作。</li>
<li><strong>示例</strong>:</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line">Type type = t.GetType();</span><br><span class="line">Console.WriteLine(type); <span class="comment">// 输出 Test</span></span><br></pre></td></tr></table></figure>

<h3 id="MemberwiseClone"><a href="#MemberwiseClone" class="headerlink" title="MemberwiseClone"></a><code>MemberwiseClone</code></h3><ul>
<li><strong>定义</strong>: <code>protected object MemberwiseClone();</code></li>
<li><strong>作用</strong>: 获取对象的浅拷贝。返回一个新的对象，新对象中的引用变量与老对象一致。</li>
<li><strong>示例</strong>:</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test original = <span class="keyword">new</span> Test();</span><br><span class="line">Test copy = (Test)original.MemberwiseClone();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>浅拷贝</strong>: 对于值类型，直接复制；对于引用类型，复制的是内存地址，改变拷贝后的引用类型变量会影响原变量。</li>
</ul>
<h2 id="Equals-虚方法"><a href="#Equals-虚方法" class="headerlink" title="Equals (虚方法)"></a><code>Equals</code> (虚方法)</h2><ul>
<li><strong>定义</strong>: <code>public virtual bool Equals(object? obj);</code></li>
<li><strong>作用</strong>: 比较两个对象是否相等。可以重写该方法以定义自定义的比较规则。</li>
<li><strong>示例</strong>:</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span>? obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">is</span> Test)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 自定义比较逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GetHashCode-虚方法"><a href="#GetHashCode-虚方法" class="headerlink" title="GetHashCode (虚方法)"></a><code>GetHashCode</code> (虚方法)</h2><ul>
<li><strong>定义</strong>: <code>public virtual int GetHashCode();</code></li>
<li><strong>作用</strong>: 获取对象的哈希码。通常用于哈希表中。可以重写该方法定义自定义的哈希码算法。</li>
<li><strong>示例</strong>:</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12345</span>; <span class="comment">// 自定义哈希码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ToString-虚方法"><a href="#ToString-虚方法" class="headerlink" title="ToString (虚方法)"></a><code>ToString</code> (虚方法)</h2><ul>
<li><strong>定义</strong>: <code>public virtual string? ToString();</code></li>
<li><strong>作用</strong>: 返回当前对象的字符串表示形式。可以重写该方法以定义自定义的对象转字符串规则。</li>
<li><strong>示例</strong>:</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;苏老师声明的Test类&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line">Console.WriteLine(t.ToString()); <span class="comment">// 输出 &quot;苏老师声明的Test类&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="string-的常用方法"><a href="#string-的常用方法" class="headerlink" title="string 的常用方法"></a>string 的常用方法</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串本质是 char 数组</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">Console.WriteLine(str[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 输出 &quot;H&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为 char 数组</span></span><br><span class="line"><span class="built_in">char</span>[] chars = str.ToCharArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符长度</span></span><br><span class="line"><span class="built_in">int</span> length = str.Length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串拼接</span></span><br><span class="line">str = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// 返回 &quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正向查找字符位置</span></span><br><span class="line">str = <span class="string">&quot;Hello from CSharp&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> index = str.IndexOf(<span class="string">&quot;from&quot;</span>);</span><br><span class="line"><span class="comment">// 返回 6，字符的索引，找不到返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向查找字符位置</span></span><br><span class="line">str = <span class="string">&quot;Hello CSharp CSharp&quot;</span>;</span><br><span class="line">index = str.LastIndexOf(<span class="string">&quot;CSharp&quot;</span>);</span><br><span class="line"><span class="comment">// 返回 13，从后面开始查找，找到的第一个字的索引，找不到返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除指定位置后的字符</span></span><br><span class="line">str = <span class="string">&quot;Hello CSharp CSharp&quot;</span>;</span><br><span class="line">str = str.Remove(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 返回 &quot;Hello &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除指定位置和字符个数</span></span><br><span class="line">str = <span class="string">&quot;Hello CSharp World&quot;</span>;</span><br><span class="line">str = str.Remove(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 返回 &quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换指定字符串</span></span><br><span class="line">str = <span class="string">&quot;Hello CSharp World&quot;</span>;</span><br><span class="line">str = str.Replace(<span class="string">&quot;CSharp&quot;</span>, <span class="string">&quot;Programming&quot;</span>);</span><br><span class="line"><span class="comment">// 返回 &quot;Hello Programming World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小写转换</span></span><br><span class="line">str = <span class="string">&quot;csharp&quot;</span>;</span><br><span class="line">str = str.ToUpper();</span><br><span class="line"><span class="comment">// 返回 &quot;CSHARP&quot;</span></span><br><span class="line"></span><br><span class="line">str = str.ToLower();</span><br><span class="line"><span class="comment">// 返回 &quot;csharp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串截取</span></span><br><span class="line">str = <span class="string">&quot;Hello CSharp World&quot;</span>;</span><br><span class="line">str = str.Substring(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 返回 &quot;CSharp World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载，指定开始位置和字符个数</span></span><br><span class="line">str = <span class="string">&quot;Hello CSharp World&quot;</span>;</span><br><span class="line">str = str.Substring(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 返回 &quot;CSharp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串切割</span></span><br><span class="line">str = <span class="string">&quot;Apple|Banana|Cherry|Date&quot;</span>;</span><br><span class="line"><span class="built_in">string</span>[] strs = str.Split(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回 string[]&#123; &quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;, &quot;Date&quot; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><p>解决字符串性能问题</p>
<p>知识回顾</p>
<ul>
<li><strong>字符串是特殊的引用类型</strong>:<ul>
<li>每次重新赋值或拼接时，会分配新的内存空间。</li>
<li>如果一个字符串经常改变，会非常浪费内存空间。</li>
</ul>
</li>
</ul>
<h3 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a><code>StringBuilder</code> 类</h3><ul>
<li><p><strong>定义</strong>: <code>StringBuilder</code> 是 C# 提供的一个类，用于处理字符串，特别是当需要频繁修改和拼接字符串时。</p>
</li>
<li><p><strong>优点</strong>:</p>
<ul>
<li>修改字符串而不创建新的对象。</li>
<li>提升性能，减少内存浪费。</li>
</ul>
</li>
<li><p><strong>使用前需要引用的命名空间</strong>:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 StringBuilder 实例</span></span><br><span class="line">StringBuilder strBui = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;InitialValue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取容量</span></span><br><span class="line"><span class="built_in">int</span> capacity = strBui.Capacity;</span><br><span class="line"><span class="comment">// 默认为16，当前使用了11，自动扩容可能会变成32, 64, 128等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加内容</span></span><br><span class="line">strBui.Append(<span class="string">&quot;MoreData&quot;</span>);</span><br><span class="line"><span class="comment">// 结果为 &quot;InitialValueMoreData&quot;</span></span><br><span class="line"></span><br><span class="line">strBui.AppendFormat(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, <span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// 结果为 &quot;InitialValueMoreData123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入内容</span></span><br><span class="line">strBui.Insert(<span class="number">0</span>, <span class="string">&quot;Prefix&quot;</span>);</span><br><span class="line"><span class="comment">// 结果为 &quot;PrefixInitialValueMoreData123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除内容</span></span><br><span class="line">strBui.Remove(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// 结果为 &quot;InitialValueMoreData123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空内容</span></span><br><span class="line">strBui.Clear();</span><br><span class="line"><span class="comment">// 结果为 &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新赋值</span></span><br><span class="line">strBui.Clear();</span><br><span class="line">strBui.Append(<span class="string">&quot;NewValue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找内容</span></span><br><span class="line"><span class="built_in">char</span> character = strBui[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 结果为 &#x27;V&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改内容</span></span><br><span class="line">strBui[<span class="number">0</span>] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line"><span class="comment">// strBui 结果为 &quot;OneValue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换内容</span></span><br><span class="line">strBui.Replace(<span class="string">&quot;Value&quot;</span>, <span class="string">&quot;String&quot;</span>);</span><br><span class="line"><span class="comment">// strBui 结果为 &quot;OneString&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否相等</span></span><br><span class="line"><span class="built_in">bool</span> isEqual = strBui.Equals(<span class="string">&quot;OneString&quot;</span>);</span><br><span class="line"><span class="comment">// 返回 true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>StringBuilder</code> 完全具有引用类型的特征，没有值类型的特征。</li>
<li><code>StringBuilder</code> 自动管理内存扩容，不需要手动调整容量。</li>
<li>对 <code>StringBuilder</code> 的所有操作，如增、删、改、查、替换等，都不会创建新的字符串实例，而是直接在现有实例上进行修改，提升了性能。</li>
</ul>
<h1 id="结构体和类的区别"><a href="#结构体和类的区别" class="headerlink" title="结构体和类的区别"></a>结构体和类的区别</h1><ul>
<li><strong>存储位置</strong>:<ul>
<li>结构体是值类型，存储在栈上。</li>
<li>类是引用类型，存储在堆上。</li>
</ul>
</li>
<li><strong>使用区别</strong>:<ul>
<li>结构体和类在使用上很类似，但结构体不具备继承和多态特性。</li>
<li>结构体可以视为封装了面向对象思想的一类对象，但由于不支持继承和多态，它的使用范围较窄。</li>
<li>结构体不能使用 <code>protected</code> 保护访问修饰符。</li>
</ul>
</li>
</ul>
<h2 id="细节区别"><a href="#细节区别" class="headerlink" title="细节区别"></a>细节区别</h2><ol>
<li>结构体是值类型，类是引用类型。</li>
<li>结构体存在栈中，类存在堆中。</li>
<li>结构体成员不能使用 <code>protected</code> 访问修饰符，而类可以。</li>
<li>结构体成员变量声明不能指定初始值，而类可以。</li>
<li>结构体不能声明无参构造函数，而类可以。</li>
<li>结构体声明有参构造函数后，无参构造函数不会被自动生成。</li>
<li>结构体不能声明析构函数，而类可以。</li>
<li>结构体不能被继承，而类可以。</li>
<li>结构体需要在构造函数中初始化所有成员变量，而类的成员变量可以不初始化。</li>
<li>结构体不能被 <code>static</code> 修饰（不存在静态结构体），而类可以。</li>
<li>结构体不能在自己内部声明和自己一样的结构体变量，而类可以。</li>
</ol>
<h2 id="结构体和类的选择"><a href="#结构体和类的选择" class="headerlink" title="结构体和类的选择"></a>结构体和类的选择</h2><ol>
<li><strong>使用继承和多态</strong>:<ul>
<li>当需要使用继承和多态时，选择类。例如，玩家、怪物等对象。</li>
</ul>
</li>
<li><strong>数据集合</strong>:<ul>
<li>当对象是数据集合时，优先考虑使用结构体。例如，位置、坐标等。</li>
</ul>
</li>
<li><strong>值类型和引用类型赋值</strong>:<ul>
<li>当需要频繁赋值传递且希望改变赋值对象而原对象不跟随变化时，使用结构体。例如，坐标、向量、旋转等。</li>
</ul>
</li>
</ol>
<h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><ul>
<li><p><strong>抽象类</strong>:</p>
<ul>
<li>使用 <code>abstract</code> 修饰的类和方法。</li>
<li>抽象类不能实例化。</li>
<li>抽象方法只能在抽象类中声明，必须在子类中实现。</li>
</ul>
</li>
<li><p><strong>接口</strong>:</p>
<ul>
<li>使用 <code>interface</code> 修饰。</li>
<li>接口是行为的抽象，不包含成员变量。</li>
<li>仅包含方法、属性、索引器、事件，成员都不能实现，访问修饰符默认为 <code>public</code>。</li>
</ul>
</li>
</ul>
<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ol>
<li>都可以被继承。</li>
<li>都不能直接实例化。</li>
<li>都可以包含方法声明。</li>
<li>子类或实现类必须实现未实现的方法。</li>
<li>都遵循里氏替换原则。</li>
</ol>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li><strong>构造函数</strong>:<ul>
<li>抽象类可以有构造函数；接口不能有构造函数。</li>
</ul>
</li>
<li><strong>继承</strong>:<ul>
<li>抽象类只能单继承；接口可以多继承。</li>
</ul>
</li>
<li><strong>成员变量</strong>:<ul>
<li>抽象类中可以有成员变量；接口中不能有成员变量。</li>
</ul>
</li>
<li><strong>方法</strong>:<ul>
<li>抽象类中可以声明成员方法、虚方法、抽象方法、静态方法；接口中只能声明没有实现的抽象方法。</li>
</ul>
</li>
<li><strong>访问修饰符</strong>:<ul>
<li>抽象类的方法可以使用访问修饰符；接口中的方法建议不写访问修饰符，默认为 <code>public</code>。</li>
</ul>
</li>
</ol>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><ul>
<li><strong>表示对象</strong>:<ul>
<li>使用抽象类来表示对象。</li>
</ul>
</li>
<li><strong>表示行为扩展</strong>:<ul>
<li>使用接口来表示行为扩展。</li>
</ul>
</li>
<li><strong>举例</strong>:<ul>
<li>动物是一类对象，可以选择抽象类；飞翔是一个行为，可以选择接口。</li>
</ul>
</li>
</ul>
<h1 id="面向对象七大原则"><a href="#面向对象七大原则" class="headerlink" title="面向对象七大原则"></a>面向对象七大原则</h1><p>七大原则总体要实现的目标是：模块内的高内聚、模块间的低耦合，使程序模块的可重用性、移植性增强。</p>
<h2 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h2><p><strong>单一职责原则:一个类只处理自己应该处理的内容，不应该啥都写在一起</strong></p>
<p><strong>开闭原则:对拓展开放，对修改封闭。新加功能尽量是加处理而不是改代码</strong></p>
<p><strong>里氏替换原则:任何地方子类都能替代父类，父类容器装子类</strong></p>
<p><strong>依赖倒转原则:不要依赖具体的实现，要依赖抽象（接口)</strong></p>
<p><strong>迪米特法则:一个类要尽量减少对别的类的了解，尽量少用别的类和自己关联</strong></p>
<p><strong>接口隔离原则:一个接口一个行为，不要一个接口 n 个行为</strong></p>
<p><strong>合成复用原则:除非设计上需要继承，否则尽量用组合复用的形式</strong></p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>SRP(Single Responsibility Principle)</p>
<p>类被修改的几率很大，因此应该专注于单一的功能。</p>
<p>如果把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能。</p>
<p>举例:假设程序、策划、美术三个工种是三个类，他们应该各司其职，在程序世界中只应该做自己应该做的事情。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>OCP(Open-Closed Principle)对拓展开发，对修改关闭</p>
<p>拓展开放:模块的行为可以被拓展从而满足新的需求</p>
<p>修改关闭:不允许修改模块的源代码（或者尽量使修改最小化)</p>
<p>举例:继承就是最典型的开闭原则的体现，可以通过添加新的子类和重写父类的方法来实现</p>
<h2 id="里氏替换原则-1"><a href="#里氏替换原则-1" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>LSP(Liskov Substitution Principle)</p>
<p>任何父类出现的地方，子类都可以替代</p>
<p>举例:用父类容器装载子类对象，因为子类对象包含了父类的所有内容</p>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>DIP(Dependence Inversion Principle)</p>
<p>要依赖于抽象，不要依赖于具体的实现</p>
<h2 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h2><p>LoP(Law of Demeter)</p>
<p>又称最少知识原则</p>
<p>一个对象应当对其它对象尽可能少的了解不要和陌生人说话</p>
<p>举例:一个对象中的成员，要尽可能少的直接和其它类建立关系目的是降低耦合性</p>
<h2 id="接口分离原则"><a href="#接口分离原则" class="headerlink" title="接口分离原则"></a>接口分离原则</h2><p>ISP(Interface Segregation Principle)</p>
<p>不应该强迫别人依赖他们不需要使用的方法</p>
<p>一个接口不需要提供太多的行为，一个接口应该尽量只提供一个对外的功能</p>
<p>让别人去选择需要实现什么样的行为，而不是把所有的行为都封装到一个接口当中</p>
<p>举例:飞行接口、走路接口、跑步接口等等虽然都是移动的行为但是我们应该把他们分为一个一个单独的接口，让别人去选择使用</p>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>CRP(Composite Reuse Principle)</p>
<p>尽量使用对象组合，而不是继承来达到复用的目的继承关系是强耦合，组合关系是低耦合</p>
<p>举例:脸应该是眼镜、鼻子、嘴巴、耳朵的组合，而不是依次的继承角色和装备也应该是组合，而不是继承</p>
<p>注意:不能盲目的使用合成复用原则，要在遵循迪米特原则的前提下</p>
<h2 id="如何使用这些原则"><a href="#如何使用这些原则" class="headerlink" title="如何使用这些原则"></a>如何使用这些原则</h2><p>在开始做项目之前，整理 UML 类图时先按自己的想法把需要的类整理出来</p>
<p>再把七大原则截图放在旁边，基于七大原则去优化整理自己的设计</p>
<p>整体目标就是:高内聚，低耦合</p>
<p>初学程序阶段</p>
<p>不要过多的<strong>纠结于七大原则</strong></p>
<p>先用最适合自己的方法把需求实现了再使用七大原则去优化</p>
<p>不要想着一步到位，要循序渐进</p>
<p>面向对象编程能力提升是需要经验积累的</p>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://clearacg.com">Aki_CCLing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://clearacg.com/posts/fd651bad/">https://clearacg.com/posts/fd651bad/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://clearacg.com" target="_blank">Secret Garden</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Technology/">Technology</a><a class="post-meta__tags" href="/tags/Code/">Code</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/65b2aa8b871b83018a3e31ec.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.staticfile.org/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/b7e144d1/" title="算法"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/qungz.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-09</div><div class="title">算法</div></div></a></div><div><a href="/posts/b8d84677/" title="Git常用操作"><img class="cover" src="https://pic.imgdb.cn/item/65b2a2ed871b83018a2d55de.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-16</div><div class="title">Git常用操作</div></div></a></div><div><a href="/posts/978bdfbc/" title="Unity 学习路线"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-05</div><div class="title">Unity 学习路线</div></div></a></div><div><a href="/posts/53b59015/" title="Unity 面试题 - CSharp 相关 Part 1"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-06</div><div class="title">Unity 面试题 - CSharp 相关 Part 1</div></div></a></div><div><a href="/posts/1c8fef53/" title="Unity 面试题 - CSharp 相关 Part 2"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-07</div><div class="title">Unity 面试题 - CSharp 相关 Part 2</div></div></a></div><div><a href="/posts/cbdf6728/" title="Unity 面试题 - Lua 相关"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-06</div><div class="title">Unity 面试题 - Lua 相关</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/65b2a3e9871b83018a2fa6bd.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Aki_CCLing</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AkiCCLing" target="_blank" title="GitHub"><i class="fa-brands fa-github" style="color: #1E3050;"></i></a><a class="social-icon" href="https://space.bilibili.com/5840406" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color: #FF6699;"></i></a><a class="social-icon" href="https://steamcommunity.com/id/AKIYC/" target="_blank" title="Steam"><i class="fa-brands fa-steam" style="color: #1E3050;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一个ACGN爱好者的Blog，有问题与我交流可在Bilibili 留言 / 私信，谢谢你的关注。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">面向对象的三大特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">实例化对象的基本语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">成员变量和访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">2.2.2.</span> <span class="toc-text">成员变量的使用和初始值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.2.3.</span> <span class="toc-text">访问修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">成员方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.</span> <span class="toc-text">垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7"><span class="toc-number">2.7.</span> <span class="toc-text">成员属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">2.7.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86"><span class="toc-number">2.7.2.</span> <span class="toc-text">数值保护和加密处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-%E5%92%8C-set-%E5%89%8D%E5%8F%AF%E5%8A%A0%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.7.3.</span> <span class="toc-text">get 和 set 前可加访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">2.7.4.</span> <span class="toc-text">自动属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-number">2.8.</span> <span class="toc-text">索引器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">2.9.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB"><span class="toc-number">2.10.</span> <span class="toc-text">静态类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.11.</span> <span class="toc-text">静态构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">2.12.</span> <span class="toc-text">拓展方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">2.12.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.12.2.</span> <span class="toc-text">基本语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%88%E4%BB%85%E5%81%9A%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.13.</span> <span class="toc-text">运算符重载（仅做了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">2.13.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">2.13.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.13.3.</span> <span class="toc-text">可重载的运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.13.4.</span> <span class="toc-text">不可重载的运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E5%B8%83%E7%B1%BB%EF%BC%88%E4%BB%85%E5%81%9A%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.14.</span> <span class="toc-text">内部类和分布类（仅做了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.14.1.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E7%B1%BB"><span class="toc-number">2.14.2.</span> <span class="toc-text">分布类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%83%A8%E7%B1%BB"><span class="toc-number">2.14.3.</span> <span class="toc-text">分部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%83%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.14.4.</span> <span class="toc-text">分部方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="toc-number">3.1.</span> <span class="toc-text">继承的基本规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="toc-number">3.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="toc-number">3.1.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-1"><span class="toc-number">3.1.3.</span> <span class="toc-text">访问修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">3.2.</span> <span class="toc-text">里氏替换原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4"><span class="toc-number">3.2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">基本实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">继承中的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-5"><span class="toc-number">3.3.1.</span> <span class="toc-text">基本概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6-%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-number">3.4.</span> <span class="toc-text">万物之父&amp;装箱拆箱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-6"><span class="toc-number">3.4.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-number">3.4.3.</span> <span class="toc-text">装箱拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="toc-number">3.4.4.</span> <span class="toc-text">密封类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">4.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vob"><span class="toc-number">4.1.</span> <span class="toc-text">Vob</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-7"><span class="toc-number">4.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-3"><span class="toc-number">4.1.2.</span> <span class="toc-text">基本语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">抽象类和抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">抽象函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-8"><span class="toc-number">4.3.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-4"><span class="toc-number">4.3.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.3.</span> <span class="toc-text">接口可以继承接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.4.</span> <span class="toc-text">显示实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.5.</span> <span class="toc-text">接口的作用和总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">密封方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">5.</span> <span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-9"><span class="toc-number">5.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">5.2.</span> <span class="toc-text">引用命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E5%AF%B9%E4%B8%8D%E5%90%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E5%90%8C%E5%90%8D%E7%B1%BB"><span class="toc-number">5.3.</span> <span class="toc-text">应对不同命名空间中的同名类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">5.4.</span> <span class="toc-text">嵌套命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E7%B1%BB"><span class="toc-number">5.4.1.</span> <span class="toc-text">使用嵌套命名空间中的类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Object-%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">Object 类中的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Equals"><span class="toc-number">6.1.1.</span> <span class="toc-text">Equals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReferenceEquals"><span class="toc-number">6.1.2.</span> <span class="toc-text">ReferenceEquals</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-1"><span class="toc-number">6.2.</span> <span class="toc-text">成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetType"><span class="toc-number">6.2.1.</span> <span class="toc-text">GetType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MemberwiseClone"><span class="toc-number">6.2.2.</span> <span class="toc-text">MemberwiseClone</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Equals-%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">Equals (虚方法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetHashCode-%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">GetHashCode (虚方法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ToString-%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.</span> <span class="toc-text">ToString (虚方法)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">string 的常用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StringBuilder"><span class="toc-number">8.</span> <span class="toc-text">StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder-%E7%B1%BB"><span class="toc-number">8.0.1.</span> <span class="toc-text">StringBuilder 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">8.0.2.</span> <span class="toc-text">示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">结构体和类的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E5%8C%BA%E5%88%AB"><span class="toc-number">9.1.</span> <span class="toc-text">细节区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">9.2.</span> <span class="toc-text">结构体和类的选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">抽象类和接口的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">10.1.</span> <span class="toc-text">相同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">10.2.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">10.3.</span> <span class="toc-text">如何选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">11.</span> <span class="toc-text">面向对象七大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">11.1.</span> <span class="toc-text">七大原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">11.2.</span> <span class="toc-text">单一职责原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">11.3.</span> <span class="toc-text">开闭原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99-1"><span class="toc-number">11.4.</span> <span class="toc-text">里氏替换原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99"><span class="toc-number">11.5.</span> <span class="toc-text">依赖倒转原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99"><span class="toc-number">11.6.</span> <span class="toc-text">迪米特原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">11.7.</span> <span class="toc-text">接口分离原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">11.8.</span> <span class="toc-text">合成复用原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%88%99"><span class="toc-number">11.9.</span> <span class="toc-text">如何使用这些原则</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/df5996f0/" title="Unity 面试题杂项"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity 面试题杂项"/></a><div class="content"><a class="title" href="/posts/df5996f0/" title="Unity 面试题杂项">Unity 面试题杂项</a><time datetime="2024-08-10T23:05:48.000Z" title="发表于 2024-08-10 23:05:48">2024-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b7e144d1/" title="算法"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/qungz.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法"/></a><div class="content"><a class="title" href="/posts/b7e144d1/" title="算法">算法</a><time datetime="2024-08-09T20:44:54.000Z" title="发表于 2024-08-09 20:44:54">2024-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2f9ec35b/" title="Unity 面试题 - Unity 相关 Part 2"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity 面试题 - Unity 相关 Part 2"/></a><div class="content"><a class="title" href="/posts/2f9ec35b/" title="Unity 面试题 - Unity 相关 Part 2">Unity 面试题 - Unity 相关 Part 2</a><time datetime="2024-08-07T21:14:32.000Z" title="发表于 2024-08-07 21:14:32">2024-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1c8fef53/" title="Unity 面试题 - CSharp 相关 Part 2"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity 面试题 - CSharp 相关 Part 2"/></a><div class="content"><a class="title" href="/posts/1c8fef53/" title="Unity 面试题 - CSharp 相关 Part 2">Unity 面试题 - CSharp 相关 Part 2</a><time datetime="2024-08-07T14:57:43.000Z" title="发表于 2024-08-07 14:57:43">2024-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/cbdf6728/" title="Unity 面试题 - Lua 相关"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity 面试题 - Lua 相关"/></a><div class="content"><a class="title" href="/posts/cbdf6728/" title="Unity 面试题 - Lua 相关">Unity 面试题 - Lua 相关</a><time datetime="2024-08-06T15:55:08.000Z" title="发表于 2024-08-06 15:55:08">2024-08-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Aki_CCLing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20238180" target="_blank">萌ICP备20238180号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.staticfile.org/fancyapps-ui/5.0.33/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://venerable-smakager-94ad33.netlify.app/.netlify/functions/twikoo',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://venerable-smakager-94ad33.netlify.app/.netlify/functions/twikoo',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.staticfile.org/twikoo/1.6.31/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>