<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CSharp 进阶 | Secret Garden</title><meta name="author" content="Aki_CCLing"><meta name="copyright" content="Aki_CCLing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ArrayList 知识点知识点一 ArrayList 的本质ArrayList 是一个 C#为我们封装好的类，它的本质是一个 object 类型的数组。 ArrayList 类帮助我们实现了很多方法，比如数组的增删查改。 知识点二 声明需要引用命名空间 using System.Collections; 1ArrayList array &#x3D; new ArrayList();  知识点三 增删查改">
<meta property="og:type" content="article">
<meta property="og:title" content="CSharp 进阶">
<meta property="og:url" content="https://clearacg.com/posts/1234f57c/index.html">
<meta property="og:site_name" content="Secret Garden">
<meta property="og:description" content="ArrayList 知识点知识点一 ArrayList 的本质ArrayList 是一个 C#为我们封装好的类，它的本质是一个 object 类型的数组。 ArrayList 类帮助我们实现了很多方法，比如数组的增删查改。 知识点二 声明需要引用命名空间 using System.Collections; 1ArrayList array &#x3D; new ArrayList();  知识点三 增删查改">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/65b2aa8b871b83018a3e31ec.jpg">
<meta property="article:published_time" content="2024-02-25T16:44:24.000Z">
<meta property="article:modified_time" content="2024-07-23T00:03:06.000Z">
<meta property="article:author" content="Aki_CCLing">
<meta property="article:tag" content="Technology">
<meta property="article:tag" content="Code">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/65b2aa8b871b83018a3e31ec.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CSharp 进阶",
  "url": "https://clearacg.com/posts/1234f57c/",
  "image": "https://pic.imgdb.cn/item/65b2aa8b871b83018a3e31ec.jpg",
  "datePublished": "2024-02-25T16:44:24.000Z",
  "dateModified": "2024-07-23T00:03:06.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Aki_CCLing",
      "url": "https://clearacg.com/"
    }
  ]
}</script><link rel="shortcut icon" href="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/202402221339492.webp"><link rel="canonical" href="https://clearacg.com/posts/1234f57c/index.html"><link rel="preconnect" href="https://cdn.staticfile.org"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.3.5"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6ec84f1c930ef67ebd0716b3d42538a0";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;8c2bdf8651d54d3a82a47995bcb6e5cc&quot;}"></script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "mvz06k2itn");</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.staticfile.org/egjs-infinitegrid/4.12.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CSharp 进阶',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/style.css?1"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-image: url(url(https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/index/202402212340984.webp?imageSlim));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://pic.imgdb.cn/item/65b2a3e9871b83018a2fa6bd.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> My ACG</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa-solid fa-play"></i><span> 追番</span></a></li><li><a class="site-page child" href="/game/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/acggoods/"><i class="fa-fw fa-solid fa-gift"></i><span> 我的 ACG 周边</span></a></li><li><a class="site-page child" href="/acgmusic/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/acglive/"><i class="fa-fw fa-solid fa-guitar"></i><span> LIVE</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-solid fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://pic.imgdb.cn/item/65b2aa8b871b83018a3e31ec.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Secret Garden</span></a><a class="nav-page-title" href="/"><span class="site-name">CSharp 进阶</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> My ACG</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa-solid fa-play"></i><span> 追番</span></a></li><li><a class="site-page child" href="/game/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/acggoods/"><i class="fa-fw fa-solid fa-gift"></i><span> 我的 ACG 周边</span></a></li><li><a class="site-page child" href="/acgmusic/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/acglive/"><i class="fa-fw fa-solid fa-guitar"></i><span> LIVE</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fa-solid fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CSharp 进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-25T16:44:24.000Z" title="发表于 2024-02-25 16:44:24">2024-02-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-23T00:03:06.000Z" title="更新于 2024-07-23 00:03:06">2024-07-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology/">Technology</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology/Unity/">Unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Technology/Unity/CSharp/">CSharp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2024-07-23 00:03:06&quot;}" hidden></div><h1 id="ArrayList-知识点"><a href="#ArrayList-知识点" class="headerlink" title="ArrayList 知识点"></a>ArrayList 知识点</h1><h2 id="知识点一-ArrayList-的本质"><a href="#知识点一-ArrayList-的本质" class="headerlink" title="知识点一 ArrayList 的本质"></a>知识点一 ArrayList 的本质</h2><p>ArrayList 是一个 C#为我们封装好的类，它的本质是一个 object 类型的数组。</p>
<p>ArrayList 类帮助我们实现了很多方法，比如数组的增删查改。</p>
<h2 id="知识点二-声明"><a href="#知识点二-声明" class="headerlink" title="知识点二 声明"></a>知识点二 声明</h2><p>需要引用命名空间 using System.Collections;</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList array = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-增删查改"><a href="#知识点三-增删查改" class="headerlink" title="知识点三 增删查改"></a>知识点三 增删查改</h2><p>增</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">object</span>? <span class="keyword">value</span></span>)</span>;	<span class="comment">//添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddRange</span>(<span class="params">ICollection c</span>)</span>;	<span class="comment">//添加一个范围内的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, <span class="built_in">object</span>? <span class="keyword">value</span></span>)</span>; <span class="comment">//在index处插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InsertRange</span>(<span class="params"><span class="built_in">int</span> index, ICollection c</span>)</span>;	<span class="comment">//在index处插入指定范围元素</span></span><br></pre></td></tr></table></figure>

<p>删</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">object</span>? obj</span>)</span>;	<span class="comment">//删除指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RemoveAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span>;	<span class="comment">//删除指定位置index的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RemoveRange</span>(<span class="params"><span class="built_in">int</span> index, <span class="built_in">int</span> count</span>)</span>;	<span class="comment">//删除指定位置index开始的count个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span>;	<span class="comment">//清空容器</span></span><br></pre></td></tr></table></figure>

<p>查</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">object</span>? <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;	<span class="comment">//索引器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">Contains</span>(<span class="params"><span class="built_in">object</span>? item</span>)</span>;	<span class="comment">//查找item是否存在于容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="title">IndexOf</span>(<span class="params"><span class="built_in">object</span>? <span class="keyword">value</span></span>)</span>;	<span class="comment">//正向查找value的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="title">LastIndexOf</span>(<span class="params"><span class="built_in">object</span>? <span class="keyword">value</span></span>)</span>;	<span class="comment">//反向查找value的位置</span></span><br></pre></td></tr></table></figure>

<p>改</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">0</span>] = <span class="string">&quot;999&quot;</span>;	<span class="comment">//直接使用索引器进行修改</span></span><br></pre></td></tr></table></figure>

<p>遍历</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; &#125;	<span class="comment">//属性，返回元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Capacity &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;	<span class="comment">//属性，返回容量</span></span><br><span class="line"><span class="comment">//迭代器遍历</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">object</span> item <span class="keyword">in</span> array)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点四-装箱拆箱"><a href="#知识点四-装箱拆箱" class="headerlink" title="知识点四 装箱拆箱"></a>知识点四 装箱拆箱</h2><p>ArrayList 本质上是一个可以自动扩容的 object 数组，由于用万物之父来存储数据，自然存在装箱拆箱</p>
<p>当往其中进行值类型存储时就是在装箱，当将值类型对象取出来转换使用时，就存在拆箱</p>
<p>所以 ArrayList 尽量少用，之后我们会学习更好的数据容器。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> k = <span class="number">1</span>;</span><br><span class="line">array[<span class="number">0</span>] = k;<span class="comment">//装箱</span></span><br><span class="line">k = (<span class="built_in">int</span>)array[<span class="number">0</span>];<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<h2 id="练习题一：请简述-ArrayList-和数组的区别"><a href="#练习题一：请简述-ArrayList-和数组的区别" class="headerlink" title="练习题一：请简述 ArrayList 和数组的区别"></a>练习题一：请简述 ArrayList 和数组的区别</h2><p>ArrayList 本质上是一个 object 数组的封装</p>
<ol>
<li>ArrayList 可以不用一开始就定长，单独使用数组是定长的</li>
<li>数组可以指定存储类型，ArrayList 默认为 object 类型</li>
<li>数组的增删需要我们自己去实现，ArrayList 帮我们封装了方便的 API 来使用</li>
<li>ArrayList 使用时可能存在装箱拆箱，数组使用时只要不是 object 数组那就不存在这个问题</li>
<li>数组长度为 Length, ArrayList 长度为 Count</li>
</ol>
<h1 id="Stack-知识点"><a href="#Stack-知识点" class="headerlink" title="Stack 知识点"></a>Stack 知识点</h1><h2 id="知识点一-Stack-的本质"><a href="#知识点一-Stack-的本质" class="headerlink" title="知识点一 Stack 的本质"></a>知识点一 Stack 的本质</h2><p>Stack（栈）是一个 C#为我们封装好的类</p>
<p>它的本质也是 object[]数组，只是封装了特殊的存储规则</p>
<p>Stack 是栈存储容器，栈是一种先进后出的数据结构</p>
<p>先存入的数据后获取，后存入的数据先获取</p>
<p>栈是先进后出</p>
<h2 id="知识点二-声明-1"><a href="#知识点二-声明-1" class="headerlink" title="知识点二 声明"></a>知识点二 声明</h2><p>需要引用命名空间 System.Collections</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack stack = <span class="keyword">new</span> Stack();</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-增取查改"><a href="#知识点三-增取查改" class="headerlink" title="知识点三 增取查改"></a>知识点三 增取查改</h2><p>增</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span>;	<span class="comment">//入栈</span></span><br></pre></td></tr></table></figure>

<p>取</p>
<p>栈中不存在删除的概念，只有取出栈的概念</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">object</span> <span class="title">Pop</span>()</span>;	<span class="comment">//出栈，删除栈顶元素，并返回这个元素</span></span><br></pre></td></tr></table></figure>

<p>查</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈无法查看指定位置的 元素，只能查看栈顶的内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">object</span> <span class="title">Peek</span>()</span>;	<span class="comment">//返回栈顶元素，但是不删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">Contains</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span>;	<span class="comment">//查看元素是否存在于栈中</span></span><br></pre></td></tr></table></figure>

<p>改</p>
<p>栈无法改变其中的元素 只能压(存)和弹（取），实在要改 只有清空</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span>;	<span class="comment">//清空栈</span></span><br></pre></td></tr></table></figure>

<h2 id="知识点四-遍历"><a href="#知识点四-遍历" class="headerlink" title="知识点四 遍历"></a>知识点四 遍历</h2><p>长度</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; &#125;	<span class="comment">//属性，返回栈中元素个数</span></span><br></pre></td></tr></table></figure>

<p>用 foreach 遍历，遍历出来的顺序 也是从栈顶到栈底</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="built_in">object</span> item <span class="keyword">in</span> stack)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种遍历方式，将栈转换为 object 数组，遍历出来的顺序 也是从栈顶到栈底</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span>[] array = stack.ToArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环弹栈遍历</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( stack.Count &gt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> o = stack.Pop();</span><br><span class="line">    Console.WriteLine(o);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(stack.Count);</span><br></pre></td></tr></table></figure>

<h2 id="知识点五-装箱拆箱"><a href="#知识点五-装箱拆箱" class="headerlink" title="知识点五 装箱拆箱"></a>知识点五 装箱拆箱</h2><p>由于用万物之父来存储数据，自然存在装箱拆箱。</p>
<p>当往其中进行值类型存储时就是在装箱。</p>
<p>当将值类型对象取出来转换使用时，就存在拆箱。</p>
<h1 id="Queue-知识点"><a href="#Queue-知识点" class="headerlink" title="Queue 知识点"></a>Queue 知识点</h1><h2 id="知识点一-Queue-本质"><a href="#知识点一-Queue-本质" class="headerlink" title="知识点一 Queue 本质"></a>知识点一 Queue 本质</h2><p>Queue 是一个 C#为我们封装好的类，它的本质也是 object[]数组，只是封装了特殊的存储规则</p>
<p>Queue 是队列存储容器，队列是一种先进先出的数据结构，先存入的数据先获取，后存入的数据后获取。</p>
<p>先进先出</p>
<h2 id="知识点二-声明-2"><a href="#知识点二-声明-2" class="headerlink" title="知识点二 声明"></a>知识点二 声明</h2><p>需要引用命名空间 System.Collections</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue queue = <span class="keyword">new</span> Queue();</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-增取查改-1"><a href="#知识点三-增取查改-1" class="headerlink" title="知识点三 增取查改"></a>知识点三 增取查改</h2><p>增</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Enqueue</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span>;	<span class="comment">//入队</span></span><br></pre></td></tr></table></figure>

<p>取</p>
<p>队列中不存在删除的概念，只有取的概念 取出先加入的对象</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">object</span> <span class="title">Dequeue</span>()</span>;	<span class="comment">//取出队头元素并删除，然后返回</span></span><br></pre></td></tr></table></figure>

<p>查</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看队列头部元素但不会移除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">object</span> <span class="title">Peek</span>()</span>;	<span class="comment">//取出队头元素但不删除，然后返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">Contains</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span>;	<span class="comment">//查看元素是否存在于队列中</span></span><br></pre></td></tr></table></figure>

<p>改</p>
<p>队列无法改变其中的元素 只能进出队列，实在要改 只有清空</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span>;</span><br></pre></td></tr></table></figure>

<h2 id="知识点四-遍历-1"><a href="#知识点四-遍历-1" class="headerlink" title="知识点四 遍历"></a>知识点四 遍历</h2><p>长度</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>用 foreach 遍历</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="built_in">object</span> item <span class="keyword">in</span> queue)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将队列转换为 object 数组遍历</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span>[] array = queue.ToArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环出队遍历</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(queue.Count&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> o = queue.Dequeue();</span><br><span class="line">    Console.WriteLine(o);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(queue.Count);</span><br></pre></td></tr></table></figure>

<h2 id="知识点五-装箱拆箱-1"><a href="#知识点五-装箱拆箱-1" class="headerlink" title="知识点五 装箱拆箱"></a>知识点五 装箱拆箱</h2><p>由于用万物之父来存储数据，自然存在装箱拆箱。</p>
<p>当往其中进行值类型存储时就是在装箱。</p>
<p>当将值类型对象取出来转换使用时，就存在拆箱。</p>
<h1 id="Hashtable-知识点"><a href="#Hashtable-知识点" class="headerlink" title="Hashtable 知识点"></a>Hashtable 知识点</h1><h2 id="知识点一-Hashtalbe-的本质"><a href="#知识点一-Hashtalbe-的本质" class="headerlink" title="知识点一 Hashtalbe 的本质"></a>知识点一 Hashtalbe 的本质</h2><p>Hashtable（又称散列表） 是基于键的哈希代码组织起来的 键&#x2F;值对</p>
<p>它的主要作用是提高数据查询的效率</p>
<p>使用键来访问集合中的元素</p>
<h2 id="知识点二-声明-3"><a href="#知识点二-声明-3" class="headerlink" title="知识点二 声明"></a>知识点二 声明</h2><p>需要引用命名空间 System.Collections</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-增删查改-1"><a href="#知识点三-增删查改-1" class="headerlink" title="知识点三 增删查改"></a>知识点三 增删查改</h2><p>增</p>
<p>注意：不能出现相同键</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">object</span> key, <span class="built_in">object</span>? <span class="keyword">value</span></span>)</span>;	<span class="comment">//添加一组键值对</span></span><br></pre></td></tr></table></figure>

<p>删：只能通过键去删除；删除不存在的键 没反应；或者直接清空</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">object</span> key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span>;</span><br></pre></td></tr></table></figure>

<p>查</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">object</span>? <span class="keyword">this</span>[<span class="built_in">object</span> key] &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;	<span class="comment">//索引器，通过键查找值</span></span><br><span class="line"><span class="comment">//查看是否存在，根据键检测，找不开返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">Contains</span>(<span class="params"><span class="built_in">object</span> key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">ContainsKey</span>(<span class="params"><span class="built_in">object</span> key</span>)</span>;</span><br><span class="line"><span class="comment">//根据值检测</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">ContainsValue</span>(<span class="params"><span class="built_in">object</span>? <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure>

<p>改：只能改 键对应的值内容 无法修改键</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashtable[<span class="number">1</span>] = <span class="number">100.5f</span>;	<span class="comment">//通过索引器修改</span></span><br></pre></td></tr></table></figure>

<h2 id="知识点四-遍历-2"><a href="#知识点四-遍历-2" class="headerlink" title="知识点四 遍历"></a>知识点四 遍历</h2><p>得到键值对 对数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; &#125;	<span class="comment">//属性，返回键值对的个数</span></span><br></pre></td></tr></table></figure>

<p>遍历所有键</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="built_in">object</span> item <span class="keyword">in</span> hashtable.Keys)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;键：&quot;</span>+item);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;值：&quot;</span>+hashtable[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历所有值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="built_in">object</span> item <span class="keyword">in</span> hashtable.Values)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;值：&quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>键值对一起遍历</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (DictionaryEntry item <span class="keyword">in</span> hashtable)</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;键：&quot;</span> + item.Key + <span class="string">&quot;值：&quot;</span> + item.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器遍历法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IDictionaryEnumerator myEnumerator = hashtable.GetEnumerator();</span><br><span class="line"><span class="built_in">bool</span> flag = myEnumerator.MoveNext();</span><br><span class="line"><span class="keyword">while</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;键：&quot;</span> + myEnumerator.Key + <span class="string">&quot;值：&quot;</span> + myEnumerator.Value);</span><br><span class="line">    flag = myEnumerator.MoveNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点五-装箱拆箱-2"><a href="#知识点五-装箱拆箱-2" class="headerlink" title="知识点五 装箱拆箱"></a>知识点五 装箱拆箱</h2><p>由于用万物之父来存储数据，自然存在装箱拆箱</p>
<p>当往其中进行值类型存储时就是在装箱</p>
<p>当将值类型对象取出来转换使用时，就存在拆箱</p>
<h1 id="泛型-知识点"><a href="#泛型-知识点" class="headerlink" title="泛型 知识点"></a>泛型 知识点</h1><h2 id="知识点一-泛型是什么"><a href="#知识点一-泛型是什么" class="headerlink" title="知识点一 泛型是什么"></a>知识点一 泛型是什么</h2><p>泛型实现了类型参数化，达到代码重用目的</p>
<p>通过类型参数化来实现同一份代码上操作多种类型</p>
<p>泛型相当于类型占位符</p>
<p>定义类或方法时使用替代符代表变量类型</p>
<p>当真正使用类或者方法时再具体指定类型</p>
<h2 id="知识点二-泛型分类"><a href="#知识点二-泛型分类" class="headerlink" title="知识点二 泛型分类"></a>知识点二 泛型分类</h2><p>泛型类和泛型接口</p>
<p>基本语法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&lt;泛型占位字母&gt;</span><br><span class="line"><span class="title">interface</span> 接口名&lt;泛型占位字母&gt;</span><br></pre></td></tr></table></figure>

<p>泛型函数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法：函数名&lt;泛型占位字母&gt;(参数列表)</span></span><br></pre></td></tr></table></figure>

<p>注意：泛型占位字母可以有多个，用逗号分开</p>
<h2 id="知识点三-泛型类和接口"><a href="#知识点三-泛型类和接口" class="headerlink" title="知识点三 泛型类和接口"></a>知识点三 泛型类和接口</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass2</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>,<span class="title">K</span>,<span class="title">M</span>,<span class="title">LL</span>,<span class="title">Key</span>,<span class="title">Value</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T1 value1;</span><br><span class="line">    <span class="keyword">public</span> T2 value2;</span><br><span class="line">    <span class="keyword">public</span> K value3;</span><br><span class="line">    <span class="keyword">public</span> M value4;</span><br><span class="line">    <span class="keyword">public</span> LL value5;</span><br><span class="line">    <span class="keyword">public</span> Key value6;</span><br><span class="line">    <span class="keyword">public</span> Value value7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">TestInterface</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T Value</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，继承泛型接口，必须指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span> : <span class="title">TestInterface</span>&lt;<span class="title">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value &#123; <span class="keyword">get</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); <span class="keyword">set</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TestClass&lt;<span class="built_in">int</span>&gt; t = <span class="keyword">new</span> TestClass&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">t.<span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">Console.WriteLine(t.<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">TestClass&lt;<span class="built_in">string</span>&gt; t2 = <span class="keyword">new</span> TestClass&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">t2.<span class="keyword">value</span> = <span class="string">&quot;123123&quot;</span>;</span><br><span class="line">Console.WriteLine(t2.<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">TestClass2&lt;<span class="built_in">int</span>, <span class="built_in">string</span>, <span class="built_in">float</span>, <span class="built_in">double</span>, TestClass&lt;<span class="built_in">int</span>&gt;, <span class="built_in">uint</span>, <span class="built_in">short</span>&gt; t3 = <span class="keyword">new</span> TestClass2&lt;<span class="built_in">int</span>, <span class="built_in">string</span>, <span class="built_in">float</span>, <span class="built_in">double</span>, TestClass&lt;<span class="built_in">int</span>&gt;, <span class="built_in">uint</span>, <span class="built_in">short</span>&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="知识点四-泛型方法"><a href="#知识点四-泛型方法" class="headerlink" title="知识点四 泛型方法"></a>知识点四 泛型方法</h2><h3 id="普通类中的泛型方法"><a href="#普通类中的泛型方法" class="headerlink" title="普通类中的泛型方法"></a>普通类中的泛型方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">T</span>&gt;(<span class="params"> T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">T</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//用泛型类型 在里面做一些逻辑处理</span></span><br><span class="line">        T t = <span class="literal">default</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">TestFun</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> v</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">default</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">T</span>,<span class="title">K</span>,<span class="title">M</span>&gt;(<span class="params">T t, K k, M m</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型类中的泛型方法"><a href="#泛型类中的泛型方法" class="headerlink" title="泛型类中的泛型方法"></a>泛型类中的泛型方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">K</span>&gt;(<span class="params">K k</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个不叫泛型方法 因为 T是泛型类申明的时候 就指定 在使用这个函数的时候</span></span><br><span class="line">    <span class="comment">//我们不能再去动态的变化了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">T t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Test2 tt = <span class="keyword">new</span> Test2();</span><br><span class="line">tt.TestFun&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;123123&quot;</span>);</span><br><span class="line"></span><br><span class="line">Test2&lt;<span class="built_in">int</span>&gt; tt2 = <span class="keyword">new</span> Test2&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">tt2.TestFun(<span class="number">10</span>);</span><br><span class="line">tt2.TestFun&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">tt2.TestFun&lt;<span class="built_in">float</span>&gt;(<span class="number">1.2f</span>);</span><br><span class="line">tt2.TestFun(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h2 id="知识点五-泛型的作用"><a href="#知识点五-泛型的作用" class="headerlink" title="知识点五 泛型的作用"></a>知识点五 泛型的作用</h2><ol>
<li>不同类型对象的相同逻辑处理就可以选择泛型</li>
<li>使用泛型可以一定程度避免装箱拆箱</li>
</ol>
<p>举例：优化 ArrayList</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"> T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>声明泛型时 它只是一个类型的占位符</li>
<li>泛型真正起作用的时候 是在使用它的时候</li>
<li>泛型占位字母可以有 n 个用逗号分开</li>
<li>泛型占位字母一般是大写字母</li>
<li>不确定泛型类型时 获取默认值 可以使用 default(占位字符)</li>
<li>看到&lt;&gt;包裹的字母 那肯定是泛型</li>
</ol>
<h1 id="泛型约束-知识点"><a href="#泛型约束-知识点" class="headerlink" title="泛型约束 知识点"></a>泛型约束 知识点</h1><h2 id="知识点一-什么是泛型约束"><a href="#知识点一-什么是泛型约束" class="headerlink" title="知识点一 什么是泛型约束"></a>知识点一 什么是泛型约束</h2><p>让泛型的类型有一定的限制，关键字：where</p>
<p>泛型约束一共有 6 种：</p>
<table>
<thead>
<tr>
<th align="center">约束</th>
<th align="center">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">值类型</td>
<td align="center">where 泛型字母:struct</td>
</tr>
<tr>
<td align="center">引用类型</td>
<td align="center">where 泛型字母:class</td>
</tr>
<tr>
<td align="center">存在无参公共构造函数</td>
<td align="center">where 泛型字母:new()</td>
</tr>
<tr>
<td align="center">某个类本身或者其派生类</td>
<td align="center">where 泛型字母:类名</td>
</tr>
<tr>
<td align="center">某个接口的派生类型</td>
<td align="center">where 泛型字母:接口名</td>
</tr>
<tr>
<td align="center">另一个泛型类型本身或者派生类型</td>
<td align="center">where 泛型字母:另一个泛型字母</td>
</tr>
</tbody></table>
<h2 id="知识点二-各泛型约束讲解"><a href="#知识点二-各泛型约束讲解" class="headerlink" title="知识点二 各泛型约束讲解"></a>知识点二 各泛型约束讲解</h2><h3 id="值类型约束"><a href="#值类型约束" class="headerlink" title="值类型约束"></a>值类型约束</h3><p>约束类型 T 必须是值类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>:<span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">K</span>&gt;(<span class="params">K v</span>) <span class="keyword">where</span> K:<span class="keyword">struct</span></span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用类型约束"><a href="#引用类型约束" class="headerlink" title="引用类型约束"></a>引用类型约束</h3><p>约束类型 T 必须是引用类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>:<span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">K</span>&gt;(<span class="params">K k</span>) <span class="keyword">where</span> K:<span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="公共无参构造约束"><a href="#公共无参构造约束" class="headerlink" title="公共无参构造约束"></a>公共无参构造约束</h3><p>约束类型 T 必须拥有公告无参构造函数（即可实例化，可 new）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test3</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>:<span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">K</span>&gt;(<span class="params">K k</span>) <span class="keyword">where</span> K : <span class="keyword">new</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类约束"><a href="#类约束" class="headerlink" title="类约束"></a>类约束</h3><p>约束类型 T 必须是某个类或者这个类的子类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test4</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Test1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">K</span>&gt;(<span class="params">K k</span>) <span class="keyword">where</span> K : Test1</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口约束"><a href="#接口约束" class="headerlink" title="接口约束"></a>接口约束</h3><p>约束类型必须是这个接口的子类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IMove</span>:<span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test4</span>:<span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test5</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">K</span>&gt;(<span class="params">K k</span>) <span class="keyword">where</span> K : IFly</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="另一个泛型约束"><a href="#另一个泛型约束" class="headerlink" title="另一个泛型约束"></a>另一个泛型约束</h3><p>约束类型 T 是 U 本身或者 U 的子类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test6</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">U</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;(<span class="params">K k</span>) <span class="keyword">where</span> K : V</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-约束的组合使用"><a href="#知识点三-约束的组合使用" class="headerlink" title="知识点三 约束的组合使用"></a>知识点三 约束的组合使用</h2><p>约束可以组合使用，但有时不能同时存在两个约束，或者两个约束的顺序有次序</p>
<p>比如，new()约束一般写在其他约束前面。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test7</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>: <span class="keyword">class</span>,<span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点四-多个泛型有约束"><a href="#知识点四-多个泛型有约束" class="headerlink" title="知识点四 多个泛型有约束"></a>知识点四 多个泛型有约束</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test8</span>&lt;<span class="title">T</span>,<span class="title">K</span>&gt; <span class="keyword">where</span> <span class="title">T</span>:<span class="keyword">class</span>,<span class="title">new</span>() <span class="keyword">where</span> <span class="title">K</span>:<span class="title">struct</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>泛型约束：让类型有一定限制</p>
<p>六种约束：class，struct，new()，类名，接口名，另一个泛型字母</p>
<p>注意：</p>
<ol>
<li>可以组合使用</li>
<li>多个泛型约束 用 where 连接即可</li>
</ol>
<h1 id="List-知识点"><a href="#List-知识点" class="headerlink" title="List 知识点"></a>List 知识点</h1><h2 id="知识点一-List-的本质"><a href="#知识点一-List-的本质" class="headerlink" title="知识点一 List 的本质"></a>知识点一 List 的本质</h2><p>List 是一个 C#为我们封装好的类，它的本质是一个可变类型的泛型数组。</p>
<p>List 类帮助我们实现了很多方法，比如泛型数组的增删查改。</p>
<h2 id="知识点二-声明-4"><a href="#知识点二-声明-4" class="headerlink" title="知识点二 声明"></a>知识点二 声明</h2><p>需要引用命名空间</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; list2 = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">List&lt;<span class="built_in">bool</span>&gt; list3 = <span class="keyword">new</span> List&lt;<span class="built_in">bool</span>&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-增删查改-2"><a href="#知识点三-增删查改-2" class="headerlink" title="知识点三 增删查改"></a>知识点三 增删查改</h2><p>增</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T item</span>)</span>;	<span class="comment">//添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddRange</span>(<span class="params">IEnumerable&lt;T&gt; collection</span>)</span>;	<span class="comment">//添加一个范围内的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, T item</span>)</span>;	<span class="comment">//在index处插入item</span></span><br></pre></td></tr></table></figure>

<p>删</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Remove</span>(<span class="params">T item</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span>;</span><br></pre></td></tr></table></figure>

<p>查</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;	<span class="comment">//索引器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Contains</span>(<span class="params">T item</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">IndexOf</span>(<span class="params">T item</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">LastIndexOf</span>(<span class="params">T item</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>改：使用索引器修改</p>
<h2 id="知识点四-遍历-3"><a href="#知识点四-遍历-3" class="headerlink" title="知识点四 遍历"></a>知识点四 遍历</h2><p>长度和容量</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Capacity &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>直接遍历</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(list[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foreach 遍历</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Dictionary-知识点"><a href="#Dictionary-知识点" class="headerlink" title="Dictionary 知识点"></a>Dictionary 知识点</h1><h2 id="知识点一-Dictionary-的本质"><a href="#知识点一-Dictionary-的本质" class="headerlink" title="知识点一 Dictionary 的本质"></a>知识点一 Dictionary 的本质</h2><p>可以将 Dictionary 理解为 拥有泛型的 Hashtable；</p>
<p>它也是基于键的哈希代码组织起来的 键&#x2F;值对；</p>
<p>键值对类型从 Hashtable 的 object 变为了可以自己制定的泛型。</p>
<h2 id="知识点二-声明-5"><a href="#知识点二-声明-5" class="headerlink" title="知识点二 声明"></a>知识点二 声明</h2><p>需要引用命名空间 using System.Collections.Generic</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-增删查改-3"><a href="#知识点三-增删查改-3" class="headerlink" title="知识点三 增删查改"></a>知识点三 增删查改</h2><p>增</p>
<p>注意：不能出现相同键</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">TKey key, TValue <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure>

<p>删：只能通过键去删除，删除不存在键 没反应。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Remove</span>(<span class="params">TKey key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span>;	<span class="comment">//清空</span></span><br></pre></td></tr></table></figure>

<p>查</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过键查看值，找不到直接报错，和HashTable不一样，不会返回null了</span></span><br><span class="line"><span class="keyword">public</span> TValue <span class="keyword">this</span>[TKey key] &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;	<span class="comment">//索引器</span></span><br><span class="line"><span class="comment">//查看是否存在，根据键检测</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ContainsKey</span>(<span class="params">TKey key</span>)</span>;</span><br><span class="line"><span class="comment">//根据值检测</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ContainsValue</span>(<span class="params">TValue <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure>

<p>改：通过索引器修改</p>
<h2 id="知识点四-遍历-4"><a href="#知识点四-遍历-4" class="headerlink" title="知识点四 遍历"></a>知识点四 遍历</h2><p>遍历所有键</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> dictionary.Keys)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">    Console.WriteLine(dictionary[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历所有值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> item <span class="keyword">in</span> dictionary.Values)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>键值对一起遍历</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt; item <span class="keyword">in</span> dictionary)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;键：&quot;</span> + item.Key + <span class="string">&quot;值：&quot;</span> + item.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="顺序存储和链式存储-知识点"><a href="#顺序存储和链式存储-知识点" class="headerlink" title="顺序存储和链式存储 知识点"></a>顺序存储和链式存储 知识点</h1><h2 id="知识点一-数据结构"><a href="#知识点一-数据结构" class="headerlink" title="知识点一 数据结构"></a>知识点一 数据结构</h2><p>数据结构：</p>
<p>数据结构是计算机存储、组织数据的方式（规则）；</p>
<p>数据结构是指相互之间存在一种或多种特定关系的数据元素的集合；</p>
<p>比如自定义的一个 类 也可以称为一种数据结构 自己定义的数据组合规则</p>
<blockquote>
<p>不要把数据结构想的太复杂，简单点理解，就是人定义的 存储数据 和 表示数据之间关系 的规则而已</p>
</blockquote>
<p>常用的数据结构（前辈总结和制定的一些经典规则）</p>
<p>数组、栈、队列、链表、树、图、堆、散列表</p>
<h2 id="知识点二-线性表"><a href="#知识点二-线性表" class="headerlink" title="知识点二 线性表"></a>知识点二 线性表</h2><p>线性表是一种数据结构，是由 n 个具有相同特性的数据元素的有限序列</p>
<p>比如数组、ArrayList、Stack、Queue、链表等等</p>
<p>顺序存储和链式存储 是数据结构中两种 存储结构</p>
<h2 id="知识点三-顺序存储"><a href="#知识点三-顺序存储" class="headerlink" title="知识点三 顺序存储"></a>知识点三 顺序存储</h2><p>数组、Stack、Queue、List、ArrayList —— 顺序存储</p>
<p>只是 数组、Stack、Queue 的 组织规则不同而已</p>
<p>顺序存储：用一组地址连续的存储单元依次存储线性表的各个数据元素</p>
<h2 id="知识点四-链式存储"><a href="#知识点四-链式存储" class="headerlink" title="知识点四 链式存储"></a>知识点四 链式存储</h2><p>单向链表、双向链表、循环链表 —— 链式存储</p>
<p>链式存储(链接存储)：用一组任意的存储单元存储线性表中的各个数据元素</p>
<h2 id="知识点五-自己实现一个最简单的单向链表"><a href="#知识点五-自己实现一个最简单的单向链表" class="headerlink" title="知识点五 自己实现一个最简单的单向链表"></a>知识点五 自己实现一个最简单的单向链表</h2><p>这里实现的链表有 bug，没有处理移除尾结点的情况。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 单向链表节点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">LinkedNode</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">    <span class="comment">//这个存储下一个元素是谁 相当于钩子</span></span><br><span class="line">    <span class="keyword">public</span> LinkedNode&lt;T&gt; nextNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedNode</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 单向链表类 管理 节点 管理 添加等等</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">LindedList</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> LinkedNode&lt;T&gt; head;</span><br><span class="line">    <span class="keyword">public</span> LinkedNode&lt;T&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//添加节点 必然是new一个新的节点</span></span><br><span class="line">        LinkedNode&lt;T&gt; node = <span class="keyword">new</span> LinkedNode&lt;T&gt;(<span class="keyword">value</span>);</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="literal">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            head = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            last.nextNode = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="literal">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( head.<span class="keyword">value</span>.Equals(<span class="keyword">value</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">            head = head.nextNode;</span><br><span class="line">            <span class="comment">//如果头节点 被移除 发现头节点变空</span></span><br><span class="line">            <span class="comment">//证明只有一个节点 那尾也要清空</span></span><br><span class="line">            <span class="keyword">if</span>( head == <span class="literal">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                last = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode&lt;T&gt; node = head;</span><br><span class="line">        <span class="keyword">while</span>(node.nextNode != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( node.nextNode.<span class="keyword">value</span>.Equals(<span class="keyword">value</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//让当前找到的这个元素的 上一个节点</span></span><br><span class="line">                <span class="comment">//指向 自己的下一个节点</span></span><br><span class="line">                node.nextNode = node.nextNode.nextNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点六-顺序存储和链式存储的优缺点"><a href="#知识点六-顺序存储和链式存储的优缺点" class="headerlink" title="知识点六 顺序存储和链式存储的优缺点"></a>知识点六 顺序存储和链式存储的优缺点</h2><p>从增删查改的角度去思考：</p>
<p>增：链式存储 计算上 优于顺序存储 （中间插入时链式不用像顺序一样去移动位置）</p>
<p>删：链式存储 计算上 优于顺序存储 （中间删除时链式不用像顺序一样去移动位置）</p>
<p>查：顺序存储 使用上 优于链式存储 （数组可以直接通过下标得到元素，链式需要遍历）</p>
<p>改：顺序存储 使用上 优于链式存储 （数组可以直接通过下标得到元素，链式需要遍历）</p>
<h2 id="练习题三-实现双向链表"><a href="#练习题三-实现双向链表" class="headerlink" title="练习题三-实现双向链表"></a>练习题三-实现双向链表</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">LinkedNode</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">public</span> LinkedNode&lt;T&gt; frontNode;</span><br><span class="line">    <span class="keyword">public</span> LinkedNode&lt;T&gt; nextNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedNode</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedNode&lt;T&gt; head;</span><br><span class="line">    <span class="keyword">private</span> LinkedNode&lt;T&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Count</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> LinkedNode&lt;T&gt; Head</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> LinkedNode&lt;T&gt; Last</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//新加节点</span></span><br><span class="line">        LinkedNode&lt;T&gt; node = <span class="keyword">new</span> LinkedNode&lt;T&gt;(<span class="keyword">value</span>);</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="literal">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            head = node;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//添加到尾部</span></span><br><span class="line">            last.nextNode = node;</span><br><span class="line">            <span class="comment">//尾部添加的节点 记录自己的上一个节点是谁</span></span><br><span class="line">            node.frontNode = last;</span><br><span class="line">            <span class="comment">//让当前新加的变成最后一个节点</span></span><br><span class="line">            last = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加了一个节点</span></span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//首先判断 有没有越界</span></span><br><span class="line">        <span class="keyword">if</span>( index &gt;= count || index &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;只有&#123;0&#125;个节点，请输入合法位置&quot;</span>, count);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> tempCount = <span class="number">0</span>;</span><br><span class="line">        LinkedNode&lt;T&gt; tempNode = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//找到了对应位置的节点 然后移除即可</span></span><br><span class="line">            <span class="keyword">if</span> ( tempCount == index )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当前要移除的节点的上一个节点 指向自己的下一个节点</span></span><br><span class="line">                <span class="keyword">if</span>( tempNode.frontNode != <span class="literal">null</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    tempNode.frontNode.nextNode = tempNode.nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tempNode.nextNode != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tempNode.nextNode.frontNode = tempNode.frontNode;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是头节点 那需要改变头节点的指向</span></span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果头节点被移除 那头节点就变成了头节点的下一个</span></span><br><span class="line">                    head = head.nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( index == count - <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//如果尾节点被移除了 那尾结点就变成了尾结点的上一个</span></span><br><span class="line">                    last = last.frontNode;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//移除了一个元素 就应该短一截</span></span><br><span class="line">                --count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每次循环完过后 要让当前临时节点 等于下一个节点</span></span><br><span class="line">            tempNode = tempNode.nextNode;</span><br><span class="line">            ++tempCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LinkedList-知识点"><a href="#LinkedList-知识点" class="headerlink" title="LinkedList 知识点"></a>LinkedList 知识点</h1><h2 id="知识点一-LinkedList"><a href="#知识点一-LinkedList" class="headerlink" title="知识点一 LinkedList"></a>知识点一 LinkedList</h2><p>LinkedList 是一个 C#为我们封装好的类，它的本质是一个可变类型的泛型双向链表</p>
<h2 id="知识点二-声明-6"><a href="#知识点二-声明-6" class="headerlink" title="知识点二 声明"></a>知识点二 声明</h2><p>需要引用命名空间</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;<span class="built_in">int</span>&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">LinkedList&lt;<span class="built_in">string</span>&gt; linkedList2 = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure>

<p>链表对象 需要掌握两个类</p>
<p>一个是链表本身 一个是链表节点类 LinkedListNode</p>
<h2 id="知识点三-增删查改-4"><a href="#知识点三-增删查改-4" class="headerlink" title="知识点三 增删查改"></a>知识点三 增删查改</h2><p>增</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkedListNode&lt;T&gt; <span class="title">AddLast</span>(<span class="params">T <span class="keyword">value</span></span>)</span>;	<span class="comment">//尾部添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LinkedListNode&lt;T&gt; <span class="title">AddFirst</span>(<span class="params">T <span class="keyword">value</span></span>)</span>;	<span class="comment">//头部添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LinkedListNode&lt;T&gt; <span class="title">AddAfter</span>(<span class="params">LinkedListNode&lt;T&gt; node, T <span class="keyword">value</span></span>)</span>;	<span class="comment">//在某个节点后添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LinkedListNode&lt;T&gt; <span class="title">AddBefore</span>(<span class="params">LinkedListNode&lt;T&gt; node, T <span class="keyword">value</span></span>)</span>;<span class="comment">//在某个节点前添加元素</span></span><br></pre></td></tr></table></figure>

<p>删</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveFirst</span>()</span>;	<span class="comment">//移除头结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveLast</span>()</span>;	<span class="comment">//移除尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Remove</span>(<span class="params">T <span class="keyword">value</span></span>)</span>;	<span class="comment">//移除指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">LinkedListNode&lt;T&gt; node</span>)</span>;	<span class="comment">//移除指定节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span>;	<span class="comment">//清空元素</span></span><br></pre></td></tr></table></figure>

<p>查</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LinkedListNode&lt;T&gt;? First &#123; <span class="keyword">get</span>; &#125;	<span class="comment">//头结点</span></span><br><span class="line"><span class="keyword">public</span> LinkedListNode&lt;T&gt;? Last &#123; <span class="keyword">get</span>; &#125;		<span class="comment">//尾结点</span></span><br><span class="line"><span class="comment">//找到第一个指定值的节点，无法直接通过下标获取中间元素，只有遍历查找指定位置元素</span></span><br><span class="line"><span class="keyword">public</span> LinkedListNode&lt;T&gt;? Find(T <span class="keyword">value</span>);</span><br><span class="line"><span class="comment">//找到最后一个指定值的节点</span></span><br><span class="line"><span class="keyword">public</span> LinkedListNode&lt;T&gt;? FindLast(T <span class="keyword">value</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Contains</span>(<span class="params">T <span class="keyword">value</span></span>)</span>;	<span class="comment">//判断是否存在</span></span><br></pre></td></tr></table></figure>

<p>改：要先得再改 得到节点 再改变其中的值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(linkedList.First.Value);</span><br><span class="line">linkedList.First.Value = <span class="number">10</span>;</span><br><span class="line">Console.WriteLine(linkedList.First.Value);</span><br></pre></td></tr></table></figure>

<h2 id="知识点四-遍历-5"><a href="#知识点四-遍历-5" class="headerlink" title="知识点四 遍历"></a>知识点四 遍历</h2><p>LinkedListNode</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LinkedListNode&lt;T&gt;? Next &#123; <span class="keyword">get</span>; &#125;	<span class="comment">//属性，上一个节点</span></span><br><span class="line"><span class="keyword">public</span> LinkedListNode&lt;T&gt;? Previous &#123; <span class="keyword">get</span>; &#125;	<span class="comment">//属性，下一个节点</span></span><br></pre></td></tr></table></figure>

<p>foreach 遍历</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> linkedList)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过节点遍历</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从头到尾</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; nowNode = linkedList.First;</span><br><span class="line"><span class="keyword">while</span> (nowNode != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(nowNode.Value);</span><br><span class="line">    nowNode = nowNode.Next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从尾到头</span></span><br><span class="line">nowNode = linkedList.Last;</span><br><span class="line"><span class="keyword">while</span> (nowNode != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(nowNode.Value);</span><br><span class="line">    nowNode = nowNode.Previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型栈和队列-知识点"><a href="#泛型栈和队列-知识点" class="headerlink" title="泛型栈和队列 知识点"></a>泛型栈和队列 知识点</h1><h2 id="知识点一-回顾数据容器"><a href="#知识点一-回顾数据容器" class="headerlink" title="知识点一 回顾数据容器"></a>知识点一 回顾数据容器</h2><p>变量</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无符号</span></span><br><span class="line"><span class="comment">//byte ushort uint ulong</span></span><br><span class="line"><span class="comment">//有符号</span></span><br><span class="line"><span class="comment">//sbyte short int long</span></span><br><span class="line"><span class="comment">//浮点数</span></span><br><span class="line"><span class="comment">//float double decimal</span></span><br><span class="line"><span class="comment">//特殊</span></span><br><span class="line"><span class="comment">//char bool string</span></span><br></pre></td></tr></table></figure>

<p>复杂数据容器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举 enum</span></span><br><span class="line"><span class="comment">//结构体 struct</span></span><br><span class="line"><span class="comment">//数组（一维、二维、交错） []  [,]  [][]</span></span><br><span class="line"><span class="comment">//类</span></span><br></pre></td></tr></table></figure>

<p>数据集合（容器）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using System.Collections;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList  object数据列表</span></span><br><span class="line"><span class="comment">//Stack 栈  先进后出</span></span><br><span class="line"><span class="comment">//Queue 队列  先进先出</span></span><br><span class="line"><span class="comment">//Hashtable   哈希表  键值对</span></span><br></pre></td></tr></table></figure>

<p>泛型数据集合</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using System.Collections.Generic;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//List  列表  泛型列表</span></span><br><span class="line"><span class="comment">//Dictionary 字典  泛型哈希表</span></span><br><span class="line"><span class="comment">//LinkedList 双向链表</span></span><br><span class="line"><span class="comment">//Statck 泛型栈</span></span><br><span class="line"><span class="comment">//Queue 泛型队列</span></span><br></pre></td></tr></table></figure>

<h2 id="知识点二-泛型栈和队列"><a href="#知识点二-泛型栈和队列" class="headerlink" title="知识点二 泛型栈和队列"></a>知识点二 泛型栈和队列</h2><p>命名空间：using System.Collections.Generic;</p>
<p>使用上 和之前的 Stack 和 Queue 一模一样</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="built_in">int</span>&gt; stack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">Queue&lt;<span class="built_in">object</span>&gt; queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">object</span>&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>自己总结一下，数组、List、Dictionary、Stack、Queue、LinkedList</p>
<p>这些存储容器，对于我们来说应该如何选择他们来使用</p>
<p>普通线性表：<br>数组，List，LinkedList<br>数组：固定的不变的一组数据<br>List: 经常改变，经常通过下标查找<br>LinkedList：不确定长度的，经常临时插入改变，查找不多</p>
<p>先进后出：<br>Stack<br>对于一些可以利用先进后出存储特点的逻辑<br>比如：UI 面板显隐规则</p>
<p>先进先出：<br>Queue<br>对于一些可以利用先进先出存储特点的逻辑<br>比如：消息队列，有了就往里放，然后慢慢依次处理</p>
<p>键值对：<br>Dictionary<br>需要频繁查找的，有对应关系的数据<br>比如一些数据存储 id 对应数据内容<br>道具 ID ——&gt; 道具信息<br>怪物 ID ——&gt; 怪物对象<br>等等</p>
<h1 id="委托-知识点"><a href="#委托-知识点" class="headerlink" title="委托 知识点"></a>委托 知识点</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AT411U7H2/?spm_id_from=333.788&vd_source=02ee6d2f2e800f429c9d6d0d1b14955f">C# 的委托与事件具体是怎么一回事_哔哩哔哩_bilibili</a></p>
<h2 id="知识点一-委托是什么"><a href="#知识点一-委托是什么" class="headerlink" title="知识点一 委托是什么"></a>知识点一 委托是什么</h2><p>委托是 函数(方法)的容器 ，可以理解为表示函数(方法)的变量类型</p>
<p>用来 存储、传递函数(方法)</p>
<p>委托的本质是一个类，用来定义函数(方法)的类型（返回值和参数的类型）</p>
<p>不同的 函数(方法)必须对应和各自”格式”一致的委托</p>
<h2 id="知识点二-基本语法"><a href="#知识点二-基本语法" class="headerlink" title="知识点二 基本语法"></a>知识点二 基本语法</h2><p>关键字 ： delegate<br>语法：访问修饰符 delegate 返回值 委托名(参数列表);</p>
<p>写在哪里？</p>
<p>可以声明在 namespace 和 class 语句块中</p>
<p>更多的写在 namespace 中</p>
<p>简单记忆委托语法 就是 函数申明语法前面加一个 delegate 关键字</p>
<h2 id="知识点三-定义自定义委托"><a href="#知识点三-定义自定义委托" class="headerlink" title="知识点三 定义自定义委托"></a>知识点三 定义自定义委托</h2><p>访问修饰默认不写 为 public 在别的命名空间中也能使用</p>
<p>private 其它命名空间就不能用了，一般使用 public</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申明了一个可以用来存储无参无返回值函数的容器</span></span><br><span class="line"><span class="comment">//这里只是定义了规则 并没有使用</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyFun</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托规则的申明 是不能重名（同一语句块中）</span></span><br><span class="line"><span class="comment">//表示用来装载或传递 返回值为int 有一个int参数的函数的 委托 容器规则</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyFun2</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托是支持 泛型的 可以让返回值和参数 可变 更方便我们的使用</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">MyFun3</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;(<span class="params">T v, K k</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="知识点四-使用定义好的委托"><a href="#知识点四-使用定义好的委托" class="headerlink" title="知识点四 使用定义好的委托"></a>知识点四 使用定义好的委托</h2><p>记住，委托变量是<strong>函数的容器</strong></p>
<p>注意：委托变量只能装载与本委托声明时，格式一致的函数。这里的格式是指<strong>返回值与参数</strong></p>
<p>委托常用在：</p>
<ol>
<li>作为类的成员</li>
<li>作为函数的参数</li>
</ol>
<p>直接使用委托变量：</p>
<p>注意：使用委托，会将容器中的所有函数<strong>全部都调用</strong>，调用的顺序是添加的顺序</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个委托变量f，它的格式是无参无返回值</span></span><br><span class="line">MyFun f = <span class="keyword">new</span> MyFun(Fun);	<span class="comment">//Fun是一个无参无返回值的函数名</span></span><br><span class="line">f.Invoke();					<span class="comment">//调用了Fun</span></span><br><span class="line">f();						<span class="comment">//调用了Fun</span></span><br></pre></td></tr></table></figure>

<h2 id="知识点五-委托变量可以存储多个函数-多播委托"><a href="#知识点五-委托变量可以存储多个函数-多播委托" class="headerlink" title="知识点五 委托变量可以存储多个函数(多播委托)"></a>知识点五 委托变量可以存储多个函数(多播委托)</h2><p>增加委托：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFun</span>(<span class="params">MyFun fun, MyFun2 fun2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//fun是一个委托变量</span></span><br><span class="line">    <span class="keyword">this</span>.fun += fun;	<span class="comment">//直接加</span></span><br><span class="line">    <span class="keyword">this</span>.fun2 += fun2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：也可以直接加一个函数</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyFun ff = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//ff = ff + Fun;</span></span><br><span class="line">ff += Fun;</span><br><span class="line">ff += Fun3;</span><br><span class="line"><span class="comment">//注意，不能在初始化时直接+</span></span><br><span class="line"><span class="comment">//MyFun ff += Fun;	//error</span></span><br></pre></td></tr></table></figure>

<p>删除委托：</p>
<blockquote>
<p>同样的，可以直接减一个函数，指定删除</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveFun</span>(<span class="params">MyFun fun, MyFun2 fun2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//this.fun = this.fun - fun;</span></span><br><span class="line">    <span class="keyword">this</span>.fun -= fun;	<span class="comment">//直接减</span></span><br><span class="line">    <span class="keyword">this</span>.fun2 -= fun2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从容器中移除指定的函数</span></span><br><span class="line">ff -= Fun;</span><br><span class="line"><span class="comment">//多减 不会报错 无非就是不处理而已</span></span><br><span class="line">ff -= Fun;</span><br><span class="line">ff();</span><br><span class="line"><span class="comment">//清空容器</span></span><br><span class="line">ff = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="知识点六-系统定义好的委托"><a href="#知识点六-系统定义好的委托" class="headerlink" title="知识点六 系统定义好的委托"></a>知识点六 系统定义好的委托</h2><p>使用系统自带委托 需要引用 using System;</p>
<p>参数修饰符：in 协变为参数，out 逆变为返回值。</p>
<p>Action：无返回值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Action action = Fun;</span><br><span class="line">action += Fun3;</span><br><span class="line">action();</span><br><span class="line"><span class="comment">//可以传n个参数的  系统提供了 1到16个参数的委托 直接用就行了</span></span><br><span class="line"><span class="comment">//定义了一个Action委托变量，这个委托的参数有两个</span></span><br><span class="line">Action&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; action2 = Fun6;</span><br></pre></td></tr></table></figure>

<p>Func：有返回值，最后一个类型为返回值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个Func委托变量，这个委托的参数有两个</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; funcString = Fun4;</span><br><span class="line">Func&lt;<span class="built_in">int</span>&gt; funcInt = Fun5;</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>简单理解 委托 就是装载、传递函数的容器而已</p>
<p>可以用委托变量 来存储函数或者传递函数的</p>
<p>系统其实已经提供了很多委托给我们用</p>
<p>Action:没有返回值，参数提供了 0~16 个委托给我们用</p>
<p>Func:有返回值，参数提供了 0~16 个委托给我们用</p>
<h1 id="事件-知识点"><a href="#事件-知识点" class="headerlink" title="事件 知识点"></a>事件 知识点</h1><h2 id="知识点一-事件是什么"><a href="#知识点一-事件是什么" class="headerlink" title="知识点一 事件是什么"></a>知识点一 事件是什么</h2><p>事件是基于委托的存在，事件是委托的安全包裹；</p>
<p>让委托的使用更具有安全性，事件 是一种特殊的变量类型。</p>
<blockquote>
<p>可以说，事件，就是类中的委托。</p>
</blockquote>
<h2 id="知识点二-事件的使用"><a href="#知识点二-事件的使用" class="headerlink" title="知识点二 事件的使用"></a>知识点二 事件的使用</h2><p>声明语法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">event</span> 委托类型 事件名;</span><br></pre></td></tr></table></figure>

<p>事件的使用：</p>
<ol>
<li>事件是作为 成员变量存在于类中</li>
<li><strong>委托</strong>怎么用 事件就怎么用</li>
</ol>
<p>事件相对于委托的区别:</p>
<ol>
<li>不能在类外部 赋值，即<strong>不能使用&#x3D;<strong>，但是</strong>可以在类外部+&#x3D;，-&#x3D;</strong></li>
<li>不能再类外部 调用，但是可以通过<strong>封装再调用</strong></li>
<li>事件 是<strong>不能作为临时变量</strong>在函数中使用的！</li>
</ol>
<p>注意：<strong>它只能作为成员存在于类和接口以及结构体中</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//委托成员变量 用于存储 函数的</span></span><br><span class="line">    <span class="keyword">public</span> Action myFun;</span><br><span class="line">    <span class="comment">//事件成员变量 用于存储 函数的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//事件的使用和委托 一模一样 只是有些 细微的区别</span></span><br><span class="line">        myFun = TestFun;</span><br><span class="line">        myFun += TestFun;</span><br><span class="line">        myFun -= TestFun;</span><br><span class="line">        myFun();</span><br><span class="line">        myFun.Invoke();</span><br><span class="line">        myFun = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        myEvent = TestFun;</span><br><span class="line">        myEvent += TestFun;</span><br><span class="line">        myEvent -= TestFun;</span><br><span class="line">        myEvent();</span><br><span class="line">        myEvent.Invoke();</span><br><span class="line">        myEvent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(myEvent != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            myEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件是不能再外部赋值的</span></span><br><span class="line"><span class="comment">//t.myEvent = null;</span></span><br><span class="line"><span class="comment">//t.myEvent = TestFun;</span></span><br><span class="line"><span class="comment">//t.myEvent = t.myEvent + TestFun;	//注意，这样也不行</span></span><br><span class="line"><span class="comment">//虽然不能直接赋值 但是可以 加减 去添加移除记录的函数</span></span><br><span class="line">t.myEvent += TestFun;</span><br><span class="line">t.myEvent -= TestFun;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件不能在外部调用</span></span><br><span class="line"><span class="comment">//t.myEvent();</span></span><br><span class="line"><span class="comment">//只能在类的内部去封装 调用</span></span><br><span class="line">t.DoEvent();</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件 是不能作为临时变量在函数中使用的</span></span><br><span class="line"><span class="comment">//event Action ae = TestFun;</span></span><br></pre></td></tr></table></figure>

<h2 id="知识点三-为什么有事件"><a href="#知识点三-为什么有事件" class="headerlink" title="知识点三 为什么有事件"></a>知识点三 为什么有事件</h2><ol>
<li>防止外部随意置空委托</li>
<li>防止外部随意调用委托</li>
<li>事件相当于对委托进行了一次封装 让其更加安全</li>
</ol>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>事件和委托的区别：事件和委托的使用基本是一模一样的，事件就是特殊的委托（类中的委托）</p>
<p>主要区别：</p>
<ol>
<li>事件不能再外部使用赋值&#x3D;符号，只能使用+ - 委托 哪里都能用</li>
<li>事件 不能再外部执行 委托哪里都能执行</li>
<li>事件 不能作为 函数中的临时变量的 委托可以</li>
</ol>
<h1 id="匿名函数-知识点"><a href="#匿名函数-知识点" class="headerlink" title="匿名函数 知识点"></a>匿名函数 知识点</h1><h2 id="知识点一-什么是匿名函数"><a href="#知识点一-什么是匿名函数" class="headerlink" title="知识点一 什么是匿名函数"></a>知识点一 什么是匿名函数</h2><p>顾名思义，就是没有名字的函数</p>
<p>匿名函数的使用主要是配合委托和事件进行使用</p>
<p>脱离委托和事件 是不会使用匿名函数的</p>
<h2 id="知识点二-基本语法-1"><a href="#知识点二-基本语法-1" class="headerlink" title="知识点二 基本语法"></a>知识点二 基本语法</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delegate</span> (参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数逻辑</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>何时使用？</p>
<ol>
<li>函数中传递委托参数时</li>
<li>委托或事件赋值时</li>
</ol>
<h2 id="知识点三-使用"><a href="#知识点三-使用" class="headerlink" title="知识点三 使用"></a>知识点三 使用</h2><p>它的使用就是委托或者事件的使用，区别是，一声明匿名函数就必须保存到委托或者事件中。</p>
<h3 id="无参无返回"><a href="#无参无返回" class="headerlink" title="无参无返回"></a>无参无返回</h3><p>注意：由于匿名函数是匿名的，所以，要使用它，<strong>必须保存到委托或者事件中！</strong></p>
<p>这样声明匿名函数 只是在声明函数而已 还没有调用</p>
<p>真正调用它的时候 是这个委托容器啥时候调用 就什么时候调用这个匿名函数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Action A = <span class="built_in">delegate</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;匿名函数逻辑&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A();</span><br></pre></td></tr></table></figure>

<h3 id="有参"><a href="#有参" class="headerlink" title="有参"></a>有参</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; b = <span class="built_in">delegate</span> (<span class="built_in">int</span> a, <span class="built_in">string</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">    Console.WriteLine(b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">b(<span class="number">100</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="有返回值"><a href="#有返回值" class="headerlink" title="有返回值"></a>有返回值</h3><p>注意，这个返回值是通过委托 Func 控制的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">string</span>&gt; c = <span class="built_in">delegate</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;123123&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(c());</span><br></pre></td></tr></table></figure>

<h3 id="一般使用情况"><a href="#一般使用情况" class="headerlink" title="一般使用情况"></a>一般使用情况</h3><p>一般情况会作为函数参数传递 或者 作为函数返回值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action action;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//作为参数传递时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dosomthing</span>(<span class="params"><span class="built_in">int</span> a, Action fun</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">GetFun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delegate</span>() &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;函数内部返回的一个匿名函数逻辑&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestTTTT</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作函数参数</span></span><br><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line">Action ac = <span class="built_in">delegate</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;随参数传入的匿名函数逻辑&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">t.Dosomthing(<span class="number">50</span>, ac);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  返回值</span></span><br><span class="line">Action ac2 = t.GetFun();</span><br><span class="line">ac2();</span><br><span class="line"><span class="comment">//一步到位 直接调用返回的 委托函数</span></span><br><span class="line">t.GetFun()();	<span class="comment">//这里调用GetFun返回了一个匿名函数，然后调用了他</span></span><br></pre></td></tr></table></figure>

<h2 id="知识点四-匿名函数的缺点"><a href="#知识点四-匿名函数的缺点" class="headerlink" title="知识点四 匿名函数的缺点"></a>知识点四 匿名函数的缺点</h2><p>添加到委托或事件容器中后 不记录 无法单独移除</p>
<p>因为匿名函数没有名字 所以没有办法指定移除某一个匿名函数</p>
<p>注意：同样逻辑的匿名函数，不是同一个函数。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此匿名函数 非彼匿名函数 不能通过看逻辑是否一样就证明是一个</span></span><br><span class="line"><span class="comment">//ac3 -= delegate ()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    Console.WriteLine(&quot;匿名函数一&quot;);</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>匿名函数 就是没有名字的函数</p>
<p>固定写法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delegate</span>(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用：主要是在 委托传递和存储时 为了方便可以直接使用该匿名函数</p>
<p>缺点是 没有办法指定移除</p>
<h1 id="lambda-表达式-知识点"><a href="#lambda-表达式-知识点" class="headerlink" title="lambda 表达式 知识点"></a>lambda 表达式 知识点</h1><h2 id="知识点一-什么是-lambda-表达式"><a href="#知识点一-什么是-lambda-表达式" class="headerlink" title="知识点一 什么是 lambda 表达式"></a>知识点一 什么是 lambda 表达式</h2><p>可以将 lambad 表达式 理解为匿名函数的简写。</p>
<p>它除了写法不同外，使用上和匿名函数一模一样，都是和委托或者事件 配合使用的。</p>
<h2 id="知识点二-lambda-表达式语法"><a href="#知识点二-lambda-表达式语法" class="headerlink" title="知识点二 lambda 表达式语法"></a>知识点二 lambda 表达式语法</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名函数</span></span><br><span class="line"><span class="comment">//delegate (参数列表)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lambad表达式</span></span><br><span class="line"><span class="comment">//(参数列表) =&gt;</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    //函数体</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="知识点三-使用-1"><a href="#知识点三-使用-1" class="headerlink" title="知识点三 使用"></a>知识点三 使用</h2><p>无参无返回</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Action a = () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;无参无返回值的lambda表达式&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<p>有参</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">int</span>&gt; a2 = (<span class="built_in">int</span> <span class="keyword">value</span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;有参数lambda表达式&#123;0&#125;&quot;</span>, <span class="keyword">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a2(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>甚至参数类型都可以省略 参数类型和委托或事件容器一致</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">int</span>&gt; a3 = (<span class="keyword">value</span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;省略参数类型的写法&#123;0&#125;&quot;</span>, <span class="keyword">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a3(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p>有返回值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; a4 = (<span class="keyword">value</span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;有返回值有参数的lambda表达式&#123;0&#125;&quot;</span>, <span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Console.WriteLine(a4(<span class="string">&quot;123123&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>其它传参使用等和匿名函数一样<br>缺点也是和匿名函数一样的</p>
<h2 id="知识点四-闭包"><a href="#知识点四-闭包" class="headerlink" title="知识点四 闭包"></a>知识点四 闭包</h2><p>内层的函数可以引用包含在它外层的函数的变量；</p>
<p>即使外层函数的执行已经终止</p>
<p>注意：该变量提供的值并非变量创建时的值，而是在<strong>父函数范围内的最终值</strong>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action action;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//这里就形成了闭包</span></span><br><span class="line">        <span class="comment">//因为 当构造函数执行完毕时  其中申明的临时变量value的声明周期被改变了</span></span><br><span class="line">        action = () =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此index 非彼index</span></span><br><span class="line">            <span class="built_in">int</span> index = i;</span><br><span class="line">            action += () =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//注意，这里的index值是10，因为i的最终值是10</span></span><br><span class="line">                Console.WriteLine(index);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomthing</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，上方程序中的 index 值是 10，因为 i 的最终值是 10</p>
</blockquote>
<h1 id="委托-补充知识点"><a href="#委托-补充知识点" class="headerlink" title="委托 补充知识点"></a>委托 补充知识点</h1><p>有返回值的委托存储多个函数 调用时如何获取多个返回值？</p>
<p>问题：当有返回值的委托容器，存储多个函数时，我们想要获取所有的返回值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">string</span>&gt; funTest = () =&gt; &#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;第一个函数&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">funTest += () =&gt; &#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;第二个函数&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">funTest += () =&gt; &#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;第三个函数&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Console.WriteLine(funTest());	<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>上述程序如果直接调用，只会输出一个 3，因为第三个函数是最后执行的，也就只返回最后一个函数的返回值。</p>
<p>为了解决这个问题，我们可以遍历委托容器中的每个函数</p>
<p>使用**Func.GetInvocationList()**函数获取容器中的每个函数，然后使用 foreach 遍历就可以了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (Func&lt;<span class="built_in">string</span>&gt; func <span class="keyword">in</span> funTest.GetInvocationList()) &#123;</span><br><span class="line">	Console.WriteLine(func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="List-排序-知识点"><a href="#List-排序-知识点" class="headerlink" title="List 排序 知识点"></a>List 排序 知识点</h1><h2 id="知识点一-List-自带排序方法"><a href="#知识点一-List-自带排序方法" class="headerlink" title="知识点一 List 自带排序方法"></a>知识点一 List 自带排序方法</h2><p>list 提供了排序方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>()</span>;	<span class="comment">//默认升序</span></span><br><span class="line"><span class="comment">//ArrayList中也有Sort排序方法</span></span><br></pre></td></tr></table></figure>

<h2 id="知识点二-自定义类的排序"><a href="#知识点二-自定义类的排序" class="headerlink" title="知识点二 自定义类的排序"></a>知识点二 自定义类的排序</h2><p>如果需要自定义类支持排序，类需要继承接口 IComparable&lt;ClassName&gt;</p>
<p>并且实现接口</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">ClassName other</span>)；</span></span><br></pre></td></tr></table></figure>

<h3 id="CompareTo-函数"><a href="#CompareTo-函数" class="headerlink" title="CompareTo 函数"></a>CompareTo 函数</h3><p>在这个函数当中，我们需要处理排序逻辑，通过这个函数的返回值，决定排序的规则。</p>
<p>返回值的含义：</p>
<p>小于 0：放在传入对象的前面</p>
<p>等于 0：保持当前的位置不变</p>
<p>大于 0：放在传入对象的后面</p>
<p>可以简单理解 传入对象的位置 就是 0；</p>
<p>如果你的返回为负数 就放在它的左边 也就前面；</p>
<p>如果你返回正数 就放在它的右边 也就是后面；</p>
<p>注意，这里作为参照的对象是传入的对象。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">Item other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//降序排序</span></span><br><span class="line">    <span class="comment">//如果本身的钱比另一个大，放到另一个的前面</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">this</span>.money &gt; other.money )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-通过委托函数进行排序"><a href="#知识点三-通过委托函数进行排序" class="headerlink" title="知识点三 通过委托函数进行排序"></a>知识点三 通过委托函数进行排序</h2><p>我们可以通过在排序函数传入委托，也就是函数，来指定排序规则。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Comparison</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T x, T y</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sort</span>(<span class="params">Comparison&lt;T&gt; comparison</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>comparison 是一个委托变量，所以，我们需要传入一个委托或者一个函数，用来指定排序规则。</p>
<p>其中，这个函数或委托，是一个有两个 T 类型的参数，返回 int。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个委托（也可以说是匿名函数）</span></span><br><span class="line">shopItems.Sort(<span class="built_in">delegate</span> (ShopItem a, ShopItem b)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> a.id &gt; b.id ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">               &#125;);</span><br><span class="line"><span class="comment">//传入一个lambda表达式（其实就是函数或者说委托）</span></span><br><span class="line">shopItems.Sort((a, b) =&gt;&#123; <span class="keyword">return</span> a.id &gt; b.id ? <span class="number">1</span> : <span class="number">-1</span>;&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>系统自带的变量(int,float,double…..) 一般都可以直接 Sort</p>
<p>自定义类 SOrt 有两种方式</p>
<ol>
<li>继承接口 IComparable</li>
<li>在 Sort 中传入委托函数</li>
</ol>
<h1 id="协变逆变-知识点"><a href="#协变逆变-知识点" class="headerlink" title="协变逆变 知识点"></a>协变逆变 知识点</h1><p>要理解协变逆变，其实就是要遵循<strong>里氏替换原则</strong>。</p>
<h2 id="知识点一-什么是协变逆变"><a href="#知识点一-什么是协变逆变" class="headerlink" title="知识点一 什么是协变逆变"></a>知识点一 什么是协变逆变</h2><p>协变：和谐的变化，自然的变化；和谐的变化，自然的变化。</p>
<p>所以 子类变父类，比如 string 变成 object，感受是和谐的。</p>
<p>逆变：逆常规的变化，不正常的变化；因为 里氏替换原则 父类可以装子类 但是子类不能装父类。</p>
<p>所以 父类变子类，比如 object 变成 string，感受是不和谐的。</p>
<p>协变和逆变是用来修饰泛型的</p>
<p><strong>协变：out</strong></p>
<p><strong>逆变：in</strong></p>
<p>用于在泛型中 修饰 泛型字母的；只有<strong>泛型接口和泛型委托</strong>能使用</p>
<h2 id="知识点二-作用"><a href="#知识点二-作用" class="headerlink" title="知识点二 作用"></a>知识点二 作用</h2><h3 id="返回值-和-参数"><a href="#返回值-和-参数" class="headerlink" title="返回值 和 参数"></a>返回值 和 参数</h3><p>用 out 修饰的泛型 只能作为返回值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">TestOut</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br></pre></td></tr></table></figure>

<p>用 in 修饰的泛型 只能作为参数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T t</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="知识点二-作用（结合里氏替换原则理解）"><a href="#知识点二-作用（结合里氏替换原则理解）" class="headerlink" title="知识点二 作用（结合里氏替换原则理解）"></a>知识点二 作用（结合里氏替换原则理解）</h2><p>协变 out：父类总是能被子类替换，允许<strong>子类返回值</strong>委托赋值给<strong>父类返回值</strong>委托。</p>
<p>out 是修饰返回值的。</p>
<p>out 修饰返回值类型，可以使得系统帮我们判断<strong>out 修饰的这个类型的委托</strong>的<strong>返回值</strong>是否可以存储到父类委托当中。</p>
<p>如果不添加 out 修饰符，是不允许<strong>子类返回值</strong>委托赋值给<strong>父类返回值</strong>委托。的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里声明了一个Son委托变量os，委托函数返回Son对象</span></span><br><span class="line">TestOut&lt;Son&gt; os = () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//然后声明了一个Father委托变量of = os；</span></span><br><span class="line"><span class="comment">//由于是out协变，允许子类委托赋值给父类委托</span></span><br><span class="line"><span class="comment">//因为里氏替换原则，父类可以装子类。</span></span><br><span class="line">TestOut&lt;Father&gt; of = os;</span><br><span class="line"><span class="comment">//实际上 返回的 是os里面装的函数 返回的是Son</span></span><br><span class="line">Father f = of();</span><br></pre></td></tr></table></figure>

<p>逆变 int：父类总是能被子类替换，允许<strong>父类参数委托</strong>赋值给<strong>子类参数委托</strong></p>
<p>in 是修饰参数的。</p>
<p>in 修饰返回值类型，可以使得系统帮我们判断<strong>in 修饰的这个类型的委托</strong>的<strong>参数</strong>是否可以存储到子类委托当中。</p>
<p>如果不添加 in 修饰符，是不允许<strong>父类参数委托</strong>赋值给<strong>子类参数委托</strong>的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里声明了一个Father委托变量if，参数类型为Father</span></span><br><span class="line">TestIn&lt;Father&gt; iF = (<span class="keyword">value</span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//然后声明了一个Son委托变量is，参数类型为Son</span></span><br><span class="line"><span class="comment">//由于是in逆变，允许父类委托赋值给子类委托</span></span><br><span class="line"><span class="comment">//因为里氏替换原则，父类可以装子类</span></span><br><span class="line">TestIn&lt;Son&gt; iS = iF;</span><br><span class="line">iS(<span class="keyword">new</span> Son());<span class="comment">//实际上 调用的是 iF</span></span><br></pre></td></tr></table></figure>

<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>协变 out</p>
<p>逆变 in</p>
<p>用来修饰 泛型替代符的 只能修饰接口和委托中的泛型</p>
<p>作用两点</p>
<ol>
<li>out 修饰的泛型类型 只能作为返回值类型 in 修饰的泛型类型 只能作为 参数类型</li>
<li>遵循里氏替换原则的 用 out 和 in 修饰的 泛型委托 可以相互装载（有父子关系的泛型）</li>
<li>协变 父类参数泛型委托装子类参数泛型委托 逆变 子类泛型返回值委托装父类泛型返回值委托</li>
</ol>
<h1 id="多线程-知识点"><a href="#多线程-知识点" class="headerlink" title="多线程 知识点"></a>多线程 知识点</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/36a65838fe46">C# 多线程的使用 - 简书 (jianshu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/142929863">多线程篇-线程安全-原子性、可见性、有序性解析 - 知乎 (zhihu.com)</a></p>
<h2 id="知识点一-了解线程前先了解进程"><a href="#知识点一-了解线程前先了解进程" class="headerlink" title="知识点一 了解线程前先了解进程"></a>知识点一 了解线程前先了解进程</h2><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动</p>
<p>系统进行资源分配和调度的基本单位，是操作系统结构的基础</p>
<p>说人话：打开一个应用程序就是在操作系统上开启了一个进程</p>
<p>进程之间可以相互独立运行，互不干扰</p>
<p>进程之间也可以相互访问、操作</p>
<h2 id="知识点二-什么是线程"><a href="#知识点二-什么是线程" class="headerlink" title="知识点二 什么是线程"></a>知识点二 什么是线程</h2><p>操作系统能够进行运算调度的最小单位。</p>
<p>它被包含在进程之中，是进程中的实际运作单位</p>
<p>一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程</p>
<p>我们目前写的程序 都在主线程中</p>
<p>简单理解线程：就是代码从上到下运行的一条“管道”</p>
<h2 id="知识点三-什么是多线程"><a href="#知识点三-什么是多线程" class="headerlink" title="知识点三 什么是多线程"></a>知识点三 什么是多线程</h2><p>我们可以通过代码 开启新的线程</p>
<p>可以同时运行代码的多条“管道” 就叫多线程</p>
<h2 id="知识点四-语法相关"><a href="#知识点四-语法相关" class="headerlink" title="知识点四 语法相关"></a>知识点四 语法相关</h2><p>线程类 Thread</p>
<p>需要引用命名空间 using System.Threading;</p>
<h3 id="1-声明一个新的线程"><a href="#1-声明一个新的线程" class="headerlink" title="1.声明一个新的线程"></a>1.声明一个新的线程</h3><p>注意：线程执行的代码 需要封装到一个函数中</p>
<p>新线程 将要执行的代码逻辑 被封装到了一个函数语句块中</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(NewThreadLogic);	<span class="comment">//这里的参数是一个函数</span></span><br></pre></td></tr></table></figure>

<h3 id="2-启动线程"><a href="#2-启动线程" class="headerlink" title="2.启动线程"></a>2.启动线程</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Start();</span><br></pre></td></tr></table></figure>

<h3 id="3-设置为后台线程"><a href="#3-设置为后台线程" class="headerlink" title="3.设置为后台线程"></a>3.设置为后台线程</h3><p>当前台线程都结束了的时候,整个程序也就结束了,即使还有后台线程正在运行</p>
<p>后台线程不会防止应用程序的进程被终止掉</p>
<p>如果不设置为后台线程 可能导致进程无法正常关闭</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.IsBackground = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-关闭释放一个线程"><a href="#4-关闭释放一个线程" class="headerlink" title="4.关闭释放一个线程"></a>4.关闭释放一个线程</h3><p>如果开启的线程中不是死循环 是能够结束的逻辑 那么 不用刻意的去关闭它</p>
<p>如果是死循环 想要中止这个线程 有两种方式</p>
<h4 id="4-1-死循环中-bool-标识"><a href="#4-1-死循环中-bool-标识" class="headerlink" title="4.1-死循环中 bool 标识"></a>4.1-死循环中 bool 标识</h4><p>定义一个全局标记（isRuning），在主线程控制线程运行。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadLogic</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//新开线程 执行的代码逻辑 在该函数语句块中</span></span><br><span class="line">    <span class="keyword">while</span>(isRuning)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Thread.Sleep(1000);</span></span><br><span class="line">        <span class="comment">//Console.WriteLine(&quot;新开线程代码逻辑&quot;);</span></span><br><span class="line">        <span class="keyword">lock</span>(obj)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.SetCursorPosition(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">            Console.ForegroundColor = ConsoleColor.Yellow;</span><br><span class="line">            Console.Write(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-通过线程提供的方法"><a href="#4-2-通过线程提供的方法" class="headerlink" title="4.2-通过线程提供的方法"></a>4.2-通过线程提供的方法</h4><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.thread.abort?view=net-7.0#system-threading-thread-abort">Thread.Abort 方法 (System.Threading) | Microsoft Learn</a></p>
<p>注意：在.Net core 版本中无法中止 会报错</p>
<blockquote>
<p>此方法已过时。 在 .NET 5 及更高版本上，调用此方法会生成编译时警告。 此方法在 .NET 5 及更高版本和 .NET Core 的运行时引发 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.platformnotsupportedexception?view=net-7.0">PlatformNotSupportedException</a> 。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终止线程</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    t.Abort();</span><br><span class="line">    t = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-线程休眠"><a href="#5-线程休眠" class="headerlink" title="5.线程休眠"></a>5.线程休眠</h3><p>让线程休眠多少毫秒 1s &#x3D; 1000 毫秒</p>
<p>在哪个线程里执行 就休眠哪个线程</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.Sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="知识点五-线程之间共享数据"><a href="#知识点五-线程之间共享数据" class="headerlink" title="知识点五 线程之间共享数据"></a>知识点五 线程之间共享数据</h2><p>多个线程使用的内存是共享的，都属于该应用程序(进程)</p>
<p>所以要注意 当多线程 同时操作同一片内存区域时可能会出问题</p>
<p>可以通过加锁的形式避免问题</p>
<p>lock：对于对象，加互斥锁。</p>
<p>当我们在多个线程当中想要访问同样的东西 进行逻辑处理时</p>
<p>为了避免不必要的逻辑顺序执行的差错</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span>(引用类型对象)</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span>(obj)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.SetCursorPosition(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        Console.ForegroundColor = ConsoleColor.Red;</span><br><span class="line">        Console.Write(<span class="string">&quot;●&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点六-多线程对于我们的意义"><a href="#知识点六-多线程对于我们的意义" class="headerlink" title="知识点六 多线程对于我们的意义"></a>知识点六 多线程对于我们的意义</h2><p>可以用多线程专门处理一些复杂耗时的逻辑</p>
<p>比如 寻路、网络通信等等</p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>多线程是多个可以同时执行代码逻辑的“管道”</p>
<p>可以通过代码开启多线程，用多线程处理一些复杂的可能影响主线程流畅度的逻辑</p>
<p>关键字 Thread</p>
<h1 id="预处理器指令-知识点"><a href="#预处理器指令-知识点" class="headerlink" title="预处理器指令 知识点"></a>预处理器指令 知识点</h1><h2 id="知识点一-什么是编译器"><a href="#知识点一-什么是编译器" class="headerlink" title="知识点一 什么是编译器"></a>知识点一 什么是编译器</h2><p>编译器是一种翻译程序</p>
<p>它用于将源语言程序翻译为目标语言程序</p>
<p>源语言程序：某种程序设计语言写成的,比如 C#、C、C++、Java 等语言写的程序</p>
<p>目标语言程序:二进制数表示的伪机器代码写的程序</p>
<h2 id="知识点二-什么是预处理器指令"><a href="#知识点二-什么是预处理器指令" class="headerlink" title="知识点二 什么是预处理器指令"></a>知识点二 什么是预处理器指令</h2><p>预处理器指令 指导编译器 在实际编译开始之前对信息进行预处理</p>
<p>预处理器指令 都是以#开始</p>
<p>预处理器指令不是语句，所以它们不以分号;结束</p>
<p>目前我们经常用到的 折叠代码块 就是预处理器指令</p>
<h2 id="知识点三-常见的预处理器指令"><a href="#知识点三-常见的预处理器指令" class="headerlink" title="知识点三 常见的预处理器指令"></a>知识点三 常见的预处理器指令</h2><h3 id="define，-undef"><a href="#define，-undef" class="headerlink" title="#define，#undef"></a>#define，#undef</h3><p>#define 定义一个符号，类似一个没有值的变量</p>
<p>#undef 取消 define 定义的符号，让其失效</p>
<p>两者都是写在<strong>脚本文件最前面</strong></p>
<p>一般配合 if 指令使用 或配合特性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个符号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Unity4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Unity5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Unity2017</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Unity2019</span></span><br><span class="line"><span class="comment">//取消定义一个符号</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> Unity4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Android</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PC</span></span><br></pre></td></tr></table></figure>

<h3 id="if，-elif，-else，-endif"><a href="#if，-elif，-else，-endif" class="headerlink" title="#if，#elif，#else，#endif"></a>#if，#elif，#else，#endif</h3><p>和 if 语句规则一样，一般配合#define 定义的符号使用</p>
<p>用于告诉编译器进行编译代码的流程控制</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">//如果发现有Unity4这个符号 那么其中包含的代码 就会被编译器翻译</span></span><br><span class="line">            <span class="comment">//可以通过 逻辑或 和 逻辑与 进行多种符号的组合判断</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> Unity4</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;版本为Unity4&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> Unity2017 &amp;&amp; IOS</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;版本为Unity2017&quot;</span>);</span><br><span class="line">            <span class="comment">//#warning 这个版本 不合法</span></span><br><span class="line">            <span class="comment">//#error 这个版本不准执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;其它版本&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="warning，-error"><a href="#warning，-error" class="headerlink" title="#warning，#error"></a>#warning，#error</h3><p>告诉编译器，是报警告还是报错误，一般还是配合 if 使用</p>
<h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><p>预处理器指令</p>
<p>可以让代码还没有编译之前就可以进行一些预处理判断</p>
<p>在 Unity 中会用来进行一些平台或者版本的判断</p>
<p>决定不同的版本或者不同的平台使用不同的代码逻辑</p>
<h1 id="反射概念和关键类-Type-知识点"><a href="#反射概念和关键类-Type-知识点" class="headerlink" title="反射概念和关键类 Type 知识点"></a>反射概念和关键类 Type 知识点</h1><p>反射是 Unity 工作的基本原理之一</p>
<h2 id="知识点一-什么是程序集"><a href="#知识点一-什么是程序集" class="headerlink" title="知识点一 什么是程序集"></a>知识点一 什么是程序集</h2><p>程序集是经由编译器编译得到的，供进一步编译执行的那个中间产物</p>
<p>在 WINDOWS 系统中，它一般表现为后缀为·dll（库文件）或者是·exe（可执行文件）的格式</p>
<p>说人话：</p>
<p>程序集就是我们写的一个代码集合，我们现在写的所有代码</p>
<p>最终都会被编译器翻译为一个程序集供别人使用</p>
<p>比如一个代码库文件（dll）或者一个可执行文件(exe)</p>
<h2 id="知识点二-元数据"><a href="#知识点二-元数据" class="headerlink" title="知识点二 元数据"></a>知识点二 元数据</h2><p>元数据就是用来描述数据的数据</p>
<p>这个概念不仅仅用于程序上，在别的领域也有元数据</p>
<p>说人话：</p>
<p>程序中的<strong>类，类中的函数、变量</strong>等等信息就是 程序的 元数据</p>
<p>有关程序以及类型的数据被称为 元数据，它们保存在程序集中</p>
<h2 id="知识点三-反射的概念"><a href="#知识点三-反射的概念" class="headerlink" title="知识点三 反射的概念"></a>知识点三 反射的概念</h2><p>程序正在运行时，可以查看其它程序集或者自身的元数据。</p>
<p>一个运行的程序查看本身或者其它程序的元数据的行为就叫做反射</p>
<p>说人话：</p>
<p>在程序运行时，通过反射可以得到其它程序集或者自己程序集代码的各种信息</p>
<p>类，函数，变量，对象等等，实例化它们，执行它们，操作它们</p>
<h2 id="知识点四-反射的作用"><a href="#知识点四-反射的作用" class="headerlink" title="知识点四 反射的作用"></a>知识点四 反射的作用</h2><p>因为反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性</p>
<ol>
<li>程序运行时得到所有元数据，包括元数据的特性</li>
<li>程序运行时，实例化对象，操作对象</li>
<li>程序运行时创建新对象，用这些对象执行任务</li>
</ol>
<h2 id="知识点五-语法相关"><a href="#知识点五-语法相关" class="headerlink" title="知识点五 语法相关"></a>知识点五 语法相关</h2><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type(类的信息类)</span><br></pre></td></tr></table></figure>

<p>它是反射功能的基础！</p>
<p>它是访问元数据的主要方式。</p>
<p>使用 Type 的成员获取有关类型声明的信息</p>
<p>有关类型的成员（如构造函数、方法、字段、属性和类的事件）</p>
<h3 id="获取-Type"><a href="#获取-Type" class="headerlink" title="获取 Type"></a>获取 Type</h3><p>注意：对于同一个类型，获取的 Type（类型）<strong>是唯一</strong>的！</p>
<p>也就是说，无论你通过什么方式获取 Type，获取到的 Type 变量都是同一个。</p>
<p>1.物之父 object 中的 **GetType()**可以获取对象的 Type</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">42</span>;</span><br><span class="line">Type type = a.GetType();</span><br><span class="line">Console.WriteLine(type);</span><br></pre></td></tr></table></figure>

<p>2.通过<strong>typeof(关键字)</strong> 传入类名 也可以得到对象的 Type</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type type2 = <span class="keyword">typeof</span>(<span class="built_in">int</span>);</span><br><span class="line">Console.WriteLine(type2);</span><br></pre></td></tr></table></figure>

<p>3.通过类的名字 也可以获取类型</p>
<p>注意：类名必须包含命名空间 不然找不到</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type type3 = Type.GetType(<span class="string">&quot;System.Int32&quot;</span>);</span><br><span class="line">Console.WriteLine(type3);</span><br></pre></td></tr></table></figure>

<h3 id="获取程序集"><a href="#获取程序集" class="headerlink" title="获取程序集"></a>获取程序集</h3><p>type.Assembly</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以通过Type可以得到类型所在程序集信息</span></span><br><span class="line">Console.WriteLine(type.Assembly);</span><br><span class="line">Console.WriteLine(type2.Assembly);</span><br><span class="line">Console.WriteLine(type3.Assembly);</span><br></pre></td></tr></table></figure>

<h3 id="获取类中的所有公共成员"><a href="#获取类中的所有公共成员" class="headerlink" title="获取类中的所有公共成员"></a>获取类中的所有公共成员</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取类中的所有公共成员</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MemberInfo[] <span class="title">GetMembers</span>()</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MemberInfo[] infos = t.GetMembers();</span><br></pre></td></tr></table></figure>

<p>需要引用命名空间 using System.Reflection;</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先得到Type</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line"><span class="comment">//然后得到所有公共成员</span></span><br><span class="line"><span class="comment">//需要引用命名空间 using System.Reflection;</span></span><br><span class="line">MemberInfo[] infos = t.GetMembers();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; infos.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(infos[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取类的公共构造函数并调用"><a href="#获取类的公共构造函数并调用" class="headerlink" title="获取类的公共构造函数并调用"></a>获取类的公共构造函数并调用</h3><p>1.获取所有构造函数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo[] ctors = t.GetConstructors();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ctors.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(ctors[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.获取其中一个构造函数 并执行</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取构造函数，types表示参数</span></span><br><span class="line"><span class="keyword">public</span> ConstructorInfo? GetConstructor(Type[] types);</span><br></pre></td></tr></table></figure>

<p>2-1 得到无参构造</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得构造函数传入 Type数组 数组中内容按顺序是参数类型</span></span><br><span class="line"><span class="comment">//执行构造函数传入  object数组 表示按顺序传入的参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Invoke</span>(<span class="params"><span class="built_in">object</span>?[]? parameters</span>)</span>;	<span class="comment">//这是ConstructorInfo类的一个成员</span></span><br><span class="line"><span class="comment">//  2-1得到无参构造</span></span><br><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//执行无参构造 无参构造 没有参数 传null</span></span><br><span class="line">Test obj = info.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> Test;</span><br><span class="line">Console.WriteLine(obj.j);</span><br></pre></td></tr></table></figure>

<p>注意，此时调用的 Invoke，返回一个 Object，所以需要 as。</p>
<p>2-2 得到有参构造</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo info2 = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br><span class="line"><span class="comment">//注意：Invoke函数需要传入的是Object类型的参数</span></span><br><span class="line">obj = info2.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">2</span> &#125;) <span class="keyword">as</span> Test;</span><br><span class="line">Console.WriteLine(obj.str);</span><br><span class="line"></span><br><span class="line">ConstructorInfo info3 = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;);</span><br><span class="line"><span class="comment">//注意：Invoke函数需要传入的是Object类型的参数</span></span><br><span class="line">obj = info3.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">4</span>, <span class="string">&quot;444444&quot;</span> &#125;) <span class="keyword">as</span> Test;</span><br><span class="line">Console.WriteLine(obj.str);</span><br></pre></td></tr></table></figure>

<h3 id="获取类的公共成员变量"><a href="#获取类的公共成员变量" class="headerlink" title="获取类的公共成员变量"></a>获取类的公共成员变量</h3><p>1.得到所有成员变量</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo[] fieldInfos = t.GetFields();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; fieldInfos.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fieldInfos[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.得到指定名称的公共成员变量</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo infoJ = t.GetField(<span class="string">&quot;j&quot;</span>);</span><br><span class="line">Console.WriteLine(infoJ);</span><br></pre></td></tr></table></figure>

<p>3.通过反射获取和设置对象的值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">test.j = <span class="number">99</span>;</span><br><span class="line">test.str = <span class="string">&quot;2222&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>3-1 通过反射 获取对象的某个变量的值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(infoJ.GetValue(test));</span><br></pre></td></tr></table></figure>

<p>3-2 通过反射 设置指定对象的某个变量的值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">infoJ.SetValue(test, <span class="number">100</span>);</span><br><span class="line">Console.WriteLine(infoJ.GetValue(test));</span><br></pre></td></tr></table></figure>

<h3 id="获取类的公共成员方法"><a href="#获取类的公共成员方法" class="headerlink" title="获取类的公共成员方法"></a>获取类的公共成员方法</h3><p>通过 Type 类中的 GetMethod 方法 得到类中的方法</p>
<p>MethodInfo 是方法的反射信息</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type strType = <span class="keyword">typeof</span>(<span class="built_in">string</span>);</span><br><span class="line">MethodInfo[] methods = strType.GetMethods();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; methods.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(methods[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.如果存在方法重载 用 Type 数组表示参数类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MethodInfo subStr = strType.GetMethod(<span class="string">&quot;Substring&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br></pre></td></tr></table></figure>

<p>2.调用该方法</p>
<p>注意：如果是静态方法 Invoke 中的第一个参数传 null 即可</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="comment">//第一个参数 相当于 是哪个对象要执行这个成员方法</span></span><br><span class="line"><span class="built_in">object</span> result = subStr.Invoke(str, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">7</span>, <span class="number">5</span> &#125;);</span><br><span class="line">Console.WriteLine(result);</span><br><span class="line"></span><br><span class="line"><span class="built_in">object</span> flag = methodEquals.Invoke(<span class="literal">null</span>, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">    <span class="string">&quot;11&quot;</span>, <span class="string">&quot;11&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line">Console.WriteLine((<span class="built_in">bool</span>)flag);</span><br><span class="line"><span class="comment">//输出True</span></span><br></pre></td></tr></table></figure>

<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Type;</span></span><br><span class="line"><span class="comment">//得枚举</span></span><br><span class="line"><span class="comment">//GetEnumName</span></span><br><span class="line"><span class="comment">//GetEnumNames</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得事件</span></span><br><span class="line"><span class="comment">//GetEvent</span></span><br><span class="line"><span class="comment">//GetEvents</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得接口</span></span><br><span class="line"><span class="comment">//GetInterface</span></span><br><span class="line"><span class="comment">//GetInterfaces</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得属性</span></span><br><span class="line"><span class="comment">//GetProperty</span></span><br><span class="line"><span class="comment">//GetPropertys</span></span><br><span class="line"><span class="comment">//等等</span></span><br></pre></td></tr></table></figure>

<h1 id="关键类-Assembly-和-Activator-知识点"><a href="#关键类-Assembly-和-Activator-知识点" class="headerlink" title="关键类 Assembly 和 Activator 知识点"></a>关键类 Assembly 和 Activator 知识点</h1><h2 id="Activator"><a href="#Activator" class="headerlink" title="Activator"></a>Activator</h2><p>用于快速实例化对象的类</p>
<p>用于将 Type 对象快捷实例化为对象</p>
<p>先得到 Type</p>
<p>然后 快速实例化一个对象</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.无参构造</span></span><br><span class="line">Test testObj = Activator.CreateInstance(testType) <span class="keyword">as</span> Test;</span><br><span class="line">Console.WriteLine(testObj.str);</span><br><span class="line"><span class="comment">//2.有参数构造</span></span><br><span class="line">testObj = Activator.CreateInstance(testType, <span class="number">99</span>) <span class="keyword">as</span> Test;</span><br><span class="line">Console.WriteLine(testObj.j);</span><br><span class="line"></span><br><span class="line">testObj = Activator.CreateInstance(testType, <span class="number">55</span>, <span class="string">&quot;111222&quot;</span>) <span class="keyword">as</span> Test;</span><br><span class="line">Console.WriteLine(testObj.j);</span><br></pre></td></tr></table></figure>

<p>主要是通过 CreateInstance 方法，快捷创建一个对象的实例。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span>? CreateInstance(Type type, <span class="keyword">params</span> <span class="built_in">object</span>?[]? <span class="keyword">args</span>);</span><br><span class="line"><span class="comment">//注意，我们必须在使用时使得构造函数的参数匹配，不然会报错</span></span><br></pre></td></tr></table></figure>

<h2 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h2><p>程序集类</p>
<p>主要用来加载其它程序集，加载后，才能用 Type 来使用其它程序集中的信息。</p>
<p>如果想要使用不是自己程序集中的内容 需要先加载程序集，比如 dll 文件(库文件)。</p>
<p>dll：简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类</p>
<h3 id="三种加载程序集的函数"><a href="#三种加载程序集的函数" class="headerlink" title="三种加载程序集的函数"></a>三种加载程序集的函数</h3><p>一般用来加载在同一文件下的其它程序集</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assembly asembly2 = Assembly.Load(<span class="string">&quot;程序集名称&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>一般用来加载不在同一文件下的其它程序集</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assembly asembly = Assembly.LoadFrom(<span class="string">&quot;包含程序集清单的文件的名称或路径&quot;</span>);</span><br><span class="line">Assembly asembly3 = Assembly.LoadFile(<span class="string">&quot;要加载的文件的完全限定路径&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><p>1.先加载一个指定程序集</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Assembly asembly = Assembly.LoadFrom(<span class="string">@&quot;C:\Users\MECHREVO\Desktop\CSharp进阶教学\Lesson18_练习题\bin\Debug\netcoreapp3.1\Lesson18_练习题&quot;</span>);</span><br><span class="line">Type[] types = asembly.GetTypes();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; types.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(types[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在加载程序集中的一个类对象 之后才能使用反射</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type icon = asembly.GetType(<span class="string">&quot;Lesson18_练习题.Icon&quot;</span>);</span><br><span class="line">MemberInfo[] members = icon.GetMembers();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; members.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(members[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反射 实例化一个 icon 对象</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type moveDir = asembly.GetType(<span class="string">&quot;Lesson18_练习题.E_MoveDir&quot;</span>);</span><br><span class="line">FieldInfo right = moveDir.GetField(<span class="string">&quot;Right&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>直接实例化对象</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> iconObj = Activator.CreateInstance(icon, <span class="number">10</span>, <span class="number">5</span>, right.GetValue(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure>

<p>得到对象中的方法 通过反射</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MethodInfo move = icon.GetMethod(<span class="string">&quot;Move&quot;</span>);</span><br><span class="line">MethodInfo draw = icon.GetMethod(<span class="string">&quot;Draw&quot;</span>);</span><br><span class="line">MethodInfo clear = icon.GetMethod(<span class="string">&quot;Clear&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="类库工程创建"><a href="#类库工程创建" class="headerlink" title="类库工程创建"></a>类库工程创建</h2><p>我们可以自己创建类库，编译后，将生成 dll 文件。</p>
<p>我们可以直接引用 dll 文件，或者通过反射获取。</p>
<h1 id="特性-知识点"><a href="#特性-知识点" class="headerlink" title="特性 知识点"></a>特性 知识点</h1><h2 id="知识点一-特性是什么"><a href="#知识点一-特性是什么" class="headerlink" title="知识点一 特性是什么"></a>知识点一 特性是什么</h2><p>特性是一种允许我们向程序的程序集添加元数据的语言结构</p>
<p>它是用于保存程序结构信息的某种特殊类型的类</p>
<p>特性提供功能强大的方法以将声明信息与 C# 代码（类型、方法、属性等）相关联。</p>
<p>特性与程序实体关联后，即可在运行时使用反射查询特性信息</p>
<p>特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中</p>
<p>它可以放置在几乎所有的声明中（类、变量、函数等等申明）</p>
<p>说人话：特性本质是个类，我们可以利用特性类为元数据添加额外信息</p>
<p>比如一个类、成员变量、成员方法等等为他们添加更多的额外信息</p>
<p>之后可以通过反射来获取这些额外信息</p>
<h2 id="知识点二-自定义特性"><a href="#知识点二-自定义特性" class="headerlink" title="知识点二 自定义特性"></a>知识点二 自定义特性</h2><p>特性实质就是一个类，所以，只需要再声明类时继承 Attribute 基类，那么这个类就是一个特性。</p>
<p>特性命名规范：特性名 Attribute</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, AllowMultiple = true, Inherited = false)</span>]</span><br><span class="line"><span class="comment">//注意，类名中的Attribute在使用时可以省略,但是typeof时不能省略</span></span><br><span class="line"><span class="comment">//继承特性基类 Attribute</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyCustomAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//特性中的成员 一般根据需求来写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCustomAttribute</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;特性的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-特性的使用"><a href="#知识点三-特性的使用" class="headerlink" title="知识点三 特性的使用"></a>知识点三 特性的使用</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[特性名(参数列表)]</span></span><br><span class="line"><span class="comment">//本质上 就是在调用特性类的构造函数</span></span><br></pre></td></tr></table></figure>

<p>写在哪里？</p>
<p>类、函数、变量上一行，表示他们具有该特性信息</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MyCustom(<span class="string">&quot;这个是我自己写的一个用于计算的类&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">MyCustom(<span class="string">&quot;这个是我自己写的一个用于计算的类&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MyCustom(<span class="string">&quot;这是一个成员变量&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[MyCustom(&quot;这是一个用于计算加法的函数&quot;)]</span></span><br><span class="line">    <span class="comment">//public void TestFun( [MyCustom(&quot;函数参数&quot;)]int a )</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断是否使用了某个特性"><a href="#判断是否使用了某个特性" class="headerlink" title="判断是否使用了某个特性"></a>判断是否使用了某个特性</h3><p>参数一：特性的类型</p>
<p>参数二：代表是否搜索继承链（属性和事件忽略此参数）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( t.IsDefined(<span class="keyword">typeof</span>(MyCustomAttribute), <span class="literal">false</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;该类型应用了MyCustom特性&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取-Type-元数据中的所有特性"><a href="#获取-Type-元数据中的所有特性" class="headerlink" title="获取 Type 元数据中的所有特性"></a>获取 Type 元数据中的所有特性</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span>[] array = t.GetCustomAttributes(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( array[i] <span class="keyword">is</span> MyCustomAttribute )</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine((array[i] <span class="keyword">as</span> MyCustomAttribute).info);</span><br><span class="line">        (array[i] <span class="keyword">as</span> MyCustomAttribute).TestFun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点四-限制自定义特性的使用范围"><a href="#知识点四-限制自定义特性的使用范围" class="headerlink" title="知识点四 限制自定义特性的使用范围"></a>知识点四 限制自定义特性的使用范围</h2><p>通过为特性类 加特性 限制其使用范围</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)</span>]</span><br></pre></td></tr></table></figure>

<p>参数一：AttributeTargets —— 特性能够用在哪些地方</p>
<p>参数二：AllowMultiple —— 是否允许多个特性实例用在同一个目标上</p>
<p>参数三：Inherited —— 特性是否能被派生类和重写成员继承</p>
<h2 id="知识点五-系统自带特性——过时特性"><a href="#知识点五-系统自带特性——过时特性" class="headerlink" title="知识点五 系统自带特性——过时特性"></a>知识点五 系统自带特性——过时特性</h2><p>过时特性：Obsolete</p>
<p>用于提示用户 使用的方法等成员已经过时 建议使用新方法</p>
<p>一般加在函数前的特性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObsoleteAttribute</span>(<span class="params"><span class="built_in">string</span>? message, <span class="built_in">bool</span> error</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数一：调用过时方法时 提示的内容</span></span><br><span class="line"><span class="comment">//参数二：true-使用该方法时会报错  false-使用该方法时直接警告</span></span><br><span class="line">[<span class="meta">Obsolete(<span class="string">&quot;OldSpeak方法已经过时了，请使用Speak方法&quot;</span>, false)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OldSpeak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点六-系统自带特性——调用者信息特性"><a href="#知识点六-系统自带特性——调用者信息特性" class="headerlink" title="知识点六 系统自带特性——调用者信息特性"></a>知识点六 系统自带特性——调用者信息特性</h2><p>需要引用命名空间 using System.Runtime.CompilerServices;</p>
<p>哪个文件调用？</p>
<p>CallerFilePath 特性</p>
<p>哪一行调用？</p>
<p>CallerLineNumber 特性</p>
<p>哪个函数调用？</p>
<p>CallerMemberName 特性</p>
<p>一般作为函数参数的特性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeakCaller</span>(<span class="params"><span class="built_in">string</span> str, [CallerFilePath]<span class="built_in">string</span> fileName = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        [CallerLineNumber]<span class="built_in">int</span> line = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        [CallerMemberName]<span class="built_in">string</span> target = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//可以直接打印这些信息</span></span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">    Console.WriteLine(fileName);</span><br><span class="line">    Console.WriteLine(line);</span><br><span class="line">    Console.WriteLine(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点七-系统自带特性——条件编译特性"><a href="#知识点七-系统自带特性——条件编译特性" class="headerlink" title="知识点七 系统自带特性——条件编译特性"></a>知识点七 系统自带特性——条件编译特性</h2><p>条件编译特性：Conditional</p>
<p>它会和预处理指令 #define 配合使用</p>
<p>需要引用命名空间 using System.Diagnostics;</p>
<p>主要可以用在一些调试代码上</p>
<p>有时想执行有时不想执行的代码</p>
<p><strong>只有 define 了 conditionString，被特性修饰的东西才能执行</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConditionalAttribute</span>(<span class="params"><span class="built_in">string</span> conditionString</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="知识点八-系统自带特性——外部-Dll-包函数特性"><a href="#知识点八-系统自带特性——外部-Dll-包函数特性" class="headerlink" title="知识点八 系统自带特性——外部 Dll 包函数特性"></a>知识点八 系统自带特性——外部 Dll 包函数特性</h2><p>DllImport</p>
<p>用来标记非.Net(C#)的函数，表明该函数在一个外部的 DLL 中定义。</p>
<p>一般用来调用 C 或者 C++的 Dll 包写好的方法</p>
<p>需要引用命名空间 using System.Runtime.InteropServices</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DllImportAttribute</span>(<span class="params"><span class="built_in">string</span> dllName</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p>特性是用于 为元数据再添加更多的额外信息（变量、方法等等）</p>
<p>我们可以通过反射获取这些额外的数据 来进行一些特殊的处理</p>
<p>自定义特性——继承<strong>Attribute</strong>类</p>
<p>系统自带特性：过时特性等</p>
<p>为什么要学习特性</p>
<p>Unity 引擎中很多地方都用到了特性来进行一些特殊处理</p>
<h1 id="迭代器-知识点"><a href="#迭代器-知识点" class="headerlink" title="迭代器 知识点"></a>迭代器 知识点</h1><p>迭代器一定是可迭代对象。迭代器要求实现 movenext 方法。可迭代对象要求实现 getIEnumerator 方法，getIEnumerator 方法返回的是该对象的迭代器。迭代器不负责维护可迭代对象的数据信息，只负责维护读取数据的位置。所以就是工厂和螺丝钉的关系</p>
<h2 id="知识点一-迭代器是什么"><a href="#知识点一-迭代器是什么" class="headerlink" title="知识点一 迭代器是什么"></a>知识点一 迭代器是什么</h2><p>迭代器（iterator）有时又称光标（cursor）</p>
<p>是程序设计的软件设计模式</p>
<p>迭代器模式提供一个方法顺序访问一个聚合对象中的各个元素</p>
<p>而又不暴露其内部的标识</p>
<p>在表现效果上看</p>
<p>是可以在容器对象（例如链表或数组）上遍历访问的接口</p>
<p>设计人员无需关心容器对象的内存分配的实现细节</p>
<p>可以用 foreach 遍历的类，都是实现了迭代器的</p>
<h2 id="知识点二-标准迭代器的实现方法"><a href="#知识点二-标准迭代器的实现方法" class="headerlink" title="知识点二 标准迭代器的实现方法"></a>知识点二 标准迭代器的实现方法</h2><p>关键接口：IEnumerator,IEnumerable</p>
<p>命名空间：using System.Collections;</p>
<p>可以通过同时继承 IEnumerable 和 IEnumerator 实现其中的方法</p>
<h3 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h3><p>IEnumerator 就是迭代器接口，拥有三个函数，用来实现遍历操作。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取当前元素</span></span><br><span class="line">    <span class="built_in">object</span>? Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="comment">//检测下一个元素是否存在，如果不存在则不可继续遍历</span></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>()</span>;</span><br><span class="line">    <span class="comment">//重置下标</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IEnumerable"><a href="#IEnumerable" class="headerlink" title="IEnumerable"></a>IEnumerable</h3><p>IEnumerable 的作用是获取 IEnumerator，并重置下标。</p>
<p>一般 Reset 函数在 GetEnumerator()中调用。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span> &#123;</span><br><span class="line">    <span class="comment">//获取迭代器，并且重置迭代器</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="foreach-本质"><a href="#foreach-本质" class="headerlink" title="foreach 本质"></a>foreach 本质</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list) &#123; &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先获取 in 后面这个对象的 IEnumerator，会调用对象其中的 GetEnumerator 方法 来获取</li>
<li>执行得到这个 IEnumerator 对象中的 MoveNext 方法</li>
<li>只要 MoveNext 方法的返回值时 true 就会去得到 Current，然后复制给 item</li>
</ol>
<h3 id="标准迭代器的实现方法"><a href="#标准迭代器的实现方法" class="headerlink" title="标准迭代器的实现方法"></a>标准迭代器的实现方法</h3><p>标准迭代器的实现方法，其实就是实现 IEnumerator，IEnumerable 这两个接口。</p>
<p>注意：下标最开始应该是-1，因为开始遍历时，就会调用一次 MoveNext();</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span> : <span class="title">IEnumerable</span>, <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] list;</span><br><span class="line">    <span class="comment">//从-1开始的光标 用于表示 数据得到了哪个位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> position = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> IEnumerable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Reset();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list[position];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//移动光标</span></span><br><span class="line">        ++position;</span><br><span class="line">        <span class="comment">//是否溢出 溢出就不合法</span></span><br><span class="line">        <span class="keyword">return</span> position &lt; list.Length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reset是重置光标位置 一般写在获取 IEnumerator对象这个函数中</span></span><br><span class="line">    <span class="comment">//用于第一次重置光标位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        position = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-用-yield-return-语法糖实现迭代器"><a href="#知识点三-用-yield-return-语法糖实现迭代器" class="headerlink" title="知识点三 用 yield return 语法糖实现迭代器"></a>知识点三 用 yield return 语法糖实现迭代器</h2><h3 id="yield-return"><a href="#yield-return" class="headerlink" title="yield return"></a>yield return</h3><p>yield return 是 C#提供给我们的语法糖</p>
<p>所谓语法糖，也称糖衣语法</p>
<p>主要作用就是将复杂逻辑简单化，可以增加程序的可读性</p>
<p>从而减少程序代码出错的机会</p>
<p>在执行</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> item;</span><br></pre></td></tr></table></figure>

<p>之后，程序会返回之前调用的函数，当需要再次获取 item 时，又会回到 yield return 然后返回下一个元素。</p>
<h3 id="用-yield-return-语法糖实现迭代器"><a href="#用-yield-return-语法糖实现迭代器" class="headerlink" title="用 yield return 语法糖实现迭代器"></a>用 yield return 语法糖实现迭代器</h3><p>关键接口：IEnumerable</p>
<p>命名空间：using System.Collections;</p>
<p>让想要通过 foreach 遍历的自定义类<strong>只需要</strong>实现接口中的方法 GetEnumerator 即可</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList2</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//yield关键字 配合迭代器使用</span></span><br><span class="line">            <span class="comment">//可以理解为 暂时返回 保留当前的状态</span></span><br><span class="line">            <span class="comment">//一会还会在回来</span></span><br><span class="line">            <span class="comment">//C#的语法糖</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//yield return list[0];</span></span><br><span class="line">        <span class="comment">//yield return list[1];</span></span><br><span class="line">        <span class="comment">//yield return list[2];</span></span><br><span class="line">        <span class="comment">//yield return list[3];</span></span><br><span class="line">        <span class="comment">//yield return list[4];</span></span><br><span class="line">        <span class="comment">//yield return list[5];</span></span><br><span class="line">        <span class="comment">//yield return list[6];</span></span><br><span class="line">        <span class="comment">//yield return list[7];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点四-用-yield-return-语法糖为泛型类实现迭代器"><a href="#知识点四-用-yield-return-语法糖为泛型类实现迭代器" class="headerlink" title="知识点四 用 yield return 语法糖为泛型类实现迭代器"></a>知识点四 用 yield return 语法糖为泛型类实现迭代器</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span>&lt;<span class="title">T</span>&gt; : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>(<span class="params"><span class="keyword">params</span> T[] array</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><p>迭代器就是可以让我们在外部直接通过 foreach 遍历对象中元素而不需要了解其结构</p>
<p>主要的两种方式</p>
<ol>
<li>传统方式 继承两个接口 实现里面的方法</li>
<li>用语法糖 yield return 去返回内容 只需要继承一个接口即可</li>
</ol>
<h1 id="特殊语法-知识点"><a href="#特殊语法-知识点" class="headerlink" title="特殊语法 知识点"></a>特殊语法 知识点</h1><h2 id="知识点一-var-隐式类型"><a href="#知识点一-var-隐式类型" class="headerlink" title="知识点一 var 隐式类型"></a>知识点一 var 隐式类型</h2><blockquote>
<p>其实就是 Cpp 的 auto</p>
</blockquote>
<p>var 是一种特殊的变量类型</p>
<p>它可以用来表示任意类型的变量</p>
<p>注意：</p>
<ol>
<li>var 不能作为类的成员 只能用于临时变量声明时，也就是 一般写在函数语句块中</li>
<li>var 必须初始化（因为需要类型推导）</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="知识点二-设置对象初始值，大括号初始化法"><a href="#知识点二-设置对象初始值，大括号初始化法" class="headerlink" title="知识点二 设置对象初始值，大括号初始化法"></a>知识点二 设置对象初始值，大括号初始化法</h2><p>声明对象时，可以通过直接写大括号的形式初始化公共成员变量和属性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="number">100</span>) &#123; sex = <span class="literal">true</span>, Age = <span class="number">18</span>, Name = <span class="string">&quot;唐老狮&quot;</span> &#125;;</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="number">200</span>) &#123; Age = <span class="number">18</span> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-设置集合初始值"><a href="#知识点三-设置集合初始值" class="headerlink" title="知识点三 设置集合初始值"></a>知识点三 设置集合初始值</h2><p>声明集合对象时，也可以通过大括号 直接初始化内部属性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array2 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; listInt = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; listPerson = <span class="keyword">new</span> List&lt;Person&gt;() &#123;</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">200</span>),</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">100</span>)&#123;Age = <span class="number">10</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> Person(<span class="number">1</span>)&#123;sex = <span class="literal">true</span>, Name = <span class="string">&quot;唐老狮&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="string">&quot;123&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">2</span>, <span class="string">&quot;222&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="知识点四-匿名类型"><a href="#知识点四-匿名类型" class="headerlink" title="知识点四 匿名类型"></a>知识点四 匿名类型</h2><p>var 变量可以申明为自定义的匿名类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> &#123; age = <span class="number">10</span>, money = <span class="number">11</span>, name = <span class="string">&quot;小明&quot;</span> &#125;;</span><br><span class="line">Console.WriteLine(v.age);</span><br><span class="line">Console.WriteLine(v.name);</span><br></pre></td></tr></table></figure>

<h2 id="知识点五-可空类型"><a href="#知识点五-可空类型" class="headerlink" title="知识点五 可空类型"></a>知识点五 可空类型</h2><p>[C#中 ??、 ?、 ?: 、?.、?<a target="_blank" rel="noopener" href="https://www.cnblogs.com/youmingkuang/p/11459615.html"> ] 问号 - 幽冥狂_七 - 博客园 (cnblogs.com)</a></p>
<p>1.值类型是不能赋值为 空的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> c = <span class="literal">null</span>;	<span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>2.申明时 在值类型后面加? 可以赋值为空</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>3.判断是否为空</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( c.HasValue )</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(c);</span><br><span class="line">    Console.WriteLine(c.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.安全获取可空类型值</p>
<p>4-1.如果为空 默认返回值类型的默认值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="keyword">value</span>.GetValueOrDefault());</span><br></pre></td></tr></table></figure>

<p>4-2.也可以指定一个默认值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="keyword">value</span>.GetValueOrDefault(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<h3 id="，"><a href="#，" class="headerlink" title="?.，?[]"></a>?.，?[]</h3><p>先检测对象是否为空，再执行方法</p>
<p>相当于是一种语法糖 能够帮助我们自动去判断 o 是否为空</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果obj不为空，就执行ToString()</span></span><br><span class="line">obj?.ToString();</span><br><span class="line"><span class="comment">//如果obj不为空，就执行[]</span></span><br><span class="line">obj?[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<h2 id="知识点六-空合并操作符"><a href="#知识点六-空合并操作符" class="headerlink" title="知识点六 空合并操作符"></a>知识点六 空合并操作符</h2><p>空合并操作符 ??</p>
<p>语法：左边值 ?? 右边值</p>
<p>语义：如果左边值为 null 就返回右边值 否则返回左边值</p>
<p>只要是可以为 null 的类型都能用</p>
<p>是三目运算符的一种特殊缩略写法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? intV = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//int intI = intV == null ? 100 : intV.Value;</span></span><br><span class="line"><span class="built_in">int</span> intI = intV ?? <span class="number">100</span>;</span><br><span class="line">Console.WriteLine(intI);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="literal">null</span>;</span><br><span class="line">str = str ?? <span class="string">&quot;hahah&quot;</span>;</span><br><span class="line">Console.WriteLine(str);</span><br></pre></td></tr></table></figure>

<h2 id="知识点七-内插字符串"><a href="#知识点七-内插字符串" class="headerlink" title="知识点七 内插字符串"></a>知识点七 内插字符串</h2><p>关键符号：$</p>
<p>用$来构造字符串，让字符串中可以拼接变量</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;唐老狮&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;好好学习,<span class="subst">&#123;name&#125;</span>,年龄：<span class="subst">&#123;age&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="知识点八-单句逻辑简略写法"><a href="#知识点八-单句逻辑简略写法" class="headerlink" title="知识点八 单句逻辑简略写法"></a>知识点八 单句逻辑简略写法</h2><p>当循环或者 if 语句中只有 一句代码时 大括号可以省略</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;123123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">    Console.WriteLine(j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;123123&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="值和引用类型补充"><a href="#值和引用类型补充" class="headerlink" title="值和引用类型补充"></a>值和引用类型补充</h1><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><p>值类型<br>无符号:byte,ushort,uint,ulong<br>有符号:sbyte,short,int,long<br>浮点数:float,double,decimal<br>特殊:char,bool<br>枚举:enum<br>结构体 :struct</p>
<p>引用类型：string，数组，class，interface，委托</p>
<p>值类型和引用类型的本质区别：值的具体内容存在栈内存上；引用的具体内容存在堆内存上</p>
<h2 id="问题一-如何判断-值类型和引用类型"><a href="#问题一-如何判断-值类型和引用类型" class="headerlink" title="问题一 如何判断 值类型和引用类型"></a>问题一 如何判断 值类型和引用类型</h2><p>F12 进到类型的内部去查看</p>
<p>是 class 就是引用</p>
<p>是 struct 就是值</p>
<h2 id="问题二-语句块"><a href="#问题二-语句块" class="headerlink" title="问题二 语句块"></a>问题二 语句块</h2><p>语句块一共有以下几种：</p>
<p>命名空间<br>↓<br>类、接口、结构体<br>↓<br>函数、属性、索引器、运算符重载等（类、接口、结构体）<br>↓<br>条件分支、循环</p>
<p>上层语句块：类、结构体<br>中层语句块：函数<br>底层的语句块： 条件分支 循环等</p>
<p>我们的逻辑代码写在哪里？<br>函数、条件分支、循环 - 中底层语句块中</p>
<p>我们的变量可以申明在哪里？<br>上、中、底都能申明变量<br>上层语句块中：成员变量<br>中、底层语句块中：临时变量</p>
<h2 id="问题三-变量的生命周期"><a href="#问题三-变量的生命周期" class="headerlink" title="问题三 变量的生命周期"></a>问题三 变量的生命周期</h2><p>编程时大部分都是 临时变量，在中底层申明的临时变量（函数、条件分支、循环语句块等）</p>
<p>语句块执行结束，没有被记录的对象将被回收或变成垃圾</p>
<p>值类型：被系统自动回收</p>
<p>引用类型：栈上用于存地址的房间被系统自动回收，堆中具体内容变成垃圾，待下次 GC 回收</p>
<p>想要不被回收或者不变垃圾，则必须将其记录下来</p>
<p>如何记录？</p>
<p>在更高层级记录或者，使用静态全局变量记录</p>
<h2 id="问题四-结构体中的值和引用"><a href="#问题四-结构体中的值和引用" class="headerlink" title="问题四 结构体中的值和引用"></a>问题四 结构体中的值和引用</h2><p>结构体本身是值类型<br>前提：该结构体没有做为其它类的成员<br>在结构体中的值，栈中存储值具体的内容<br>在结构体中的引用，堆中存储引用具体的内容</p>
<p>引用类型始终存储在堆中，真正通过结构体使用其中引用类型时只是顺藤摸瓜</p>
<h2 id="问题五-类中的值和引用"><a href="#问题五-类中的值和引用" class="headerlink" title="问题五 类中的值和引用"></a>问题五 类中的值和引用</h2><p>类本身是引用类型<br>在类中的值，堆中存储具体的值（托管值类型）<br>在类中的引用，堆中存储具体的值</p>
<p>值类型跟着大哥走，引用类型一根筋</p>
<h2 id="问题六-数组中的存储规则"><a href="#问题六-数组中的存储规则" class="headerlink" title="问题六 数组中的存储规则"></a>问题六 数组中的存储规则</h2><p>数组本身是引用类型</p>
<p>值类型数组，堆中房间存具体内容</p>
<p>引用类型数组，堆中房间存地址</p>
<h2 id="问题七-结构体继承接口"><a href="#问题七-结构体继承接口" class="headerlink" title="问题七 结构体继承接口"></a>问题七 结构体继承接口</h2><p>利用里氏替换原则，用接口容器装载结构体存在装箱拆箱</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TestStruct obj1 = <span class="keyword">new</span> TestStruct();</span><br><span class="line">obj1.Value = <span class="number">1</span>;</span><br><span class="line">Console.WriteLine(obj1.Value);</span><br><span class="line">TestStruct obj2 = obj1;</span><br><span class="line">obj2.Value = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//由于是值类型，obj1.value不会改变</span></span><br><span class="line">Console.WriteLine(obj1.Value);</span><br><span class="line">Console.WriteLine(obj2.Value);</span><br><span class="line"></span><br><span class="line">ITest iObj1 = obj1;<span class="comment">//装箱  value 1</span></span><br><span class="line">ITest iObj2 = iObj1;</span><br><span class="line">iObj2.Value = <span class="number">99</span>;</span><br><span class="line"><span class="comment">//由于是引用类型，iobj1.value会变成99</span></span><br><span class="line">Console.WriteLine(iObj1.Value);</span><br><span class="line">Console.WriteLine(iObj2.Value);</span><br><span class="line"></span><br><span class="line">TestStruct obj3 = (TestStruct)iObj1;<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="知识点一-插入排序的基本原理"><a href="#知识点一-插入排序的基本原理" class="headerlink" title="知识点一 插入排序的基本原理"></a>知识点一 插入排序的基本原理</h2><p>8 7 1 5 4 2 6 3 9<br>两个区域<br>排序区<br>未排序区<br>用一个索引值做分水岭</p>
<p>未排序区元素<br>与排序区元素比较<br>插入到合适位置<br>直到未排序区清空</p>
<h2 id="知识点二-代码实现"><a href="#知识点二-代码实现" class="headerlink" title="知识点二 代码实现"></a>知识点二 代码实现</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现升序 把 大的 放在最后面</span></span><br><span class="line"><span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前提规则</span></span><br><span class="line"><span class="comment">//排序开始前</span></span><br><span class="line"><span class="comment">//首先认为第一个元素在排序区中</span></span><br><span class="line"><span class="comment">//其它所有元素在未排序区中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序开始后</span></span><br><span class="line"><span class="comment">//每次将未排序区第一个元素取出用于和</span></span><br><span class="line"><span class="comment">//排序区中元素比较(从后往前)</span></span><br><span class="line"><span class="comment">//满足条件（较大或者较小）</span></span><br><span class="line"><span class="comment">//则排序区中元素往后移动一个位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意</span></span><br><span class="line"><span class="comment">//所有数字都在一个数组中</span></span><br><span class="line"><span class="comment">//所谓的两个区域是一个分水岭索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步</span></span><br><span class="line"><span class="comment">//能取出未排序区的所有元素进行比较</span></span><br><span class="line"><span class="comment">//i=1的原因：默认第一个元素就在排序区</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; arr.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第二步</span></span><br><span class="line">    <span class="comment">//每一轮</span></span><br><span class="line">    <span class="comment">//1.取出排序区的最后一个元素索引</span></span><br><span class="line">    <span class="built_in">int</span> sortIndex = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//2.取出未排序区的第一个元素</span></span><br><span class="line">    <span class="built_in">int</span> noSortNum = arr[i];</span><br><span class="line">    <span class="comment">//第三步</span></span><br><span class="line">    <span class="comment">//在未排序区进行比较</span></span><br><span class="line">    <span class="comment">//移动位置</span></span><br><span class="line">    <span class="comment">//确定插入索引</span></span><br><span class="line">    <span class="comment">//循环停止的条件</span></span><br><span class="line">    <span class="comment">//1.发现排序区中所有元素都已经比较完</span></span><br><span class="line">    <span class="comment">//2.发现排序区中的元素不满足比较条件了</span></span><br><span class="line">    <span class="keyword">while</span> (sortIndex &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">           arr[sortIndex] &gt; noSortNum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//只要进了这个while循环 证明满足条件</span></span><br><span class="line">        <span class="comment">//排序区中的元素 就应该往后退一格</span></span><br><span class="line">        arr[sortIndex + <span class="number">1</span>] = arr[sortIndex];</span><br><span class="line">        <span class="comment">//移动到排序区的前一个位置 准备继续比较</span></span><br><span class="line">        --sortIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最终插入数字</span></span><br><span class="line">    <span class="comment">//循环中知识在确定位置 和找最终的插入位置</span></span><br><span class="line">    <span class="comment">//最终插入对应位置 应该循环结束后</span></span><br><span class="line">    arr[sortIndex + <span class="number">1</span>] = noSortNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; nums.Length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> sortedIndex = i - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> nowSortNum = nums[i];</span><br><span class="line">    <span class="keyword">while</span> (sortedIndex &gt;= <span class="number">0</span> &amp;&amp; nums[sortedIndex] &gt; nowSortNum)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[sortedIndex + <span class="number">1</span>] = nums[sortedIndex];</span><br><span class="line">        --sortedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[sortedIndex + <span class="number">1</span>] = nowSortNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> nums)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(item + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-总结"><a href="#知识点三-总结" class="headerlink" title="知识点三 总结"></a>知识点三 总结</h2><h3 id="为什么有两层循环？"><a href="#为什么有两层循环？" class="headerlink" title="为什么有两层循环？"></a>为什么有两层循环？</h3><p>第一层循环：一次取出未排序区的元素进行排序<br>第二层循环：找到想要插入的位置</p>
<h3 id="为什么第一层循环从-1-开始遍历？"><a href="#为什么第一层循环从-1-开始遍历？" class="headerlink" title="为什么第一层循环从 1 开始遍历？"></a>为什么第一层循环从 1 开始遍历？</h3><p>插入排序的关键是分两个区域，已排序区 和 未排序区，默认第一个元素在已排序区</p>
<h3 id="为什么使用-while-循环？"><a href="#为什么使用-while-循环？" class="headerlink" title="为什么使用 while 循环？"></a>为什么使用 while 循环？</h3><p>满足条件才比较<br>否则证明插入位置已确定<br>不需要继续循环</p>
<h3 id="为什么可以直接往后移位置"><a href="#为什么可以直接往后移位置" class="headerlink" title="为什么可以直接往后移位置"></a>为什么可以直接往后移位置</h3><p>每轮未排序数已记录</p>
<p>最后一个位置不怕丢</p>
<h3 id="为什么确定位置后-是放在-sortIndex-1-的位置"><a href="#为什么确定位置后-是放在-sortIndex-1-的位置" class="headerlink" title="为什么确定位置后,是放在 sortIndex + 1 的位置"></a>为什么确定位置后,是放在 sortIndex + 1 的位置</h3><p>当循环停止时，插入位置应该是停止循环的索引加 1 处</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>两个区域<br>用索引值来区分<br>未排序区与排序区<br>元素不停比较<br>找到合适位置<br>插入当前元素</p>
<h3 id="套路写法"><a href="#套路写法" class="headerlink" title="套路写法"></a>套路写法</h3><p>两层循环<br>一层获取未排序区元素<br>一层找到合适插入位置</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>默认（假设）开头已排序，其实一个元素，就是有序的。<br>第二层循环外插入</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="知识点一-希尔排序的基本原理"><a href="#知识点一-希尔排序的基本原理" class="headerlink" title="知识点一 希尔排序的基本原理"></a>知识点一 希尔排序的基本原理</h2><p>希尔排序是，插入排序的升级版，必须先掌握插入排序</p>
<p>希尔排序的原理：将整个待排序序列，分割成为若干子序列，分别进行插入排序</p>
<p>总而言之：</p>
<p>希尔排序对插入排序的升级主要就是加入了一个步长的概念，通过步长每次可以把原序列分为多个子序列；对子序列进行插入排序，在极限情况下可以有效降低普通插入排序的时间复杂度，提升算法效率。</p>
<h2 id="知识点二-代码实现-1"><a href="#知识点二-代码实现-1" class="headerlink" title="知识点二 代码实现"></a>知识点二 代码实现</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">//学习希尔排序的前提条件</span></span><br><span class="line"><span class="comment">//先掌握插入排序</span></span><br><span class="line"><span class="comment">//第一步：实现插入排序</span></span><br><span class="line"><span class="comment">//第一层循环 是用来取出未排序区中的元素的</span></span><br><span class="line"><span class="comment">//for (int i = 1; i &lt; arr.Length; i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    //得出未排序区的元素</span></span><br><span class="line"><span class="comment">//    int noSortNum = arr[i];</span></span><br><span class="line"><span class="comment">//    //得出排序区中最后一个元素索引</span></span><br><span class="line"><span class="comment">//    int sortIndex = i - 1;</span></span><br><span class="line"><span class="comment">//    //进入条件</span></span><br><span class="line"><span class="comment">//    //首先排序区中还有可以比较的 &gt;=0</span></span><br><span class="line"><span class="comment">//    //排序区中元素 满足交换条件 升序就是排序区中元素要大于未排序区中元素</span></span><br><span class="line"><span class="comment">//    while (sortIndex &gt;= 0 &amp;&amp;</span></span><br><span class="line"><span class="comment">//        arr[sortIndex] &gt; noSortNum)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        arr[sortIndex + 1] = arr[sortIndex];</span></span><br><span class="line"><span class="comment">//        --sortIndex;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    //找到位置过后 真正的插入 值</span></span><br><span class="line"><span class="comment">//    arr[sortIndex + 1] = noSortNum;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; arr.Length; i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    Console.WriteLine(arr[i]);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：确定步长</span></span><br><span class="line"><span class="comment">//基本规则：每次步长变化都是/2</span></span><br><span class="line"><span class="comment">//一开始步长 就是数组的长度/2</span></span><br><span class="line"><span class="comment">//之后每一次 都是在上一次的步长基础上/2</span></span><br><span class="line"><span class="comment">//结束条件是 步长 &lt;=0</span></span><br><span class="line"><span class="comment">//1.第一次的步长是数组长度/2  所以：int step = arr.length/2</span></span><br><span class="line"><span class="comment">//2.之后每一次步长变化都是/2  索引：step /= 2</span></span><br><span class="line"><span class="comment">//3.最小步长是1  所以：step &gt; 0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> step = arr.Length / <span class="number">2</span>; step &gt; <span class="number">0</span>; step/=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//每次得到步长后 会把该步长下所有序列都进行插入排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：执行插入排序</span></span><br><span class="line">    <span class="comment">//i=1代码 相当于 代表取出来的排序区的第一个元素</span></span><br><span class="line">    <span class="comment">//for (int i = 1; i &lt; arr.Length; i++)</span></span><br><span class="line">    <span class="comment">//i=step 相当于 代表取出来的排序区的第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = step; i &lt; arr.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//得出未排序区的元素</span></span><br><span class="line">        <span class="built_in">int</span> noSortNum = arr[i];</span><br><span class="line">        <span class="comment">//得出排序区中最后一个元素索引</span></span><br><span class="line">        <span class="comment">//int sortIndex = i - 1;</span></span><br><span class="line">        <span class="comment">//i-step 代表和子序列中 已排序区元素一一比较</span></span><br><span class="line">        <span class="built_in">int</span> sortIndex = i - step;</span><br><span class="line">        <span class="comment">//进入条件</span></span><br><span class="line">        <span class="comment">//首先排序区中还有可以比较的 &gt;=0</span></span><br><span class="line">        <span class="comment">//排序区中元素 满足交换条件 升序就是排序区中元素要大于未排序区中元素</span></span><br><span class="line">        <span class="keyword">while</span> (sortIndex &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">               arr[sortIndex] &gt; noSortNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//arr[sortIndex + 1] = arr[sortIndex];</span></span><br><span class="line">            <span class="comment">// 代表移步长个位置 代表子序列中的下一个位置</span></span><br><span class="line">            arr[sortIndex + step] = arr[sortIndex];</span><br><span class="line">            <span class="comment">//--sortIndex;</span></span><br><span class="line">            <span class="comment">//一个步长单位之间的比较</span></span><br><span class="line">            sortIndex -= step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到位置过后 真正的插入 值</span></span><br><span class="line">        <span class="comment">//arr[sortIndex + 1] = noSortNum;</span></span><br><span class="line">        <span class="comment">//现在是加步长个单位</span></span><br><span class="line">        arr[sortIndex + step] = noSortNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> step = nums.Length / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = step; i &lt; nums.Length; i += step)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sortedIndex = i - step;</span><br><span class="line">        <span class="built_in">int</span> nowSortNum = nums[i];</span><br><span class="line">        <span class="keyword">while</span> (sortedIndex &gt;= <span class="number">0</span> &amp;&amp; nowSortNum &gt; nums[sortedIndex])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[sortedIndex + step] = nums[sortedIndex];</span><br><span class="line">            sortedIndex -= step;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[sortedIndex + step] = nowSortNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-总结-1"><a href="#知识点三-总结-1" class="headerlink" title="知识点三 总结"></a>知识点三 总结</h2><h3 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h3><p>设置步长<br>步长不停缩小<br>到 1 排序后结束</p>
<h3 id="具体排序方式"><a href="#具体排序方式" class="headerlink" title="具体排序方式"></a>具体排序方式</h3><p>插入排序原理</p>
<h3 id="套路写法-1"><a href="#套路写法-1" class="headerlink" title="套路写法"></a>套路写法</h3><p>三层循环<br>一层获取步长<br>一层获取未排序区元素<br>一层找到合适位置插入</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>步长确定后<br>会将所有子序列进行插入排序</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="知识点一-归并排序基本原理"><a href="#知识点一-归并排序基本原理" class="headerlink" title="知识点一 归并排序基本原理"></a>知识点一 归并排序基本原理</h2><p>归并 &#x3D; 递归 + 合并</p>
<p>数组分左右<br>左右元素相比较<br>满足条件放入新数组<br>一侧用完放对面</p>
<p>递归不停分<br>分完再排序<br>排序结束往上走<br>边走边合并<br>走到头顶出结果</p>
<p>归并排序分成两部分 1.基本排序规则 2.递归平分数组</p>
<p>递归平分数组：<br>不停进行分割<br>长度小于 2 停止<br>开始比较<br>一层一层向上比</p>
<p>基本排序规则：<br>左右元素进行比较<br>依次放入新数组中<br>一侧没有了另一侧直接放入新数组</p>
<h2 id="知识点二-代码实现-2"><a href="#知识点二-代码实现-2" class="headerlink" title="知识点二 代码实现"></a>知识点二 代码实现</h2><h3 id="唐老狮做法"><a href="#唐老狮做法" class="headerlink" title="唐老狮做法"></a>唐老狮做法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：</span></span><br><span class="line"><span class="comment">//基本排序规则</span></span><br><span class="line"><span class="comment">//左右元素相比较</span></span><br><span class="line"><span class="comment">//满足条件放进去</span></span><br><span class="line"><span class="comment">//一侧用完直接放</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span>[] <span class="title">Sort</span>(<span class="params"><span class="built_in">int</span>[] left, <span class="built_in">int</span>[] right</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先准备一个新数组</span></span><br><span class="line">    <span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[left.Length + right.Length];</span><br><span class="line">    <span class="built_in">int</span> leftIndex = <span class="number">0</span>;<span class="comment">//左数组索引</span></span><br><span class="line">    <span class="built_in">int</span> rightIndex = <span class="number">0</span>;<span class="comment">//右数组索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终目的是要填满这个新数组</span></span><br><span class="line">    <span class="comment">//不会出现两侧都放完还在进循环</span></span><br><span class="line">    <span class="comment">//因为这个新数组的长度 是根据左右两个数组长度计算出来的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//左侧放完了 直接放对面右侧</span></span><br><span class="line">        <span class="keyword">if</span>( leftIndex &gt;= left.Length )</span><br><span class="line">        &#123;</span><br><span class="line">            array[i] = right[rightIndex];</span><br><span class="line">            <span class="comment">//已经放入了一个右侧元素进入新数组</span></span><br><span class="line">            <span class="comment">//所以 标识应该指向下一个嘛</span></span><br><span class="line">            rightIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右侧放完了 直接放对面左侧</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( rightIndex &gt;= right.Length )</span><br><span class="line">        &#123;</span><br><span class="line">            array[i] = left[leftIndex];</span><br><span class="line">            <span class="comment">//已经放入了一个左侧元素进入新数组</span></span><br><span class="line">            <span class="comment">//所以 标识应该指向下一个嘛</span></span><br><span class="line">            leftIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( left[leftIndex] &lt; right[rightIndex] )</span><br><span class="line">        &#123;</span><br><span class="line">            array[i] = left[leftIndex];</span><br><span class="line">            <span class="comment">//已经放入了一个左侧元素进入新数组</span></span><br><span class="line">            <span class="comment">//所以 标识应该指向下一个嘛</span></span><br><span class="line">            leftIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            array[i] = right[rightIndex];</span><br><span class="line">            <span class="comment">//已经放入了一个右侧元素进入新数组</span></span><br><span class="line">            <span class="comment">//所以 标识应该指向下一个嘛</span></span><br><span class="line">            rightIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到了新数组 直接返回出去</span></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：</span></span><br><span class="line"><span class="comment">//递归平分数组</span></span><br><span class="line"><span class="comment">//结束条件为长度小于2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span>[] <span class="title">Merge</span>(<span class="params"><span class="built_in">int</span>[] array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (array.Length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="comment">//1.数组分两段  得到一个中间索引</span></span><br><span class="line">    <span class="built_in">int</span> mid = array.Length / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//2.初始化左右数组</span></span><br><span class="line">    <span class="comment">//左数组</span></span><br><span class="line">    <span class="built_in">int</span>[] left = <span class="keyword">new</span> <span class="built_in">int</span>[mid];</span><br><span class="line">    <span class="comment">//右数组</span></span><br><span class="line">    <span class="built_in">int</span>[] right = <span class="keyword">new</span> <span class="built_in">int</span>[array.Length - mid];</span><br><span class="line">    <span class="comment">//左右初始化内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mid)</span><br><span class="line">            left[i] = array[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right[i - mid] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.递归再分再排序</span></span><br><span class="line">    <span class="keyword">return</span> Sort(Merge(left), Merge(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更简洁的做法"><a href="#更简洁的做法" class="headerlink" title="更简洁的做法"></a>更简洁的做法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> center = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(nums, left, center);</span><br><span class="line">        MergeSort(nums, center + <span class="number">1</span>, right);</span><br><span class="line">        Merge(nums, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> center = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span> leftIndex = left;</span><br><span class="line">    <span class="built_in">int</span> rightIndex = center + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span>[] tempNums = <span class="keyword">new</span> <span class="built_in">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (leftIndex &lt;= center &amp;&amp; rightIndex &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[leftIndex] &lt; nums[rightIndex])</span><br><span class="line">        &#123;</span><br><span class="line">            tempNums[index++] = nums[leftIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tempNums[index++] = nums[rightIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (leftIndex &lt;= center)</span><br><span class="line">    &#123;</span><br><span class="line">        tempNums[index++] = nums[leftIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (rightIndex &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        tempNums[index++] = nums[rightIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tempNums.Length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[left++] = tempNums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-总结-2"><a href="#知识点三-总结-2" class="headerlink" title="知识点三 总结"></a>知识点三 总结</h2><p>理解递归逻辑<br>一开始不会执行 Sort 函数的<br>要先找到最小容量数组时<br>才会回头递归调用 Sort 进行排序</p>
<p>基本原理<br>归并 &#x3D; 递归 + 合并<br>数组分左右<br>左右元素相比较<br>一侧用完放对面<br>不停放入新数组</p>
<p><strong>递归不停分</strong><br><strong>分完再排序</strong><br><strong>排序结束往上走</strong><br><strong>边走边合并</strong><br><strong>走到头顶出结果</strong></p>
<p>套路写法<br>两个函数<br>一个基本排序规则<br>一个递归平分数组</p>
<p>注意事项<br>排序规则函数 在 平分数组函数<br>内部 return 调用</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="知识点一-快速排序基本原理"><a href="#知识点一-快速排序基本原理" class="headerlink" title="知识点一 快速排序基本原理"></a>知识点一 快速排序基本原理</h2><p>选取基准<br>产生左右标识<br>左右比基准<br>满足则换位</p>
<p>排完一次<br>基准定位</p>
<p>左右递归<br>直到有序</p>
<h2 id="知识点二-代码实现-3"><a href="#知识点二-代码实现-3" class="headerlink" title="知识点二 代码实现"></a>知识点二 代码实现</h2><p>快速排序是不稳定排序</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wusuopubupt/article/details/22743315">为什么快速排序是不稳定的<em>d4shman 的博客-CSDN 博客</em>快排是稳定排序吗</a></p>
<h3 id="唐老狮写法"><a href="#唐老狮写法" class="headerlink" title="唐老狮写法"></a>唐老狮写法</h3><p>有 bug，数组有相同元素的情况下，会死循环。</p>
<p>在查找时加&lt;&#x3D;解决</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：</span></span><br><span class="line"><span class="comment">//申明用于快速排序的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span>(<span class="params"><span class="built_in">int</span>[] array, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第七步：</span></span><br><span class="line">    <span class="comment">//递归函数结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：</span></span><br><span class="line">    <span class="comment">//记录基准值</span></span><br><span class="line">    <span class="comment">//左游标</span></span><br><span class="line">    <span class="comment">//右游标</span></span><br><span class="line">    <span class="built_in">int</span> tempLeft, tempRight, temp;</span><br><span class="line">    temp = array[left];</span><br><span class="line">    tempLeft = left;</span><br><span class="line">    tempRight = right;</span><br><span class="line">    <span class="comment">//第三步：</span></span><br><span class="line">    <span class="comment">//核心交换逻辑</span></span><br><span class="line">    <span class="comment">//左右游标会不同变化 要不相同时才能继续变化</span></span><br><span class="line">    <span class="keyword">while</span>(tempLeft != tempRight)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第四步：比较位置交换</span></span><br><span class="line">        <span class="comment">//首先从右边开始 比较 看值有没有资格放到表示的右侧</span></span><br><span class="line">        <span class="keyword">while</span> (tempLeft &lt; tempRight &amp;&amp;</span><br><span class="line">               array[tempRight] &gt; temp)</span><br><span class="line">        &#123;</span><br><span class="line">            tempRight--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移动结束证明可以换位置</span></span><br><span class="line">        array[tempLeft] = array[tempRight];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面是移动右侧游标</span></span><br><span class="line">        <span class="comment">//接着移动完右侧游标 就要来移动左侧游标</span></span><br><span class="line">        <span class="keyword">while</span> (tempLeft &lt;= tempRight &amp;&amp;</span><br><span class="line">               array[tempLeft] &lt; temp)</span><br><span class="line">        &#123;</span><br><span class="line">            tempLeft++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移动结束证明可以换位置</span></span><br><span class="line">        array[tempRight] = array[tempLeft];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第五步：放置基准值</span></span><br><span class="line">    <span class="comment">//跳出循环后 把基准值放在中间位置</span></span><br><span class="line">    <span class="comment">//此时tempRight和tempLeft一定是相等的</span></span><br><span class="line">    array[tempRight] = temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第六步：</span></span><br><span class="line">    <span class="comment">//递归继续</span></span><br><span class="line">    QuickSort(array, left, tempRight - <span class="number">1</span>);</span><br><span class="line">    QuickSort(array, tempLeft + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化写法"><a href="#优化写法" class="headerlink" title="优化写法"></a>优化写法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RandonPatition(nums, <span class="number">0</span>, nums.Length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RandonPatition</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> mark = r.Next(left, right + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">int</span> temp = nums[left];</span><br><span class="line">        nums[left] = nums[mark];</span><br><span class="line">        nums[mark] = temp;</span><br><span class="line">        <span class="built_in">int</span> index = Patition(nums, left, right);</span><br><span class="line">        RandonPatition(nums, left, index - <span class="number">1</span>);</span><br><span class="line">        RandonPatition(nums, index + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Patition</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> benchMark = nums[left];</span><br><span class="line">    <span class="keyword">while</span> (left != right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &lt;= benchMark)</span><br><span class="line">        &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &gt; benchMark)</span><br><span class="line">        &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[right] = nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[right] = benchMark;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="知识点一-堆排序基本原理"><a href="#知识点一-堆排序基本原理" class="headerlink" title="知识点一 堆排序基本原理"></a>知识点一 堆排序基本原理</h2><p>构建二叉树，大堆顶调整，堆顶往后方，不停变堆顶</p>
<p>关键规则：最大非叶子节点是 数组长度 &#x2F; 2 - 1</p>
<p>父节点和叶子节点：父节点为 i，左节点 2i+1，右节点 2i+2</p>
<h2 id="知识点二-代码实现-4"><a href="#知识点二-代码实现-4" class="headerlink" title="知识点二 代码实现"></a>知识点二 代码实现</h2><p>堆排序的精髓在于，利用数组长度这个参数，每次对其他元素进行 HeapCompare</p>
<p>使得每次排序，忽略最大&#x2F;最小的元素，已达到排序的效果</p>
<h3 id="唐老狮写法-1"><a href="#唐老狮写法-1" class="headerlink" title="唐老狮写法"></a>唐老狮写法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：实现父节点和左右节点比较</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;array&quot;&gt;</span>需要排序的数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;nowIndex&quot;&gt;</span>当前作为根节点的索引<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;arrayLength&quot;&gt;</span>固定一个位置,那么长度就会减去1,是没有确定位置的数组元素长度<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapCompare</span>(<span class="params"><span class="built_in">int</span>[] array, <span class="built_in">int</span> nowIndex, <span class="built_in">int</span> arrayLength</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过传入的索引 得到它对应的左右叶子节点的索引</span></span><br><span class="line">    <span class="comment">//可能算出来的会溢出数组的索引 我们一会再判断</span></span><br><span class="line">    <span class="built_in">int</span> left = <span class="number">2</span> * nowIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> right = <span class="number">2</span> * nowIndex + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//用于记录较大数的索引</span></span><br><span class="line">    <span class="built_in">int</span> biggerIndex = nowIndex;</span><br><span class="line">    <span class="comment">//先比左 再比右</span></span><br><span class="line">    <span class="comment">//不能溢出</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; arrayLength &amp;&amp; array[left] &gt; array[biggerIndex])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//认为目前最大的是左节点 记录索引</span></span><br><span class="line">        biggerIndex = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较右节点</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; arrayLength &amp;&amp; array[right] &gt; array[biggerIndex])</span><br><span class="line">    &#123;</span><br><span class="line">        biggerIndex = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果比较过后 发现最大索引发生变化了 那就以为这要换位置了</span></span><br><span class="line">    <span class="keyword">if</span> (biggerIndex != nowIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = array[nowIndex];</span><br><span class="line">        array[nowIndex] = array[biggerIndex];</span><br><span class="line">        array[biggerIndex] = temp;</span><br><span class="line">        <span class="comment">//通过递归 看是否影响了叶子节点他们的三角关系</span></span><br><span class="line">        HeapCompare(array, biggerIndex, arrayLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步：构建大堆顶</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildBigHeap</span>(<span class="params"><span class="built_in">int</span>[] array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//从最大的非叶子节点索引 开始 不停的往前 去构建大堆顶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = array.Length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        HeapCompare(array, i, array.Length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三步：结合大堆顶和节点比较 实现堆排序 把堆顶不停往后移动</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span>(<span class="params"><span class="built_in">int</span>[] array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构建大堆顶</span></span><br><span class="line">    BuildBigHeap(array);</span><br><span class="line">    <span class="comment">//执行过后</span></span><br><span class="line">    <span class="comment">//最大的数肯定就在最上层</span></span><br><span class="line">    <span class="comment">//往屁股后面放 得到 屁股后面最后一个索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = array.Length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//直接把 堆顶端的数 放到最后一个位置即可</span></span><br><span class="line">        <span class="built_in">int</span> temp = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">        <span class="comment">//重新进行大堆顶调整</span></span><br><span class="line">        HeapCompare(array, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapCompare</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> nowIndex, <span class="built_in">int</span> len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> biggestIndex = nowIndex;</span><br><span class="line">    <span class="built_in">int</span> left = nowIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> right = nowIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; nums[left] &gt; nums[biggestIndex])</span><br><span class="line">    &#123;</span><br><span class="line">        biggestIndex = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; nums[right] &gt; nums[biggestIndex])</span><br><span class="line">    &#123;</span><br><span class="line">        biggestIndex = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (biggestIndex != nowIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = nums[nowIndex];</span><br><span class="line">        nums[nowIndex] = nums[biggestIndex];</span><br><span class="line">        nums[biggestIndex] = temp;</span><br><span class="line">        HeapCompare(nums, biggestIndex, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildHeap</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = nums.Length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        HeapCompare(nums, i, nums.Length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BuildHeap(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = nums.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">        <span class="comment">//堆排序的精髓就在这里，利用数组长度这个参数</span></span><br><span class="line">        <span class="comment">//使得每次排序，忽略最大/最小的元素，已达到排序的效果</span></span><br><span class="line">        HeapCompare(nums, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="知识点三-总结-3"><a href="#知识点三-总结-3" class="headerlink" title="知识点三 总结"></a>知识点三 总结</h2><p>基本原理<br>构建二叉树<br>大堆顶调整<br>堆顶往后方<br>不停变堆顶</p>
<p>套路写法<br>3 个函数<br>1 个堆顶比较<br>1 个构建大堆顶<br>1 个堆排序</p>
<p>重要规则<br>最大非叶子节点索引：数组长度&#x2F;2 - 1<br>父节点和叶子节点索引：父节点为 i，左节点 2i+1，右节点 2i-1</p>
<p>注意：<br>堆是一类特殊的树，堆的通用特点就是父节点会大于或小于所有子节点；</p>
<p>我们并没有真正的把数组变成堆，只是利用了堆的特点来解决排序问题</p>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://clearacg.com">Aki_CCLing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://clearacg.com/posts/1234f57c/">https://clearacg.com/posts/1234f57c/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://clearacg.com" target="_blank">Secret Garden</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Technology/">Technology</a><a class="post-meta__tags" href="/tags/Code/">Code</a></div><div class="post-share"><div class="social-share" data-image="https://pic.imgdb.cn/item/65b2aa8b871b83018a3e31ec.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.staticfile.org/butterfly-extsrc/1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.staticfile.org/butterfly-extsrc/1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/b7e144d1/" title="算法"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/69553946_p0.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-09</div><div class="info-item-2">算法</div></div><div class="info-2"><div class="info-item-1">A 星寻路算法寻路消耗公式：f(寻路消耗)&#x3D;g(离起点距离)+h(离终点距离) 开启列表：记录待检查的节点。关闭列表：记录已检查的节点。 A 星（A*）寻路算法是一种图搜索算法，用于在网格图上找到从起点到终点的最短路径。 基本原理初始化：将起点加入开启列表。设定起点的 g 值为 0，h 值为起点到终点的估算距离。 循环过程：从开启列表中取出 f 值最小的节点作为当前节点。将当前节点从开启列表移到关闭列表。 检查当前节点的所有相邻节点：如果相邻节点是终点，则路径找到，算法结束。如果相邻节点不在关闭列表中，计算其 g 值和 h 值，并将其加入开启列表。如果相邻节点已在开启列表中，检查新的 g 值是否更小，如果是则更新该节点的 g...</div></div></div></a><a class="pagination-related" href="/posts/b8d84677/" title="Git常用操作"><img class="cover" src="https://pic.imgdb.cn/item/65b2a2ed871b83018a2d55de.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-16</div><div class="info-item-2">Git常用操作</div></div><div class="info-2"><div class="info-item-1">Git常用操作 内容及图片来自GeekHour，请关注支持原作者。     初始化设置配置⽤户名 1git config --global user.name &quot;Your Name&quot;  配置邮箱 1git config --global user.email &quot;mail@example.com&quot;  存储配置 1git config --global credential store 创建仓库创建⼀个新的本地仓库 (省略 project-name 则在当前⽬录创建) 1git init &lt;project-name&gt; 克隆⼀个远程仓库。 1git clone &lt;url&gt;  四个区域⼯作区（Working Directory）就是你在电脑⾥能实际看到的⽬录。 暂存区（Stage &#x2F; Index）暂存区也叫索引，⽤来临时存放未提交的内容􀀄 ⼀般在.git⽬录下的index中。 本地仓库（Repository）Git在本地的版本库，仓库信息存储在.git这个隐藏⽬录中。 远程仓库（Remote...</div></div></div></a><a class="pagination-related" href="/posts/978bdfbc/" title="Unity 学习路线"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-05</div><div class="info-item-2">Unity 学习路线</div></div><div class="info-2"><div class="info-item-1"> 内容参考：课程内容及架构 : 唐老狮 唐老狮的 B 站空间内容整理、面试题整理 : 人间自有韬哥在 人间自有韬哥在的博客盘子 ssa : 盘子 ssa&#x2F;个人学习笔记litfire : 2024 年 Unity 面试题和日常问题总结  CSharp目录传送门 : CSharp 知识目录 CSharp 入门文章传送门 : CSharp 入门 知识点主要内容包括变量、常量、转义字符、类型转换、异常捕获、运算符、条件分支语句、循环语句 CSharp 基础文章传送门 : CSharp 基础主要包括枚举、数组、值类型和引用类型、函数（ref 和 out、参数、重载、递归）、结构体、冒泡排序、递归排序 CSharp 核心文章传送门 : CSharp 核心 主要包括枚举、面向对象（封装、继承、多态） 封装：类和对象、成员变量、成员方法、构造函数、析构函数、成员属性、索引器、静态成员、静态类和静态构造函数、拓展方法、运算符重载 继承：里氏替换原则、继承中的构造函数、万物之父和装箱拆箱、密封类 多态：Vob、抽象类和抽象方法、接口、密封方法 以及七大原则 CSharp 进阶文章传送门...</div></div></div></a><a class="pagination-related" href="/posts/53b59015/" title="Unity 面试题 - CSharp 相关 Part 1"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-06</div><div class="info-item-2">Unity 面试题 - CSharp 相关 Part 1</div></div><div class="info-2"><div class="info-item-1">🟡: 代表个人还有一些理解上的问题🟢: 代表自己面试中被问到过🔴: 代表问题内容未完成 List请说明 C# 中的 List 是如何扩容的C#中的 List 是一个动态数组，其容量可以根据需要动态扩展。初始容量：List在创建时可以指定初始容量（capacity），如果没有指定，则初始容量默认为 0。 自动扩容：当添加元素导致当前容量不足时，List会自动扩容。扩容时，List会分配一个新的数组，并将现有元素复制到新数组中。 扩容倍数：扩容时，新数组的容量通常是旧容量的两倍。这种倍增策略有助于减少频繁分配内存和数据复制的开销。 1234567891011121314151617181920212223242526272829303132using System;using System.Collections.Generic;class Program&#123;    static void Main()    &#123;        // 创建一个初始容量为2的List        List&lt;int&gt; numbers = new...</div></div></div></a><a class="pagination-related" href="/posts/1c8fef53/" title="Unity 面试题 - CSharp 相关 Part 2"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-07</div><div class="info-item-2">Unity 面试题 - CSharp 相关 Part 2</div></div><div class="info-2"><div class="info-item-1">请问什么是线程安全？如何在 C#中实现线程安全操作？C#中属性(Property)和字段(Field)的区别是什么？请解释一下 C#中的异步编程模型（Async&#x2F;Await），它是用来做什么的？请问七大排序算法一般指哪七种排序算法？你一般常用的排序算法是哪种？请简单描述它的排序原理 请简单描述斐波那契数列的基本规则是什么请简单描述 A 星寻路算法的基本原理抽象类中的虚函数和抽象函数，是否必须在子类中重写？当我们使用里式替换原则，用父类容器装载子类对象时我们通过该父类容器调用其中的一个虚函数，执行的逻辑是父类中的还是子类中的逻辑呢？ 我们在游戏开发时，想要获取系统时间，应该如何获取？C#使用 var 声明临时变量相比用指定变量类型声明临时变量，在最终执行时是否会增加性能消耗？int a &#x3D; 10;int b &#x3D; a;b &#x3D; 20;我们知道，上述代码 b 改为 20 后，a 还是 10。（值类型的特点）我们是否可以简单修改以上代码，让 b 变成 20 后，a 跟着一起变。请说出修改方案 我们可以使用...</div></div></div></a><a class="pagination-related" href="/posts/cbdf6728/" title="Unity 面试题 - Lua 相关"><img class="cover" src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-06</div><div class="info-item-2">Unity 面试题 - Lua 相关</div></div><div class="info-2"><div class="info-item-1">热更新流程简述获取对比文件：从远程服务器下载一个用于对比的文件，该文件记录了当前可用资源的版本号或哈希值等信息。 对比本地资源和远程资源：将下载的对比文件与本地保存的对比文件进行比较，以确定本地资源和远程资源之间的差异。根据比较结果，确定需要更新的资源和需要移除的资源。 资源更新和移除：下载远程服务器上与本地资源不同的更新文件，并覆盖本地对应的资源文件，或者直接将更新的资源文件添加到本地资源目录。根据对比结果，删除本地不再需要的资源文件。 更新对比文件：将下载的远程对比文件替换本地保存的对比文件，以保持本地对比文件与服务器端一致，为下一次热更新做准备。 在 Unity 中 AssetBundle 的压缩方式有不压缩、LZMA、LZ4 三种，请问 LZMA 和 LZ4 有什么区别？🟡 Lua 面向对象的三大特性Lua 如何实现面向对象的三大特性 封装：可以通过 table 进行实现。在 Lua 中，我们可以将对象的属性和方法放入一个 table 中，然后对该 table 进行操作，从而达到封装的效果。 1234567891011121314151617Object =...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/65b2a3e9871b83018a2fa6bd.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Aki_CCLing</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/AkiCCLing" target="_blank" title="GitHub"><i class="fa-brands fa-github" style="color: #1E3050;"></i></a><a class="social-icon" href="https://space.bilibili.com/5840406" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color: #FF6699;"></i></a><a class="social-icon" href="https://steamcommunity.com/id/AKIYC/" target="_blank" title="Steam"><i class="fa-brands fa-steam" style="color: #1E3050;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一个ACGN爱好者的Blog，有问题与我交流可在Bilibili 留言 / 私信，谢谢你的关注。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayList-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">ArrayList 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-ArrayList-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.1.</span> <span class="toc-text">知识点一 ArrayList 的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.</span> <span class="toc-text">知识点二 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9"><span class="toc-number">1.3.</span> <span class="toc-text">知识点三 增删查改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-number">1.4.</span> <span class="toc-text">知识点四 装箱拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B8%80%EF%BC%9A%E8%AF%B7%E7%AE%80%E8%BF%B0-ArrayList-%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">练习题一：请简述 ArrayList 和数组的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stack-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">Stack 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-Stack-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.1.</span> <span class="toc-text">知识点一 Stack 的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E5%A3%B0%E6%98%8E-1"><span class="toc-number">2.2.</span> <span class="toc-text">知识点二 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E5%A2%9E%E5%8F%96%E6%9F%A5%E6%94%B9"><span class="toc-number">2.3.</span> <span class="toc-text">知识点三 增取查改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E9%81%8D%E5%8E%86"><span class="toc-number">2.4.</span> <span class="toc-text">知识点四 遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%94-%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-number">2.5.</span> <span class="toc-text">知识点五 装箱拆箱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Queue-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">Queue 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-Queue-%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.1.</span> <span class="toc-text">知识点一 Queue 本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E5%A3%B0%E6%98%8E-2"><span class="toc-number">3.2.</span> <span class="toc-text">知识点二 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E5%A2%9E%E5%8F%96%E6%9F%A5%E6%94%B9-1"><span class="toc-number">3.3.</span> <span class="toc-text">知识点三 增取查改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E9%81%8D%E5%8E%86-1"><span class="toc-number">3.4.</span> <span class="toc-text">知识点四 遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%94-%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1-1"><span class="toc-number">3.5.</span> <span class="toc-text">知识点五 装箱拆箱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hashtable-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">Hashtable 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-Hashtalbe-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.1.</span> <span class="toc-text">知识点一 Hashtalbe 的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E5%A3%B0%E6%98%8E-3"><span class="toc-number">4.2.</span> <span class="toc-text">知识点二 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-1"><span class="toc-number">4.3.</span> <span class="toc-text">知识点三 增删查改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E9%81%8D%E5%8E%86-2"><span class="toc-number">4.4.</span> <span class="toc-text">知识点四 遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%94-%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1-2"><span class="toc-number">4.5.</span> <span class="toc-text">知识点五 装箱拆箱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">5.</span> <span class="toc-text">泛型 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E6%B3%9B%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.1.</span> <span class="toc-text">知识点一 泛型是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E6%B3%9B%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">知识点二 泛型分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.3.</span> <span class="toc-text">知识点三 泛型类和接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">知识点四 泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.1.</span> <span class="toc-text">普通类中的泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.2.</span> <span class="toc-text">泛型类中的泛型方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%94-%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.5.</span> <span class="toc-text">知识点五 泛型的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">泛型约束 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.1.</span> <span class="toc-text">知识点一 什么是泛型约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E5%90%84%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E8%AE%B2%E8%A7%A3"><span class="toc-number">6.2.</span> <span class="toc-text">知识点二 各泛型约束讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.2.1.</span> <span class="toc-text">值类型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.2.2.</span> <span class="toc-text">引用类型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.2.3.</span> <span class="toc-text">公共无参构造约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.2.4.</span> <span class="toc-text">类约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.2.5.</span> <span class="toc-text">接口约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.2.6.</span> <span class="toc-text">另一个泛型约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E7%BA%A6%E6%9D%9F%E7%9A%84%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">知识点三 约束的组合使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E5%A4%9A%E4%B8%AA%E6%B3%9B%E5%9E%8B%E6%9C%89%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.4.</span> <span class="toc-text">知识点四 多个泛型有约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">6.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">7.</span> <span class="toc-text">List 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-List-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">7.1.</span> <span class="toc-text">知识点一 List 的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E5%A3%B0%E6%98%8E-4"><span class="toc-number">7.2.</span> <span class="toc-text">知识点二 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-2"><span class="toc-number">7.3.</span> <span class="toc-text">知识点三 增删查改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E9%81%8D%E5%8E%86-3"><span class="toc-number">7.4.</span> <span class="toc-text">知识点四 遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dictionary-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">8.</span> <span class="toc-text">Dictionary 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-Dictionary-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">8.1.</span> <span class="toc-text">知识点一 Dictionary 的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E5%A3%B0%E6%98%8E-5"><span class="toc-number">8.2.</span> <span class="toc-text">知识点二 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-3"><span class="toc-number">8.3.</span> <span class="toc-text">知识点三 增删查改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E9%81%8D%E5%8E%86-4"><span class="toc-number">8.4.</span> <span class="toc-text">知识点四 遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">9.</span> <span class="toc-text">顺序存储和链式存储 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.1.</span> <span class="toc-text">知识点一 数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">9.2.</span> <span class="toc-text">知识点二 线性表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">9.3.</span> <span class="toc-text">知识点三 顺序存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">9.4.</span> <span class="toc-text">知识点四 链式存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%94-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">9.5.</span> <span class="toc-text">知识点五 自己实现一个最简单的单向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%AD-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">9.6.</span> <span class="toc-text">知识点六 顺序存储和链式存储的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B8%89-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">9.7.</span> <span class="toc-text">练习题三-实现双向链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LinkedList-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">10.</span> <span class="toc-text">LinkedList 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-LinkedList"><span class="toc-number">10.1.</span> <span class="toc-text">知识点一 LinkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E5%A3%B0%E6%98%8E-6"><span class="toc-number">10.2.</span> <span class="toc-text">知识点二 声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-4"><span class="toc-number">10.3.</span> <span class="toc-text">知识点三 增删查改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E9%81%8D%E5%8E%86-5"><span class="toc-number">10.4.</span> <span class="toc-text">知识点四 遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">11.</span> <span class="toc-text">泛型栈和队列 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E5%9B%9E%E9%A1%BE%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8"><span class="toc-number">11.1.</span> <span class="toc-text">知识点一 回顾数据容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">11.2.</span> <span class="toc-text">知识点二 泛型栈和队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">11.3.</span> <span class="toc-text">练习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A7%94%E6%89%98-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">12.</span> <span class="toc-text">委托 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.1.</span> <span class="toc-text">知识点一 委托是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">知识点二 基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E5%AE%9A%E4%B9%89%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A7%94%E6%89%98"><span class="toc-number">12.3.</span> <span class="toc-text">知识点三 定义自定义委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E4%BD%BF%E7%94%A8%E5%AE%9A%E4%B9%89%E5%A5%BD%E7%9A%84%E5%A7%94%E6%89%98"><span class="toc-number">12.4.</span> <span class="toc-text">知识点四 使用定义好的委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%94-%E5%A7%94%E6%89%98%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0-%E5%A4%9A%E6%92%AD%E5%A7%94%E6%89%98"><span class="toc-number">12.5.</span> <span class="toc-text">知识点五 委托变量可以存储多个函数(多播委托)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%AD-%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89%E5%A5%BD%E7%9A%84%E5%A7%94%E6%89%98"><span class="toc-number">12.6.</span> <span class="toc-text">知识点六 系统定义好的委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">12.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">13.</span> <span class="toc-text">事件 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">13.1.</span> <span class="toc-text">知识点一 事件是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">13.2.</span> <span class="toc-text">知识点二 事件的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">13.3.</span> <span class="toc-text">知识点三 为什么有事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">13.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">14.</span> <span class="toc-text">匿名函数 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">14.1.</span> <span class="toc-text">知识点一 什么是匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">14.2.</span> <span class="toc-text">知识点二 基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E4%BD%BF%E7%94%A8"><span class="toc-number">14.3.</span> <span class="toc-text">知识点三 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%97%A0%E8%BF%94%E5%9B%9E"><span class="toc-number">14.3.1.</span> <span class="toc-text">无参无返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%8F%82"><span class="toc-number">14.3.2.</span> <span class="toc-text">有参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">14.3.3.</span> <span class="toc-text">有返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">14.3.4.</span> <span class="toc-text">一般使用情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">14.4.</span> <span class="toc-text">知识点四 匿名函数的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">14.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">15.</span> <span class="toc-text">lambda 表达式 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AF-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">15.1.</span> <span class="toc-text">知识点一 什么是 lambda 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="toc-number">15.2.</span> <span class="toc-text">知识点二 lambda 表达式语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E4%BD%BF%E7%94%A8-1"><span class="toc-number">15.3.</span> <span class="toc-text">知识点三 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E9%97%AD%E5%8C%85"><span class="toc-number">15.4.</span> <span class="toc-text">知识点四 闭包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A7%94%E6%89%98-%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">16.</span> <span class="toc-text">委托 补充知识点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List-%E6%8E%92%E5%BA%8F-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">17.</span> <span class="toc-text">List 排序 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-List-%E8%87%AA%E5%B8%A6%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="toc-number">17.1.</span> <span class="toc-text">知识点一 List 自带排序方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">17.2.</span> <span class="toc-text">知识点二 自定义类的排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CompareTo-%E5%87%BD%E6%95%B0"><span class="toc-number">17.2.1.</span> <span class="toc-text">CompareTo 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E9%80%9A%E8%BF%87%E5%A7%94%E6%89%98%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">17.3.</span> <span class="toc-text">知识点三 通过委托函数进行排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">17.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">18.</span> <span class="toc-text">协变逆变 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98"><span class="toc-number">18.1.</span> <span class="toc-text">知识点一 什么是协变逆变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E4%BD%9C%E7%94%A8"><span class="toc-number">18.2.</span> <span class="toc-text">知识点二 作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-%E5%92%8C-%E5%8F%82%E6%95%B0"><span class="toc-number">18.2.1.</span> <span class="toc-text">返回值 和 参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E4%BD%9C%E7%94%A8%EF%BC%88%E7%BB%93%E5%90%88%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%E7%90%86%E8%A7%A3%EF%BC%89"><span class="toc-number">18.3.</span> <span class="toc-text">知识点二 作用（结合里氏替换原则理解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">18.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">19.</span> <span class="toc-text">多线程 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E4%BA%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E5%89%8D%E5%85%88%E4%BA%86%E8%A7%A3%E8%BF%9B%E7%A8%8B"><span class="toc-number">19.1.</span> <span class="toc-text">知识点一 了解线程前先了解进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="toc-number">19.2.</span> <span class="toc-text">知识点二 什么是线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">19.3.</span> <span class="toc-text">知识点三 什么是多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3"><span class="toc-number">19.4.</span> <span class="toc-text">知识点四 语法相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">19.4.1.</span> <span class="toc-text">1.声明一个新的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">19.4.2.</span> <span class="toc-text">2.启动线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">19.4.3.</span> <span class="toc-text">3.设置为后台线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B3%E9%97%AD%E9%87%8A%E6%94%BE%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">19.4.4.</span> <span class="toc-text">4.关闭释放一个线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%B8%AD-bool-%E6%A0%87%E8%AF%86"><span class="toc-number">19.4.4.1.</span> <span class="toc-text">4.1-死循环中 bool 标识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E9%80%9A%E8%BF%87%E7%BA%BF%E7%A8%8B%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">19.4.4.2.</span> <span class="toc-text">4.2-通过线程提供的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="toc-number">19.4.5.</span> <span class="toc-text">5.线程休眠</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%94-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-number">19.5.</span> <span class="toc-text">知识点五 线程之间共享数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%AD-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AF%B9%E4%BA%8E%E6%88%91%E4%BB%AC%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">19.6.</span> <span class="toc-text">知识点六 多线程对于我们的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">19.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">20.</span> <span class="toc-text">预处理器指令 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">20.1.</span> <span class="toc-text">知识点一 什么是编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">20.2.</span> <span class="toc-text">知识点二 什么是预处理器指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">20.3.</span> <span class="toc-text">知识点三 常见的预处理器指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#define%EF%BC%8C-undef"><span class="toc-number">20.3.1.</span> <span class="toc-text">#define，#undef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if%EF%BC%8C-elif%EF%BC%8C-else%EF%BC%8C-endif"><span class="toc-number">20.3.2.</span> <span class="toc-text">#if，#elif，#else，#endif</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#warning%EF%BC%8C-error"><span class="toc-number">20.3.3.</span> <span class="toc-text">#warning，#error</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">20.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%85%B3%E9%94%AE%E7%B1%BB-Type-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">21.</span> <span class="toc-text">反射概念和关键类 Type 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="toc-number">21.1.</span> <span class="toc-text">知识点一 什么是程序集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">21.2.</span> <span class="toc-text">知识点二 元数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">21.3.</span> <span class="toc-text">知识点三 反射的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">21.4.</span> <span class="toc-text">知识点四 反射的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%94-%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3"><span class="toc-number">21.5.</span> <span class="toc-text">知识点五 语法相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Type"><span class="toc-number">21.5.1.</span> <span class="toc-text">Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Type"><span class="toc-number">21.5.2.</span> <span class="toc-text">获取 Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="toc-number">21.5.3.</span> <span class="toc-text">获取程序集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%AC%E5%85%B1%E6%88%90%E5%91%98"><span class="toc-number">21.5.4.</span> <span class="toc-text">获取类中的所有公共成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%85%AC%E5%85%B1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B9%B6%E8%B0%83%E7%94%A8"><span class="toc-number">21.5.5.</span> <span class="toc-text">获取类的公共构造函数并调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%85%AC%E5%85%B1%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">21.5.6.</span> <span class="toc-text">获取类的公共成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%85%AC%E5%85%B1%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">21.5.7.</span> <span class="toc-text">获取类的公共成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">21.5.8.</span> <span class="toc-text">其它</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%B1%BB-Assembly-%E5%92%8C-Activator-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">22.</span> <span class="toc-text">关键类 Assembly 和 Activator 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Activator"><span class="toc-number">22.1.</span> <span class="toc-text">Activator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Assembly"><span class="toc-number">22.2.</span> <span class="toc-text">Assembly</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%E9%9B%86%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">22.2.1.</span> <span class="toc-text">三种加载程序集的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">22.2.2.</span> <span class="toc-text">加载过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%BA%93%E5%B7%A5%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">22.3.</span> <span class="toc-text">类库工程创建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%80%A7-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">23.</span> <span class="toc-text">特性 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">23.1.</span> <span class="toc-text">知识点一 特性是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7"><span class="toc-number">23.2.</span> <span class="toc-text">知识点二 自定义特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">23.3.</span> <span class="toc-text">知识点三 特性的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">23.3.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E4%BA%86%E6%9F%90%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="toc-number">23.3.2.</span> <span class="toc-text">判断是否使用了某个特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Type-%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%89%B9%E6%80%A7"><span class="toc-number">23.3.3.</span> <span class="toc-text">获取 Type 元数据中的所有特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E9%99%90%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">23.4.</span> <span class="toc-text">知识点四 限制自定义特性的使用范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%94-%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E8%BF%87%E6%97%B6%E7%89%B9%E6%80%A7"><span class="toc-number">23.5.</span> <span class="toc-text">知识点五 系统自带特性——过时特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%AD-%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E8%80%85%E4%BF%A1%E6%81%AF%E7%89%B9%E6%80%A7"><span class="toc-number">23.6.</span> <span class="toc-text">知识点六 系统自带特性——调用者信息特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%83-%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E7%89%B9%E6%80%A7"><span class="toc-number">23.7.</span> <span class="toc-text">知识点七 系统自带特性——条件编译特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%AB-%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E5%A4%96%E9%83%A8-Dll-%E5%8C%85%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7"><span class="toc-number">23.8.</span> <span class="toc-text">知识点八 系统自带特性——外部 Dll 包函数特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-number">23.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">24.</span> <span class="toc-text">迭代器 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">24.1.</span> <span class="toc-text">知识点一 迭代器是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E6%A0%87%E5%87%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">24.2.</span> <span class="toc-text">知识点二 标准迭代器的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IEnumerator"><span class="toc-number">24.2.1.</span> <span class="toc-text">IEnumerator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IEnumerable"><span class="toc-number">24.2.2.</span> <span class="toc-text">IEnumerable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach-%E6%9C%AC%E8%B4%A8"><span class="toc-number">24.2.3.</span> <span class="toc-text">foreach 本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">24.2.4.</span> <span class="toc-text">标准迭代器的实现方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E7%94%A8-yield-return-%E8%AF%AD%E6%B3%95%E7%B3%96%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">24.3.</span> <span class="toc-text">知识点三 用 yield return 语法糖实现迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#yield-return"><span class="toc-number">24.3.1.</span> <span class="toc-text">yield return</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-yield-return-%E8%AF%AD%E6%B3%95%E7%B3%96%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">24.3.2.</span> <span class="toc-text">用 yield return 语法糖实现迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E7%94%A8-yield-return-%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B8%BA%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">24.4.</span> <span class="toc-text">知识点四 用 yield return 语法糖为泛型类实现迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-number">24.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">25.</span> <span class="toc-text">特殊语法 知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-var-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">25.1.</span> <span class="toc-text">知识点一 var 隐式类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%80%BC%EF%BC%8C%E5%A4%A7%E6%8B%AC%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B3%95"><span class="toc-number">25.2.</span> <span class="toc-text">知识点二 设置对象初始值，大括号初始化法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E8%AE%BE%E7%BD%AE%E9%9B%86%E5%90%88%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">25.3.</span> <span class="toc-text">知识点三 设置集合初始值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">25.4.</span> <span class="toc-text">知识点四 匿名类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%94-%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">25.5.</span> <span class="toc-text">知识点五 可空类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%8C"><span class="toc-number">25.5.1.</span> <span class="toc-text">?.，?[]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%AD-%E7%A9%BA%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">25.6.</span> <span class="toc-text">知识点六 空合并操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%83-%E5%86%85%E6%8F%92%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">25.7.</span> <span class="toc-text">知识点七 内插字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%AB-%E5%8D%95%E5%8F%A5%E9%80%BB%E8%BE%91%E7%AE%80%E7%95%A5%E5%86%99%E6%B3%95"><span class="toc-number">25.8.</span> <span class="toc-text">知识点八 单句逻辑简略写法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%A1%A5%E5%85%85"><span class="toc-number">26.</span> <span class="toc-text">值和引用类型补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="toc-number">26.1.</span> <span class="toc-text">知识回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">26.2.</span> <span class="toc-text">问题一 如何判断 值类型和引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C-%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-number">26.3.</span> <span class="toc-text">问题二 语句块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%89-%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">26.4.</span> <span class="toc-text">问题三 变量的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9B%9B-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">26.5.</span> <span class="toc-text">问题四 结构体中的值和引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%94-%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">26.6.</span> <span class="toc-text">问题五 类中的值和引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%85%AD-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E8%A7%84%E5%88%99"><span class="toc-number">26.7.</span> <span class="toc-text">问题六 数组中的存储规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%83-%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">26.8.</span> <span class="toc-text">问题七 结构体继承接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">27.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">27.1.</span> <span class="toc-text">知识点一 插入排序的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">27.2.</span> <span class="toc-text">知识点二 代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E6%80%BB%E7%BB%93"><span class="toc-number">27.3.</span> <span class="toc-text">知识点三 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%B8%A4%E5%B1%82%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="toc-number">27.3.1.</span> <span class="toc-text">为什么有两层循环？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E4%B8%80%E5%B1%82%E5%BE%AA%E7%8E%AF%E4%BB%8E-1-%E5%BC%80%E5%A7%8B%E9%81%8D%E5%8E%86%EF%BC%9F"><span class="toc-number">27.3.2.</span> <span class="toc-text">为什么第一层循环从 1 开始遍历？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-while-%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="toc-number">27.3.3.</span> <span class="toc-text">为什么使用 while 循环？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%BE%80%E5%90%8E%E7%A7%BB%E4%BD%8D%E7%BD%AE"><span class="toc-number">27.3.4.</span> <span class="toc-text">为什么可以直接往后移位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A1%AE%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%90%8E-%E6%98%AF%E6%94%BE%E5%9C%A8-sortIndex-1-%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">27.3.5.</span> <span class="toc-text">为什么确定位置后,是放在 sortIndex + 1 的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">27.3.6.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E8%B7%AF%E5%86%99%E6%B3%95"><span class="toc-number">27.3.7.</span> <span class="toc-text">套路写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">27.3.8.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">28.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">28.1.</span> <span class="toc-text">知识点一 希尔排序的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">28.2.</span> <span class="toc-text">知识点二 代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E6%80%BB%E7%BB%93-1"><span class="toc-number">28.3.</span> <span class="toc-text">知识点三 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-1"><span class="toc-number">28.3.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F"><span class="toc-number">28.3.2.</span> <span class="toc-text">具体排序方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E8%B7%AF%E5%86%99%E6%B3%95-1"><span class="toc-number">28.3.3.</span> <span class="toc-text">套路写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">28.3.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">29.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">29.1.</span> <span class="toc-text">知识点一 归并排序基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">29.2.</span> <span class="toc-text">知识点二 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%90%E8%80%81%E7%8B%AE%E5%81%9A%E6%B3%95"><span class="toc-number">29.2.1.</span> <span class="toc-text">唐老狮做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E7%AE%80%E6%B4%81%E7%9A%84%E5%81%9A%E6%B3%95"><span class="toc-number">29.2.2.</span> <span class="toc-text">更简洁的做法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E6%80%BB%E7%BB%93-2"><span class="toc-number">29.3.</span> <span class="toc-text">知识点三 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">30.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">30.1.</span> <span class="toc-text">知识点一 快速排序基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">30.2.</span> <span class="toc-text">知识点二 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%90%E8%80%81%E7%8B%AE%E5%86%99%E6%B3%95"><span class="toc-number">30.2.1.</span> <span class="toc-text">唐老狮写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%86%99%E6%B3%95"><span class="toc-number">30.2.2.</span> <span class="toc-text">优化写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">31.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80-%E5%A0%86%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">31.1.</span> <span class="toc-text">知识点一 堆排序基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">31.2.</span> <span class="toc-text">知识点二 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%90%E8%80%81%E7%8B%AE%E5%86%99%E6%B3%95-1"><span class="toc-number">31.2.1.</span> <span class="toc-text">唐老狮写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-number">31.2.2.</span> <span class="toc-text">重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89-%E6%80%BB%E7%BB%93-3"><span class="toc-number">31.3.</span> <span class="toc-text">知识点三 总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/1161385d/" title="广州 ACGN 地点游玩推荐 / 攻略"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/noet8h3s.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="广州 ACGN 地点游玩推荐 / 攻略"/></a><div class="content"><a class="title" href="/posts/1161385d/" title="广州 ACGN 地点游玩推荐 / 攻略">广州 ACGN 地点游玩推荐 / 攻略</a><time datetime="2025-02-19T00:41:54.000Z" title="发表于 2025-02-19 00:41:54">2025-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e7073109/" title="Blog更新记录"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/qungz.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Blog更新记录"/></a><div class="content"><a class="title" href="/posts/e7073109/" title="Blog更新记录">Blog更新记录</a><time datetime="2024-11-27T21:01:33.000Z" title="发表于 2024-11-27 21:01:33">2024-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/37d9abb5%60/" title="Unity 面试高频题"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity 面试高频题"/></a><div class="content"><a class="title" href="/posts/37d9abb5%60/" title="Unity 面试高频题">Unity 面试高频题</a><time datetime="2024-08-26T02:07:45.000Z" title="发表于 2024-08-26 02:07:45">2024-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/df5996f0/" title="Unity 面试题杂项"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/UNITY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity 面试题杂项"/></a><div class="content"><a class="title" href="/posts/df5996f0/" title="Unity 面试题杂项">Unity 面试题杂项</a><time datetime="2024-08-10T23:05:48.000Z" title="发表于 2024-08-10 23:05:48">2024-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b7e144d1/" title="算法"><img src="https://blogimage-1258650140.cos.ap-nanjing.myqcloud.com/blog/69553946_p0.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法"/></a><div class="content"><a class="title" href="/posts/b7e144d1/" title="算法">算法</a><time datetime="2024-08-09T20:44:54.000Z" title="发表于 2024-08-09 20:44:54">2024-08-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Aki_CCLing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20238180" target="_blank">萌ICP备20238180号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.5"></script><script src="/js/main.js?v=5.3.5"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://venerable-smakager-94ad33.netlify.app/.netlify/functions/twikoo',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://venerable-smakager-94ad33.netlify.app/.netlify/functions/twikoo',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.staticfile.org/twikoo/1.6.41/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>